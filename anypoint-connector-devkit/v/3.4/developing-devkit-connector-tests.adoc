= 开发DevKit连接器测试

尽管DevKit没有强制执行写入测试，但强烈建议您为连接器开发单元和功能测试，作为开发过程的一部分。没有测试套件，不应将连接器视为生产就绪。

虽然测试策略可能会根据您的特定需求而大不相同，但本文档介绍了Mule和DevKit可用于支持测试工作的基础知识。


== 假设

本文档假定您熟悉Java IDE（Eclipse或IntelliJ）并熟悉Maven Maven构建管理器的Java。它还假定您正在开发过程中为新连接器准备测试套件。

要测试的== 个区域

接下来是你应该加入你的测试套件的测试的快速分解：

.  *Input data validation*：由于您的扩展可能需要从其他应用程序获取用户参数或参数，因此请对其接收的输入执行一些一致性检查。云服务采取的一些参数可能是可选的，而其他参数则必须遵守某些规则。实施单元测试，为每个连接器的方法分配有效或无效的输入，并检查输入验证是否相应响应。
.  *API Interaction*：由于连接器通常通过Internet与远程服务进行通信，因此连接器应处理连接或通信错误，通常通过重试或抛出明确的异常来处理。无论您选择哪种错误处理策略，都要确保测试错误处理。您可能需要模拟测试Web服务。将连接器指向测试端点而不是生产目标，以便您可以更轻松地重现错误状况，如超时或连接丢失。
.  *Mule ESB Integration*：当您创建一个新连接器时，确保您的测试套件覆盖了所有操作。它应该通过并接收所有合理的输入和输出到每个操作。请特别注意覆盖传入和接收来自XML操作的复杂数据类型，因为这些可能会非常棘手。测试XML中默认和可选参数值的使用，以确保它们的行为与预期相符。通常，每个操作和参数至少测试一次。最后，确保测试您希望连接器引发异常的情况。
.  *Studio Integration*：您的连接器在Studio中的外观和可用性也应该进行测试。在属性对话框中包含行为和提示，从Javadoc注释中生成工具提示等。测试此方法的唯一方法是在Studio中手动使用连接器。

== 生成DevKit测试用例骨架

当Maven创建一个基于DevKit原型的新项目时，生成的项目将包含一个测试用例框架。这个测试类有一些帮助器方法和注释，可以让你了解如何开始使用Mule配置中的流编写单元测试。在文件夹`src/test/java`中找到该文件，文件名为`<yourConnectorName>test.java`。

请注意，Java类继承自 http://www.mulesoft.org/docs/site/3.0.0/apidocs/org/mule/tck/FunctionalTestCase.html[FunctionalTestCase]，这是Mule ESB中所有功能测试的基类。

[%header%autowidth.spread]
|===
^ |示例test.java文件
一个|
[source, code, linenums]
----
/**
* This file was automatically generated by the Mule Development Kit
*/
 
package com.mulesoft.hello;
import org.mule.api.MuleEvent;
import org.mule.construct.Flow;
import org.mule.tck.FunctionalTestCase;
import org.mule.tck.AbstractMuleTestCase;
import org.junit.Test;
 
public class helloConnectorTest extends FunctionalTestCase
{
    @Override protected String getConfigResources()
    {
        return "mule-config.xml";
    }
 
    @Test public void testFlow() throws Exception
    {
        runFlowAndExpect("testFlow", "Another string");
    }
 
    /**
    * Run the flow specified by name and assert equality on the expected output
    *
    * @param flowName The name of the flow to run
    * @param expect The expected output
    */
 
    protected <T> void runFlowAndExpect(String flowName, T expect)
    throws Exception
    {
        Flow flow = lookupFlowConstruct(flowName);
        MuleEvent event = AbstractMuleTestCase.getTestEvent(null);
        MuleEvent responseEvent = flow.process(event);
        assertEquals(expect, responseEvent.getMessage().getPayload());
    }
 
    /**
    * Run the flow specified by name using the specified payload and assert
    * equality on the expected output
    *
    * @param flowName The name of the flow to run
    * @param expect The expected output
    * @param payload The payload of the input event
    */
 
    protected <T, U> void runFlowWithPayloadAndExpect(String flowName, T expect, U payload)
    throws Exception
    {
        Flow flow = lookupFlowConstruct(flowName);
        MuleEvent event = AbstractMuleTestCase.getTestEvent(payload);
        MuleEvent responseEvent = flow.process(event);
        assertEquals(expect, responseEvent.getMessage().getPayload());
    }
 
    /**
    * Retrieve a flow by name from the registry
    *
    * @param name Name of the flow to retrieve
    */
    protected Flow lookupFlowConstruct(String name)
    {
        return (Flow) AbstractMuleTestCase.muleContext.getRegistry().lookupFlowConstruct(name);
    }
}
----
|===

请注意，Java代码`getConfigResources()`引用了一个XML文件。 DevKit测试框架在**`src/test/resources` **文件夹中查找指定的文件。显示的默认XML文件显示为*below*：

[source, xml, linenums]
----
<mule xmlns="http://www.mulesoft.org/schema/mule/core"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:spring="http://www.springframework.org/schema/beans"
   xmlns:hello="http://www.mulesoft.org/schema/mule/hello"
   xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd http://www.mulesoft.org/schema/mule/hello http://www.mulesoft.org/schema/mule/hello/1.0-SNAPSHOT/mule-hello.xsd">
 
  <hello:config myProperty="Some string" username="xxx" password="yyy"/>
 
  <flow name="testFlow">
    <hello:my-processor content="Another string"/>
  </flow>
</mule>
----

== 生成的测试类：帮助器方法

测试类定义了构建单独测试时使用的许多有用的帮助器方法

===  runFlowAndExpect

该方法需要两个参数：

[%header%autowidth.spread]
|===
| {名称{1}}说明
| `flowName`  | Mule流程运行
| `expect`  |测试的预期输出
|===

在默认测试中，XML文件加载`myProperty`值为`Another string`，该值与`testFlow`方法设置的`expect`参数匹配并通过测试。

我们来深入研究一下这个方法。

首先，方法`lookupFlowConstruct`（声明*below*）查找您在项目XML配置中的参数中设置的流程：

[source, code, linenums]
----
Flow flow = lookupFlowConstruct(flowName);
----

然后，两行产生一个测试事件并启动流程：

[source, code, linenums]
----
MuleEvent event = getTestEvent(null);
MuleEvent responseEvent = flow.process(event);
----

最后一行将测试的输出与您设置为方法参数的预期输出进行比较：

[source, code, linenums]
----
assertEquals(expect, responseEvent.getMessage().getPayload());
----

===  runFlowWithPayloadAndExpect

此方法与*above*中讨论的`runFlowAndExpect`方法非常相似，但向测试添加了第三个参数：

[%header%autowidth.spread]
|===
| {名称{1}}说明
| `flowName`  | Mule流程运行
| `expect`  |测试的预期输出
| `payload`  |输入事件的有效负载
|===

接下来是对该方法的逐行检查。

第一行使用方法`lookupFlowConstruct`（反过来使用Mule的 http://www.mulesoft.org/docs/site/3.0.0/apidocs/org/mule/api/registry/Registry.html[注册处]）来查找您在项目XML配置中作为方法参数设置的流程：

[source, code, linenums]
----
Flow flow = lookupFlowConstruct(flowName);
----

然后，接下来的两行使用指定的有效载荷生成测试事件并启动流程：

[source, code, linenums]
----
MuleEvent event = getTestEvent(payload);
MuleEvent responseEvent = flow.process(event);
----

最后一行将测试的输出与您设置为方法参数的预期输出进行比较。

[source, code, linenums]
----
assertEquals(expect, responseEvent.getMessage().getPayload());
----

如果断言失败，`assertEquals()`将抛出异常。

===  getConfigResources（）

该方法简单地标识要从中检索测试的XML文件。它在`src/test/resources.`中查找文件

===  lookupFlowConstruct

此方法检索指定的流程。它只需要一个参数：`name`，它引用一个流程名称。它由`runFlowAndExpect`和`runFlowWithPayloadAndExpect`调用。

== 添加测试

要构建测试，请将方法添加到生成的测试类中，并使用`@Test`对其进行注释。 `@Test`注释指示当实例化类时，Mule将自动运行此方法。

在默认框架中，文件中已经有一个`@Test`方法。它使用助手方法r `unFlowAndExpect`从`src/test/resources/mule-config.xml`调用`testFlow`并检查结果：

[source, java, linenums]
----
@Test public void testFlow() throws Exception
    {
        runFlowAndExpect("testFlow", "Another string");
    }
----

随意修改此测试或根据需要添加更多测试方法，并在适当的地方使用助手方法。

要通过测试，它应该运行到完成而不会抛出异常。要通过测试，请在`@Test`方法的主体中引发异常。

== 下一步

如果在向连接器添加操作的同时开发单个单元测试，则应该返回到开发过程。使用Maven构建您的连接器项目;如果您的任何测试失败，那么您的Maven构建过程将失败。

如果您有完整的测试套件，则可以转至您的连接器的 link:/anypoint-connector-devkit/v/3.4/creating-devkit-connector-documentation[完成文件和样品]。
