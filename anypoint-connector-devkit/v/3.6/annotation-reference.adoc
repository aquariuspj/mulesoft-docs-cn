= 注释参考
:keywords: devkit, annotation, reference

本文档列出了以符号（@）开头的MuleSoft元素。有关注释的更多信息，请参阅 http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/annotation/Annotation.html[java.lang.annotation.Annotation]。对于不在DevKit中的Mule注释，请参阅 link:/mule-user-guide/v/3.6/creating-flow-objects-and-transformers-using-annotations[使用注释创建流对象和变形金刚]。

*{{0}}*

== 类别摘要

[%header,cols="2*a"]
|===

|类别
|注解

| *Newest Annotations*  | link:#AnnotationReference-configan[@组态] link:#AnnotationReference-connmgmtan[@ConnectionManagement] link:#AnnotationReference-connstratan[@ConnectionStrategy] link:#AnnotationReference-handlean[@处理] link:#AnnotationReference-handleran[@Handler] link:#AnnotationReference-httpbasicauthan[@HTTPBasicAuth] link:#AnnotationReference-literalan[@文字] link:#AnnotationReference-onexceptionan[@OnException] link:#AnnotationReference-reqentitlean[@RequiresEntitlement] link:#AnnotationReference-reqentlican[@RequiresEnterpriseLicense] link:#AnnotationReference-testconnan[@TestConnectivity]

| *General*
| link:#AnnotationReference-catan[@类别] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-expran[@Expr] link:#AnnotationReference-expenan[@ExpressionEnricher]
  link:#AnnotationReference-exevan[@ExpressionEvaluator] link:#AnnotationReference-exlan[@ExpressionLanguage] link:#AnnotationReference-filan[@过滤] link:#AnnotationReference-iconan[@Icons]
  link:#AnnotationReference-ignan[@忽视] link:#AnnotationReference-mimean[@哑剧] link:#AnnotationReference-modulean[@Module] link:#AnnotationReference-pagean[@Paged] link:#AnnotationReference-procan[@处理器]
  link:#AnnotationReference-srcan[@资源] link:#AnnotationReference-tranan[@变压器] link:#AnnotationReference-trsan[@TransformerResolver]

| *Argument Passing*  | link:#AnnotationReference-inhean[@InboundHeaders] link:#AnnotationReference-ivhean[@InvocationHeaders] link:#AnnotationReference-literalan[@文字] link:#AnnotationReference-outhan[@OutboundHeaders]
  link:#AnnotationReference-payan[@Payload] link:#AnnotationReference-sessa[@SessionHeaders]

| *Connection Management*  | link:#AnnotationReference-cnctan[@Connect] link:#AnnotationReference-coidan[@ConnectionIdentifier] link:#AnnotationReference-connmgmtan[@ConnectionManagement] link:#AnnotationReference-connstratan[@ConnectionStrategy] link:#AnnotationReference-discan[@断开] link:#AnnotationReference-invan[@InvalidateConnectionOn] link:#AnnotationReference-recan[@ReconnectOn] link:#AnnotationReference-valcan[@ValidateConnection]

| *DataSense*  | link:#AnnotationReference-metan[@MetaDataCategory] link:#AnnotationReference-mtkpan[@MetaDataKeyParam] link:#AnnotationReference-mtkran[@MetaDataKeyRetriever]
  link:#AnnotationReference-mtoran[@MetaDataOutputRetriever] link:#AnnotationReference-mtran[@MetaDataRetriever] link:#AnnotationReference-mtsan[@MetaDataScope]
  link:#AnnotationReference-noman[@NoMetaData] link:#AnnotationReference-quan[@Query] link:#AnnotationReference-qupan[@QueryPart] link:#AnnotationReference-qutan[@QueryTranslator]

| *Display*
| link:#AnnotationReference-fnan[@友好名称] link:#AnnotationReference-passan[@密码] link:#AnnotationReference-pathan[@路径] link:#AnnotationReference-plcan[@放置] link:#AnnotationReference-suman[@概要] link:#AnnotationReference-textan[@文本]

| *Exception Management*
| link:#AnnotationReference-onexceptionan[@OnException] link:#AnnotationReference-handleran[@Handler] link:#AnnotationReference-handlean[@处理]

| *Lifecycle*
| link:#AnnotationReference-displ[@Dispose] link:#AnnotationReference-initan[@Initialise] link:#AnnotationReference-stan[@开始] link:#AnnotationReference-stopan[@停止]

| *Authentication*  | link:#AnnotationReference-httpbasicauthan[@HTTPBasicAuth]

| *OAuth*
| link:#AnnotationReference-oa1an[@OAuth] link:#AnnotationReference-oa2an[@的OAuth2] link:#AnnotationReference-oatan[@OAuthAccessToken] link:#AnnotationReference-oatian[@OAuthAccessTokenIdentifier]
  link:#AnnotationReference-oatsan[@OAuthAccessTokenSecret] link:#AnnotationReference-oaupan[@OAuthAuthorizationParameter]
  link:#AnnotationReference-oacban[@OAuthCallbackParameter] link:#AnnotationReference-oackan[@OAuthConsumerKey] link:#AnnotationReference-oacsan[@OAuthConsumerSecret]
  link:#AnnotationReference-oaitan[@OAuthInvalidateAccessTokenOn] link:#AnnotationReference-oapan[@OAuthPostAuthorization]
  link:#AnnotationReference-oapran[@OAuthProtected] link:#AnnotationReference-oasan[@OAuthScope]

| *Parameters*  | link:#AnnotationReference-conkan[@ConnectionKey] link:#AnnotationReference-defan[@默认] link:#AnnotationReference-eman[@电子邮件] link:#AnnotationReference-e[@ExceptionPayload]
  link:#AnnotationReference-mtskan[@MetaDataStaticKey] link:#AnnotationReference-optan[@可选的] link:#AnnotationReference-refan[@RefOnly]

| *REST*
| link:#AnnotationReference-binpan[@BinaryParam] link:#AnnotationReference-rstcan[@RestCall] link:#AnnotationReference-rstean[@RestExceptionOn] link:#AnnotationReference-rstpan[@RestHeaderParam]
  link:#AnnotationReference-rshcan[@RestHttpClient] link:#AnnotationReference-rsppan[@RestPostParam] link:#AnnotationReference-rsqpan[@RestQueryParam] link:#AnnotationReference-rstoan[@RestTimeout]
  link:#AnnotationReference-rsupan[@RestUriParam]
|===

==  @ BinaryParam

类别：REST +
Mule版本：3.5及更高版本

指定有效负载是否是二进制类型。

另请参阅： link:#AnnotationReference-rstcan[@RestCall] link:#AnnotationReference-rstean[@RestExceptionOn] link:#AnnotationReference-rstpan[@RestHeaderParam] link:#AnnotationReference-rshcan[@RestHttpClient]
  link:#AnnotationReference-rsppan[@RestPostParam] link:#AnnotationReference-rsqpan[@RestQueryParam] link:#AnnotationReference-rstoan[@RestTimeout] link:#AnnotationReference-rsupan[@RestUriParam]

==  @类别

类别：通用+
Mule版本：3.5及更高版本

Anypoint Studio和doclet使用`@Category`注释来组织消息处理器。您可以在课程定义级别（`@Connector`或`@Module`）使用`@Category`注释来选择您希望将您的分机列入的类别：

[source, java, linenums]
----
Connector(name = "ldap", schemaVersion = "3.6",
  friendlyName="LDAP", minMuleVersion="3.6",
  description="The LDAP connector connects to a
    LDAP server and performs LDAP operations")
@Category(name = "org.mule.tooling.category.core",
  description = "Components")
  public class LDAPConnector
    {
      ...
    }
----

*Notes*：

* 您只能将连接器添加到其中一个现有的Studio类别（这意味着您无法定义自己的类别）。
*  `@Category`的名称和说明属性的值只能包含以下值：
+
[%header,cols="2*a"]
|===

|名称
|说明

|云端连接器（DEFAULT）
| `org.mule.tooling.category.cloudconnector`
|组件
| `org.mule.tooling.category.core`
|端点
| `org.mule.tooling.category.endpoints`
|错误处理
| `org.mule.tooling.ui.modules.core.exceptions`
|流量控制
| `org.mule.tooling.category.flowControl`
|过滤器
| `org.mule.tooling.category.filters`
|其他
| `org.mule.tooling.ui.modules.core.miscellaneous`
|作用域
| `org.mule.tooling.category.scopes`
|安全
| `org.mule.tooling.category.security`
|变压器
| `org.mule.tooling.category.transformers`
|===

您可以使用以下来指定允许的类别：

[source,java, linenums]
----
import org.mule.api.annotations.Category;
@Category(name = "org.mule.tooling.category.endpoints", description = "Endpoints")
@Category(name = "org.mule.tooling.category.scopes", description = "Scopes")
@Category(name = "org.mule.tooling.category.core", description = "Components")
@Category(name = "org.mule.tooling.category.transformers", description = "Transformers")
@Category(name = "org.mule.tooling.category.filters", description = "Filters")
@Category(name = "org.mule.tooling.category.flowControl", description = "Flow Control")
@Category(name = "org.mule.tooling.ui.modules.core.exceptions", description = "Error Handling")
@Category(name = "org.mule.tooling.category.cloudconnector", description = "Cloud Connectors")
@Category(name = "org.mule.tooling.ui.modules.core.miscellaneous", description = "Miscellaneous")
@Category(name = "org.mule.tooling.category.security", description = "Security")
----

请参阅： link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-expran[@Expr] link:#AnnotationReference-expenan[@ExpressionEnricher] link:#AnnotationReference-exevan[@ExpressionEvaluator]
  link:#AnnotationReference-exlan[@ExpressionLanguage] link:#AnnotationReference-filan[@过滤] link:#AnnotationReference-iconan[@Icons] link:#AnnotationReference-ignan[@忽视] link:#AnnotationReference-mimean[@哑剧] link:#AnnotationReference-modulean[@Module] link:#AnnotationReference-pagean[@Paged] link:#AnnotationReference-procan[@处理器]
  link:#AnnotationReference-srcan[@资源] link:#AnnotationReference-tranan[@变压器] link:#AnnotationReference-trsan[@TransformerResolver]


==  @配置

类别：通用+
Mule版本：3.5及更高版本

将`@Connector`内的字段标记为可配置。 `@Configurable`注释指示生成器通过XML语法或连接器配置对话框创建可为连接器的每个实例配置的属性。除`@Configurable`注释之外，您至少需要一个公共get和set函数。

[source,java, linenums]
----
@Configurable
 private String url;

 public String getUrl() {
      return url;
 }

 public void setUrl(String url) {
      this.url = url;
 }
----

请参阅： link:#AnnotationReference-catan[@类别] link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-expran[@Expr] link:#AnnotationReference-expenan[@ExpressionEnricher] link:#AnnotationReference-exevan[@ExpressionEvaluator] +
  link:#AnnotationReference-exlan[@ExpressionLanguage] link:#AnnotationReference-filan[@过滤] link:#AnnotationReference-iconan[@Icons] link:#AnnotationReference-ignan[@忽视] link:#AnnotationReference-mimean[@哑剧] link:#AnnotationReference-modulean[@Module] link:#AnnotationReference-pagean[@Paged] link:#AnnotationReference-procan[@处理器] +
  link:#AnnotationReference-srcan[@资源] link:#AnnotationReference-tranan[@变压器] link:#AnnotationReference-trsan[@TransformerResolver]

==  @配置

类别：连接管理+
Mule版本：3.6及更高版本

表示没有连接管理策略的类;也就是说，没有合并配置文件或重新连接的能力。为没有任何连接管理的全局元素提供通用策略。

使用此批注时，连接器或模块可以在不需要身份验证和/或连接管理时使用 link:#AnnotationReference-confan[@Configurable]在全局元素级别配置不同的参数。

[source,java, linenums]
----
@Configuration
public class GenericStrategy{

    @Configurable
    private String myConfigurable
    ...
}
----

笔记：

*  @Configuration策略没有用于共享配置文件或重新连接的任何连接管理选项卡，并且默认情况下不创建连接组。
* 默认情况下，所有配置都会进入`General`组。
* 定义您自己的组和/或使用连接性测试。

请参阅： link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-cnctan[@Connect] link:#AnnotationReference-coidan[@ConnectionIdentifier] link:#AnnotationReference-connmgmtan[@ConnectionManagement] link:#AnnotationReference-connstratan[@ConnectionStrategy] link:#AnnotationReference-discan[@断开] link:#AnnotationReference-invan[@InvalidateConnectionOn] link:#AnnotationReference-recan[@ReconnectOn] link:#AnnotationReference-valcan[@ValidateConnection]

==  @连接

类别：连接管理+
Mule版本：3.5及更高版本

将@Connector作用域内的方法标记为负责创建连接。

此方法可以有多个参数，并且可以包含注释，例如@ConnectionKey或@Password。 @Connect注释保证在调用任何消息处理器之前调用该方法。

此方法指定`@Connector`类中的哪个方法负责创建到目标的连接。当连接器启动时，或者与API的连接已经丢失并且必须重新建立，Mule会自动调用`@Connect`方法。当此方法结束时，如果认证成功，则连接器实例已准备好向API发出请求。

用`@Connect`注释的方法必须：

* 为`public`
* 抛出`org.mule.api.ConnectionException`（并且没有其他例外）
* 有一个`void`返回类型
* 如果使用用户名和密码身份验证的自动连接管理，则只需注释一个方法`@Connect`;否则编译失败
* 参数不能是基本类型，例如int，bool，short等。

例1：
[source,java, linenums]
----
@Connect
public void connect(@ConnectionKey String username, String password) throws   ConnectionException { ... }
----

例2：

[source,java, linenums]
----
@Connect
public void connect(@ConnectionKey String username, String password)
throws ConnectionException
{
   ConnectorConfig config = new ConnectorConfig();
   config.setUsername(username);
   config.setPassword(password);
   try
   {
      connection = com.mycompany.ws.Connector.newConnection(config);
   }
   catch (com.mycompany.ws.ConnectionException e)
   {
      throw new org.mule.api.ConnectionException(ConnectionExceptionCode.UNKNOWN, null, e.getMessage(), e);
   }
}
----

此方法所需的参数是认证所需的凭证，在这种情况下是用户名和密码。由于此方法使用`@Connect`进行了注释，Anypoint DevKit使这些参数在该连接器的配置元素中都可用（与`@Configurable`字段一样），以及在消息处理器被拖入时流量。指定的凭据会覆盖配置元素中设置的凭据。

请参阅： link:/anypoint-connector-devkit/v/3.6/connection-management[连接管理] link:#AnnotationReference-cnctan[@Connect] link:#AnnotationReference-coidan[@ConnectionIdentifier] link:#AnnotationReference-discan[@断开] link:#AnnotationReference-invan[@InvalidateConnectionOn] +
  link:#AnnotationReference-recan[@ReconnectOn] link:#AnnotationReference-valcan[@ValidateConnection]

==  @ ConnectionIdentifier

类别：连接管理+
Mule版本：3.5及更高版本

标记 link:#AnnotationReference-connan[@Connector]中的方法负责识别连接。

用`@ConnectionIdentifier`注释的方法必须：

* 为`public`
* 不是`static`
* 不接受参数
*  {返回{1}}

使用连接管理进行基本身份验证的`@Connector`类必须只有一个注释为`@ConnectionIdentifier`的方法;否则编译失败。

出于调试目的，连接器的连接管理器调用用@ConnectionIdentifier注解的方法。

此注释必须用于不带参数的非静态方法，并且必须返回包含连接标识符表示的字符串。

以下示例代码返回连接SessionId作为标识符（如果可用）。在这种情况下，SessionHeader对象包含有关当前连接到API的头信息，包括会话ID。

[source,java, linenums]
----
@ConnectionIdentifier
   public String connectionId() {
    if (connection != null){
     return connection.getSessionHeader().getSessionId();
    } else {
     return null;
    }
   }
----

请参阅： link:/anypoint-connector-devkit/v/3.6/connection-management[连接管理] link:#AnnotationReference-cnctan[@Connect] link:#AnnotationReference-discan[@断开] link:#AnnotationReference-invan[@InvalidateConnectionOn] +
  link:#AnnotationReference-recan[@ReconnectOn] link:#AnnotationReference-valcan[@ValidateConnection]

==  @ ConnectionKey

类别：参数+
Mule版本：3.5及更高版本

将连接方法内的参数标记为连接器查找的关键字的一部分。这只能用作 link:#AnnotationReference-cnctan[@Connect]方法的一部分。

[source,java, linenums]
----
@Connect(strategy=ConnectStrategy.SINGLE_INSTANCE)
public void connect(@ConnectionKey String username, @Password String password)
throws ConnectionException { ... }
----

请参阅： link:#AnnotationReference-defan[@默认] link:#AnnotationReference-eman[@电子邮件] link:#AnnotationReference-excpan[@ExceptionPayload] link:#AnnotationReference-mtskan[@MetaDataStaticKey] link:#AnnotationReference-optan[@可选的] link:#AnnotationReference-refan[@RefOnly]

==  @ ConnectionManagement

类别：连接管理+
Mule版本：3.6及更高版本

表示为基本用户名和密码身份验证定义连接策略的类。

例子

[source,java, linenums]
----
@ConnectionManagement(friendlyName = "Connection Management type Strategy",
     configElementName="config-type")
public class ConnectionManagementStrategy implements StrategyCommonInterface {

    MyDummyService service;

    public ConnectionManagementStrategy(){
        service = new MyDummyService();
    }

    @TestConnectivity
    @Connect
    public void connect(@ConnectionKey String username, @Password String password)
        throws ConnectionException {
        Boolean result = service.connectService(username, password);
        if(result == false){
            throw new ConnectionException(null, "Invalid Username or password",
              "Please review Username or Password values");
        }
    }
----

以下示例适用于具有连接管理和连接测试的连接器。

[source,java, linenums]
----
@ConnectionManagement
public class BasicAuthConnectionStrategy{
  @Connect
  @TestConnectivity //(active=true) default
  //Connection management methods
}
----

以下示例适用于具有连接管理和无连接测试的连接器：

[source,java, linenums]
----
@ConnectionManagement
public class BasicAuthConnectionStrategy{
  @Connect
  @TestConnectivity(active=false)
  //Connection management methods
}
----

表示连接器策略类。有关更多示例，请参阅 link:#AnnotationReference-connstrat[@ConnectionStrategy]。

请参阅： link:#AnnotationReference-configan[@组态] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-cnctan[@Connect] link:#AnnotationReference-coidan[@ConnectionIdentifier] +
  link:#AnnotationReference-connstratan[@ConnectionStrategy] link:#AnnotationReference-discan[@断开] link:#AnnotationReference-invan[@InvalidateConnectionOn] link:#AnnotationReference-recan[@ReconnectOn] +
  link:#AnnotationReference-testconnan[@TestConnectivity] link:#AnnotationReference-valcan[@ValidateConnection]

==  @ ConnectionStrategy

类别：身份验证+
Mule版本：3.6及更高版本

表示连接的连接策略类。该类由新的@ConnectionManagement批注，新的@Configuration批注，新的@HTTPBasicAuth批注或现有的@ OAuth2批注定义。在以前的Mule版本中，只能通过继承来添加连接策略，这使得编码更加困难，并在新的DevKit功能出现时导致扩展性问题。新的连接策略功能可以解决这些问题。

[source,java, linenums]
----
@Connector
public class MyConnector {

    @ConnectionStrategy
    private OAuth2Strategy connection;

    @Processor
    public void doSomething(){
        connection.getClient().doSomething();
    }
}
@OAuth2(friendlyName="oauth2", configElementName="oauth2", ...)
public class OAuth2Strategy implements BaseConnectionStrategy {

    @Override
    public Client getClient(){
        return this.client;
    }

    /**
     * Your application's client identifier (consumer key in Remote Access Detail).
     */
    @OAuthConsumerKey
    private String consumerKey;

    /**
     * Your application's client secret (consumer secret in Remote Access Detail).
     */
    @OAuthConsumerSecret
    private String consumerSecret;

    @OAuthAccessToken
    private String accessToken;

    @OAuthPostAuthorization
    public void postAuthorize() {...}

    ...
}
----

*Example with @ConnectionManagement*

[source,java, linenums]
----
@Connector
public class MyConnector {

    @ConnectionStrategy
    private ConnectionManagementStrategy connection;

    @Processor
    public void doSomething(){
        connection.getClient().doSomething();
    }
}
----

[source,java, linenums]
----
@ConnectionManagement(friendlyName="ConnectionManagement", configElementName="connection-management")
public class ConnectionManagementStrategy implements BaseConnectionStrategy {

    @Override
    public Client getClient(){
        return this.client;
    }

    @Connect
    public void connect(...){
        this.client = new Client(...);
    }

    @Disconnect
    public void disconnect() {...}

    @ValidateConnection
    public boolean isConnected() {...}

    @ConnectorIdentifier
    public String getIdentifier() {...}

}
----

*Multiple Connection Strategies*

上面的每个连接策略扩展了BaseConnectionStrategy接口。

[source,java, linenums]
----
public interface BaseConnectionStrategy{
    private Client client;

    Client getClient();
}
----

@ConnectorStrategy字段类型是通用接口。

[source,java, linenums]
----
@Connector
public class MyConnector {


    @ConnectionStrategy
    private BaseConnectionStrategy connection;

    @Processor
    public void doSomething(){
        connection.getClient().doSomething();
    }
    ...
}
----

现在，您可以在设计时选择要使用的连接器类型。

image:Screen+Shot+2014-12-30+at+1.06.11+PM.png[屏幕+镜头+情节中字+在+ 11年6月1日下午+]

https://github.com/mulesoft-labs/multiple-strategies-example-connector[Here]是github中多策略连接器的一个例子。


*Compatibility*

@Processor调用不能覆盖@Connect参数。

对于这种情况，DevKit中的@ConnectionManagement组件允许您使用@O​​verrideAtProcessors注释@ConnetionStrategy，将@Connect参数添加为@Processor块的可选参数。这样，您可以直接从@Processor调用覆盖属性。

@OverrideAtProcessor批注在Mule 3.6及更高版本中已被弃用，并且仅为了向后兼容而存在。

*Execution Time: Connector Pooling*

最简单的方法是维护当前的DevKit连接器的体系结构，并为每个配置继续使用连接器池。使用下面的例子：

[source,xml, linenums]
----
<my-connector:connection-management name="connection-management" username="mule" password="mulemanishere"/>
<my-connector:oauth name="oauth2" consumerkey="..." consumerSecret="..." />

<flow>
  <my-connector:do-something config-ref="basic"/>
</flow>
----

两个元素`:basic-auth`和`:oauth`的后面是MyConnector类的两个不同的池，分别用于分别注入BasicStrategy和OAuthStrategy实例。这可以通过在MyConnector <Strategy>上使用泛型来完成。下面介绍了此替代方案的执行流程图。

.  Spring bean注入从：basic-auth元素到MyConnectorPool <BasicStrategy> bean对象。
.  Spring Bean注入：do-something到DoSomethingMessageProcessor（引用MyConnectorPool）。
. 稍后进行DoSomethingMessageProcessor.doProcess（）调用。 MyConnector实例取自包含已连接的ConnectionManagement连接的MyConnectorPool <ConnectionManagement>。如果没有，则创建一个新的。

请参阅： link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-cnctan[@Connect] link:#AnnotationReference-coidan[@ConnectionIdentifier] link:#AnnotationReference-connmgmtan[@ConnectionManagement] link:#AnnotationReference-discan[@断开] link:#AnnotationReference-invan[@InvalidateConnectionOn] link:#AnnotationReference-recan[@ReconnectOn] link:#AnnotationReference-valcan[@ValidateConnection]

==  @连接器

类别：通用+
Mule版本：3.5及更高版本

定义一个将其功能作为Mule连接器导出的类。当您首次在Studio中创建Anypoint Connector Project时，Maven会为您生成一个支架@Connector类。创建一个连接器假定你增强了这个类来使你的代码访问一个目标资源。

此类级别注释将Java类标识为云连接器。

@连接器限制：

* 不适用于接口
* 不适用于最终课程
* 仅适用于公共课程
* 不能有类型化的参数（没有泛型）
* 具有`@Connector`的类必须只包含一个用`@Connect`注释的方法
* 具有`@Connector`的类必须只包含一个用`@Disconnect`注释的方法

[source,java, linenums]
----
@Connector(name = "hello", schemaVersion = "1.0", friendlyName = "Hello", minMuleVersion = "3.6")
public class HelloConnector {
  ...
}
----

*@Connector Parameters:*

[%header,cols="4*a"]
|===
|注释类型元素
|说明
|是否必需？
|默认值

| `name`
|连接器的名称。该值必须是简单的字符串，不能有空格。
|✓
|

| `schemaVersion`
|由DevKit生成的模式版本。
|
| `1.0-SNAPSHOT`

| `friendlyName`
|这是连接器的人类可读名称。它可以包含空格。 Mule只用它来标记Studio调色板中的连接器。
|✓
|

| `description`
|描述连接器及其操作的较长字符串。 Mule Studio将描述显示为工具提示。
|
|

| `namespace`
|连接器的名称空间。
|
| `+http://www.mulesoft.org/schema/mule/name+`

| `schemaLocation`
|写入`spring.schemas`文件的模式文件的位置。
|
| `+http://www.mulesoft.org/schema/mule/name/schemaVersion/mule-name.xsd+`

和：

`+http://www.mulesoft.org/schema/mule/name/current/mule-name.xsd+`

| `minMuleVersion`
|可以使用连接器的最小Mule版本。 Mule在运行时检查版本，并在版本不兼容时引发错误。
|
|最新的稳定Mule运行时版本
|===

请参阅： link:#AnnotationReference-catan[@类别] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-expran[@Expr] link:#AnnotationReference-expenan[@ExpressionEnricher] link:#AnnotationReference-exevan[@ExpressionEvaluator] +
  link:#AnnotationReference-exlan[@ExpressionLanguage] link:#AnnotationReference-filan[@过滤] link:#AnnotationReference-iconan[@Icons] link:#AnnotationReference-ignan[@忽视] link:#AnnotationReference-mimean[@哑剧] link:#AnnotationReference-modulean[@Module] link:#AnnotationReference-pagean[@Paged] link:#AnnotationReference-procan[@处理器] +
   link:#AnnotationReference-srcan[@资源] link:#AnnotationReference-tranan[@变压器] link:#AnnotationReference-trsan[@TransformerResolver]

==  @默认

类别：参数+
Mule版本：3.5及更高版本

指定@Configurable字段或@Processor或@Source参数的默认值。

[source,java, linenums]
----
@Configurable
@Default("mule")
private String type;
----

要么：

[source,java, linenums]
----
@Processor
public abstract String listAnimals(@Default("mule") String type) throws IOException;
----

另请参阅： link:#AnnotationReference-conkan[@ConnectionKey] link:#AnnotationReference-eman[@电子邮件] link:#AnnotationReference-excpan[@ExceptionPayload] link:#AnnotationReference-mtskan[@MetaDataStaticKey]

link:#AnnotationReference-optan[@可选的] link:#AnnotationReference-refan[@RefOnly]

==  @断开

类别：连接管理+
Mule版本：3.5及更高版本

在负责处理连接的@Connector类中标记一个方法。连接器关闭或连接终止时，由连接器的连接管理器调用。

用`@Disconnect`注释的方法必须：

* 为`public`
* 不要输入参数
* 有一个`void`返回类型

如果使用连接管理（用户名和密码）进行认证，则`@Connector`类必须只有一个带注释的`@Disconnect`方法;否则编译失败。

在3.6及更高版本中，@Disconnect方法仅支持RuntimeException，任何其他异常都会导致连接器编译失败：

[source,java, linenums]
----
@Connector(...)
public myConnector(){
    ...
    @Disconnect
    public void disconnect() throws RuntimeException{
        ...
    }
    ...
}
----

此方法作为维护连接池的一部分进行调用。该池配置了最大空闲时间值。

当连接位于池中而不超过配置的时间时，则调用使用@Disconnect注释的方法，然后调用@Connect方法。另外，当在方法上使用@InvalidateConnectionOn注释来捕获异常时，同样会调用@Disconnect方法并进行后续的重新连接。

[source,java, linenums]
----
@Disconnect
public void disconnect() {
   if (connection != null)
   {
      try
         {
         connection.logout();
         }
      catch (ConnectionException e)
         {
         e.printStackTrace();
         }
      finally
         {
         connection = null;
         }
   }
}
----

请参阅： link:/anypoint-connector-devkit/v/3.6/connection-management[连接管理] link:#AnnotationReference-cnctan[@Connect] link:#AnnotationReference-coidan[@ConnectionIdentifier] link:#AnnotationReference-invan[@InvalidateConnectionOn] +
  link:#AnnotationReference-recan[@ReconnectOn] link:#AnnotationReference-valcan[@ValidateConnection]

==  @处置

类别：LifeCycle +
Mule版本：3.5及更高版本

在方法的`org.mule.lifecycle.Disposable`阶段标记要处理的方法。

[source,java, linenums]
----
@Dispose
public void mydispose()  {
    if ( this.sessionId != null ) {
        serviceProvider.dispose(sessionId);
    }
}
----

*Note:* `dispose`是一个保留字，不能用作方法的名称。

另请参阅： link:#AnnotationReference-initan[@Initialise] link:#AnnotationReference-stan[@开始] link:#AnnotationReference-stopan[@停止]

==  @电子邮件

类别：参数+
Mule版本：3.5及更高版本

指定默认的电子邮件模式。

请参阅： link:#AnnotationReference-conkan[@ConnectionKey] link:#AnnotationReference-defan[@默认] link:#AnnotationReference-excpan[@ExceptionPayload] link:#AnnotationReference-mtskan[@MetaDataStaticKey] link:#AnnotationReference-optan[@可选的] link:#AnnotationReference-refan[@RefOnly]

==  @ ExceptionPayload

类别：参数+
Mule版本：3.5及更高版本

指定异常的有效负载。

[source,java, linenums]
----
@Processor
public Object returnExceptionPayload(@ExceptionPayload Object payload) {
    return payload;
}
----

请参阅： link:#AnnotationReference-conkan[@ConnectionKey] link:#AnnotationReference-defan[@默认] link:#AnnotationReference-eman[@电子邮件] link:#AnnotationReference-mtskan[@MetaDataStaticKey] link:#AnnotationReference-optan[@可选的] link:#AnnotationReference-refan[@RefOnly]

==  @ Expr的

类别：通用+
Mule版本：3.5及更高版本

将 link:#AnnotationReference-procan[@处理器]方法中的参数绑定到表达式。

将参数绑定到表达式与 link:#AnnotationReference-payan[@Payload]类似，因为模块的用户将无法更改XML中的表达式或参数值。绑定是硬编码的，用户不能更改它。

以下示例将`myFlowVarXXX`参数映射到表达式`flowVars['xxx']`的结果：

[source,java, linenums]
----
@Processor
public String myProcessor(@Expr("flowVars['xxx']")
   String myFlowVarXXX) {
     ...
   }
----

请参阅： link:#AnnotationReference-catan[@类别] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-expenan[@ExpressionEnricher] link:#AnnotationReference-exevan[@ExpressionEvaluator] +
  link:#AnnotationReference-exlan[@ExpressionLanguage] link:#AnnotationReference-filan[@过滤] link:#AnnotationReference-iconan[@Icons] link:#AnnotationReference-ignan[@忽视] link:#AnnotationReference-mimean[@哑剧] link:#AnnotationReference-modulean[@Module] link:#AnnotationReference-pagean[@Paged] link:#AnnotationReference-procan[@处理器] +
  link:#AnnotationReference-srcan[@资源] link:#AnnotationReference-tranan[@变压器] link:#AnnotationReference-trsan[@TransformerResolver]

==  @ ExpressionEnricher

类别：通用+
Mule版本：3.5及更高版本

将 link:#AnnotationReference-exlan[@ExpressionLanguage]中的方法标记为负责基于表达式丰富mule消息。

以下示例显示如何使用@ExpressionEnricher批注使用`map-payload`表达式语言在`enrich()`方法中设置有效内容（预期为映射）：

[source,java, linenums]
----
@ExpressionLanguage(name = "map-payload")
public class MapPayloadExpressionLanguage {
    @ExpressionEnricher
    public void enrich() {
        ...
    }
}
----

请参阅： link:#AnnotationReference-catan[@类别] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-expran[@Expr] link:#AnnotationReference-exevan[@ExpressionEvaluator] +
  link:#AnnotationReference-exlan[@ExpressionLanguage] link:#AnnotationReference-filan[@过滤] link:#AnnotationReference-iconan[@Icons] link:#AnnotationReference-ignan[@忽视] link:#AnnotationReference-mimean[@哑剧] link:#AnnotationReference-modulean[@Module] link:#AnnotationReference-pagean[@Paged] +
  link:#AnnotationReference-procan[@处理器] link:#AnnotationReference-srcan[@资源] link:#AnnotationReference-tranan[@变压器] link:#AnnotationReference-trsan[@TransformerResolver]

==  @的ExpressionEvaluator

类别：通用+
Mule版本：3.5及更高版本

将 link:#AnnotationReference-exlan[@ExpressionLanguage]注释中的方法标记为负责评估表达式。

[source,java, linenums]
----
@ExpressionLanguage(name = "expr")
public class ExprExpressionLanguage {
    @ExpressionEvaluator
    public Object evaluate() {
        ...
    }
}
----

请参阅： link:#AnnotationReference-catan[@类别] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-expran[@Expr] link:#AnnotationReference-expenan[@ExpressionEnricher] +
  link:#AnnotationReference-exlan[@ExpressionLanguage] link:#AnnotationReference-filan[@过滤] link:#AnnotationReference-iconan[@Icons] link:#AnnotationReference-ignan[@忽视] link:#AnnotationReference-mimean[@哑剧] link:#AnnotationReference-modulean[@Module] link:#AnnotationReference-pagean[@Paged] +
  link:#AnnotationReference-procan[@处理器] link:#AnnotationReference-srcan[@资源] link:#AnnotationReference-tranan[@变压器] link:#AnnotationReference-trsan[@TransformerResolver]

==  @表达式语言

类别：通用+
Mule版本：3.5及更高版本

定义一个将其功能导出为Mule表达式语言的类。

对哪些类型有效的@ExpressionLanguage限制：

* 不能成为界面
* 必须公开
* 不能有类型化的参数（没有泛型）

[source,java, linenums]
----
@ExpressionLanguage(name = "expr")
public class ExprExpressionLanguage {
    @ExpressionEvaluator
    public Object evaluate() {
        ...
    }
}
----

请参阅： link:#AnnotationReference-catan[@类别] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-expran[@Expr] link:#AnnotationReference-expenan[@ExpressionEnricher] +
  link:#AnnotationReference-exevan[@ExpressionEvaluator] link:#AnnotationReference-filan[@过滤] link:#AnnotationReference-iconan[@Icons] link:#AnnotationReference-ignan[@忽视] link:#AnnotationReference-mimean[@哑剧] link:#AnnotationReference-modulean[@Module] link:#AnnotationReference-pagean[@Paged] +
  link:#AnnotationReference-procan[@处理器] link:#AnnotationReference-srcan[@资源] link:#AnnotationReference-tranan[@变压器] link:#AnnotationReference-trsan[@TransformerResolver]

==  @过滤

类别：通用+
Mule版本：3.5及更高版本

将@Connector内部的方法标记为可从过滤消息的Mule流中调用。此方法中的每个参数都被用作Mule XML调用的属性。

通过将此注释添加到@Connector中的方法中，将创建一个过滤器，该过滤器可以从Mule流中用于基于此方法的实现过滤消息。

[source,java, linenums]
----
@Filter
    public boolean shouldFilter() throws Exception {
        ...
   }
----

请参阅： link:#AnnotationReference-catan[@类别] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-expran[@Expr] link:#AnnotationReference-expenan[@ExpressionEnricher] +
  link:#AnnotationReference-exevan[@ExpressionEvaluator] link:#AnnotationReference-exlan[@ExpressionLanguage] link:#AnnotationReference-iconan[@Icons] link:#AnnotationReference-ignan[@忽视] link:#AnnotationReference-mimean[@哑剧] +
  link:#AnnotationReference-modulean[@Module] link:#AnnotationReference-pagean[@Paged] link:#AnnotationReference-procan[@处理器] link:#AnnotationReference-srcan[@资源] link:#AnnotationReference-tranan[@变压器] link:#AnnotationReference-trsan[@TransformerResolver]

==  @的FriendlyName

类别：显示+
Mule版本：3.5及更高版本

为注释元素提供简短的名称。如果未指定值，则从注释元素的名称中推断出该名称。

使用此批注实例变量和方法参数来提供一种方法来覆盖 link:#AnnotationReference-confan[@Configurable]变量或 link:#AnnotationReference-procan[@处理器]， link:#AnnotationReference-srcan[@资源]， link:#AnnotationReference-tranan[@变压器]方法参数的默认推断昵称。提供一个参数，如果用这个注释。

例：

[source,java, linenums]
----
@FriendlyName("Consumer Key")
private String consumerKey;
// Alternate: Declare in a method's arguments:
  public abstract String getByTypeAndName(
  @RestQueryParam("name") @FriendlyName("name") String uname)
      throws IOException;
----

另一个示例说明友好名称如何显示在Anypoint Studio连接器列表中：

[source,java, linenums]
----
@Connector(name="barn", schemaVersion="1.0", friendlyName="Barn", minMuleVersion="3.6")
public class BarnConnector
{
    ...
}
----

示例Barn连接器显示在Anypoint Studio的连接器列表中，如下所示：

image:friendlyName-screenshot.png[的friendlyName-截图]

请参阅： link:#AnnotationReference-passan[@密码] link:#AnnotationReference-pathan[@路径] link:#AnnotationReference-plcan[@放置] link:#AnnotationReference-suman[@概要] link:#AnnotationReference-textan[@文本]

==  @拉手

类别：例外管理+
Mule版本：3.6及更高版本

指示处理和描述异常的方法。每个@Handler类有一个@Handle类。

与 link:#AnnotationReference-handleran[@Handler]一起使用：

[source,java, linenums]
----
@Handler
public class GenericHandler
{
   @Inject                    //optional
   FooConnector fooConnector; //optional

   @Handle
   public void customHandler (Exception e) throws Exception
   {
      // Analyze the stack within "e"...
      throw new MyDescriptiveException(e);
   }

   public void setFooConnector(Foo foo)
   {
      this.fooConnector=foo;
   }
}
----

@Handle方法可以返回两个结果：

*  RECONNECT  - 如果@Processor具有 link:#AnnotationReference-recan[@ReconnectOn]，请重试该操作，并且@Handle引发该类型的异常。
* 失败 - 通过抛出不属于 link:#AnnotationReference-recan[@ReconnectOn]的异常来使操作失败，或者处理器不支持重新连接。

*Note*：如果使用@Handle注解的方法在执行过程中不会引发异常，则会重新引发原始异常。

另请参阅： link:#AnnotationReference-onexceptionan[@OnException] link:#AnnotationReference-handleran[@Handler]

  

==  @处理程序

类别：例外管理+
Mule版本：3.6及更高版本

指示处理异常的类。与 link:#AnnotationReference-onexceptionan[@OnException]和 link:#AnnotationReference-handlean[@处理]一起使用。

[source,java, linenums]
----
@OnException (handler=GenericHandler.class)
@Connector (name = "foo", friendlyName = "Foo")
{
   @Processor
   public void someOp (...)
   {
      ...
   }
   @OnException (handler=CustomHandler.class)
   @Processor
   public void anotherOp ()
   {
      ...
   }
}
----

@Handler类的约束条件是：

* 必须公开
* 必须使用@Handler进行注释
* 必须有一个空的构造函数
* 可能有一个具有相同类型连接器的@Inject参数
* 必须有一个用@Handle注解的方法
** 带有@Handle的带注释的方法必须接收一个Exception作为参数
** 带注释的方法必须返回void
** 带注释的方法必须用`throws Exception`声明

另请参阅： link:#AnnotationReference-onexceptionan[@OnException] link:#AnnotationReference-handlean[@处理]

==  @ HTTPBasicAuth

类别：身份验证+
Mule版本：3.6及更高版本

表示 http://tools.ietf.org/html/rfc2617[RFC-2617] "HTTP Authentication: Basic and Digest Access Authentication"的实现。

[source,java, linenums]
----
@HTTPBasicAuth(headerName = "Authorization", prefix="Basic ", friendlyName="Http Basic Auth")
public class HTTPBasicAuthStrategy implements BaseConnectionStrategy {
   ...

 @Configurable
 @BasicAuthUsername
 private String username;

 @Configurable
 @BasicAuthPassword
 private String password;
}
----

用法：

* 用户名和密码合并为一个字符串"username:password"。
* 然后使用Base64的RFC-2045 MIME变体对结果字符串进行编码。
* 头部参数名称的默认值："Authorization"，以及前缀参数的默认值："Basic "
* 头部参数和前缀参数的值可以由用户修改。
* 支持空密码，例如：Stripe。
*  @ BasicAuthUsername仅在@HTTPBasicAuth下有效。
*  @ BasicAuthPassword仅在@BasicAuthUsername存在时有效，反之亦然。
* 这仅适用于@RestCall连接器。

示例API：+
Stripe：https://stripe.com/docs/api/curl#authentication +
Twilio：http://www.twilio.com/docs/security +
JIRA：https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Basic+Authentication

JIRAs API需要一个内容为"Basic "的授权标头，后面跟着编码字符串。例如，字符串"fred:fred"在base64中编码为"ZnJlZDpmcmVk"，因此按如下方式进行请求。

[source, code, linenums]
----
curl -D- -X GET -H "Authorization: Basic ZnJlZDpmcmVk" -H "Content-
Type: application/json" "http://<url>"
----

另请参阅： link:#AnnotationReference-rstcan[@RestCall] link:#AnnotationReference-oa2an[@的OAuth2] link:#AnnotationReference-oatan[@OAuthAccessToken] link:#AnnotationReference-oatian[@OAuthAccessTokenIdentifier]

link:#AnnotationReference-oatsan[@OAuthAccessTokenSecret] link:#AnnotationReference-oaupan[@OAuthAuthorizationParameter] +
  link:#AnnotationReference-oacban[@OAuthCallbackParameter] link:#AnnotationReference-oackan[@OAuthConsumerKey] link:#AnnotationReference-oacsan[@OAuthConsumerSecret] +
  link:#AnnotationReference-oaitan[@OAuthInvalidateAccessTokenOn] link:#AnnotationReference-oapan[@OAuthPostAuthorization] +
  link:#AnnotationReference-oapran[@OAuthProtected] link:#AnnotationReference-oasan[@OAuthScope] link:#AnnotationReference-httpbasicauthan[@HTTPBasicAuth]

==  @图标

类别：通用+
Mule版本：3.5及更高版本

自定义调色板和流编辑器图标。

在连接器类上使用此注释来覆盖一个或多个所需图标的默认位置。路径需要相对于`/src/main/java`目录。

[source,java, linenums]
----
@Icons(connectorLarge="barn-icon-large.png", connectorSmall="barn-icon-small.png")
@Connector(name="barn", schemaVersion="1.0", friendlyName="Barn", minMuleVersion="3.6")
public class BarnConnector
{
   ...
}
----

请参阅： link:#AnnotationReference-catan[@类别] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-expran[@Expr] link:#AnnotationReference-expenan[@ExpressionEnricher] +
  link:#AnnotationReference-exevan[@ExpressionEvaluator] link:#AnnotationReference-exlan[@ExpressionLanguage] link:#AnnotationReference-filan[@过滤] link:#AnnotationReference-ignan[@忽视] link:#AnnotationReference-mimean[@哑剧] link:#AnnotationReference-modulean[@Module] +
  link:#AnnotationReference-pagean[@Paged] link:#AnnotationReference-procan[@处理器] link:#AnnotationReference-srcan[@资源] link:#AnnotationReference-tranan[@变压器] link:#AnnotationReference-trsan[@TransformerResolver]

==  @忽略

类别：通用+
Mule版本：3.5及更高版本

忽略复杂对象内的字段。

[source,java, linenums]
----
public class MyComplexType
{
    private String color;

    @Ignore
    private String description;
}

@Processor
public void receiveAComplexType(MyComplexType myComplexType) {
    ...
}
----

请参阅： link:#AnnotationReference-catan[@类别] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-expran[@Expr] link:#AnnotationReference-expenan[@ExpressionEnricher] +
  link:#AnnotationReference-exevan[@ExpressionEvaluator] link:#AnnotationReference-exlan[@ExpressionLanguage] link:#AnnotationReference-filan[@过滤] link:#AnnotationReference-iconan[@Icons] link:#AnnotationReference-mimean[@哑剧] link:#AnnotationReference-modulean[@Module] +
  link:#AnnotationReference-pagean[@Paged] link:#AnnotationReference-procan[@处理器] link:#AnnotationReference-srcan[@资源] link:#AnnotationReference-tranan[@变压器] link:#AnnotationReference-trsan[@TransformerResolver]

==  @ InboundHeaders

类别：参数传递+
Mule版本：3.5及更高版本

传入入站标题。

[source,java, linenums]
----
@Processor
public String getInboundHeaders(@InboundHeaders("myHeader") String myHeader) { ... }
----

另请参阅： link:#AnnotationReference-ivhean[@InvocationHeaders] link:#AnnotationReference-outhan[@OutboundHeaders] link:#AnnotationReference-payan[@Payload] link:#AnnotationReference-sessa[@SessionHeaders]

==  @初始化

类别：LifeCycle +
Mule版本：3.5及更高版本

在方法的`org.mule.lifecycle.Initialisable`阶段标记要初始化的方法。

[source,java, linenums]
----
@Initialise
public void initialize() {
    if ( this.sessionId != null ) {
        serviceProvider.initialise(sessionId);
    }
}
----

*Note:* `initialise`是一个保留字，不能用作方法的名称。

另请参阅： link:#AnnotationReference-displ[@Dispose] link:#AnnotationReference-stan[@开始] link:#AnnotationReference-stopan[@停止]

==  @ InvalidateConnectionOn

类别：连接管理+
Mule版本：3.5及更高版本

用于捕获异常的方法 - 不推荐使用 link:#AnnotationReference-recan[@ReconnectOn]。

[source,java, linenums]
----
@Processor
@InvalidateConnectionOn(exception=AnimalException.class)
public Animal getAnimal (String id ) {
    ...
}
----

请参阅： link:/anypoint-connector-devkit/v/3.6/connection-management[连接管理] link:#AnnotationReference-cnctan[@Connect] link:#AnnotationReference-coidan[@ConnectionIdentifier] link:#AnnotationReference-discan[@断开] +
  link:#AnnotationReference-recan[@ReconnectOn] link:#AnnotationReference-valcan[@ValidateConnection]

==  @ InvocationHeaders

类别：参数传递+
Mule版本：3.5及更高版本

传递调用标头。这可以是一个单独的标题，一个逗号分隔的标题名称列表，一个星号'*'表示所有标题，或一个逗号分隔的通配表达式列表。默认情况下，如果一个指定的头文件不存在，则抛出异常。但是，如果标头名称是用'？'定义的后期修复，它被标记为可选。

[source,java, linenums]
----
@Processor
public String getInvocationHeaders(@InvocationHeaders("myHeader")
String myHeader) {
    ...
}
----

另请参阅： link:#AnnotationReference-inhean[@InboundHeaders] link:#AnnotationReference-outhan[@OutboundHeaders] link:#AnnotationReference-payan[@Payload] link:#AnnotationReference-sessa[@SessionHeaders]

==  @字面

类别：参数+
Mule版本：3.6及更高版本

将 link:/mule-user-guide/v/3.6/mule-expression-language-mel[骡子表达语言（MEL）]指定为方法参数，而不需要DevKit解析表达式。您可以对此注释使用任何MEL代码。

*Problem*

鉴于以下处理器方法：

[source,java, linenums]
----
public void enrich(Object source, String targetExpression)
----

鉴于以下Mule XML：

[source,xml, linenums]
----
<mymodule:enrich targetExpression="#[variable:myexpr]" ... />
----

丰富方法接收评估以下表达式的结果：

[source,java, linenums]
----
# [variable:myexpr]
  And not this String:

[ variable:myexpr]
----

这是因为DevKit的生成代码会尝试自动解析表达式。

*Solution*

@Literal注解标记一个方法参数，以便它来自Mule XML的值如果是Mule表达式则不会被解析：

[source,java, linenums]
----
public void enrich(Object source, @Literal String targetExpression)
----

在这种情况下，表达式评估不适用于targetExpression参数的值。

而且，这个注解可以用于字符串列表，其中每个元素都是在不评估表达式的情况下传递的。例如：

[source,java, linenums]
----
public void enrich(Object source, @Literal List<String> targetExpressions)
----

请参阅： link:#AnnotationReference-inhean[@InboundHeaders] link:#AnnotationReference-ivhean[@InvocationHeaders] link:#AnnotationReference-outhan[@OutboundHeaders] link:#AnnotationReference-payan[@Payload] link:#AnnotationReference-sessa[@SessionHeaders]

==  @ MetaDataCategory

类别：DataSense +
  Mule版本：3.5及更高版本

描述一个分组DataSense具体类，它返回任何这些类型的类型和描述。

Mule 3.6和更高版本支持@Module和@Connector注释中的@MetaDataCategory。

用于注释一个类，该类将使用DataSense提供有关连接器的元数据的方法分组。

[source,java, linenums]
----
@MetaDataCategory
public class MyCategory {
    ...
}
----

请参阅： link:#AnnotationReference-mtkpan[@MetaDataKeyParam] link:#AnnotationReference-mtkran[@MetaDataKeyRetriever] +
  link:#AnnotationReference-mtoran[@MetaDataOutputRetriever] link:#AnnotationReference-mtran[@MetaDataRetriever] link:#AnnotationReference-mtsan[@MetaDataScope] +
  link:#AnnotationReference-noman[@NoMetaData] link:#AnnotationReference-quan[@Query] link:#AnnotationReference-qupan[@QueryPart] link:#AnnotationReference-qutan[@QueryTranslator]

==  @ MetaDataKeyParam

类别：DataSense +
  Mule版本：3.5及更高版本

将@Processor内部的参数标记为元数据查找的关键字。

[source,java, linenums]
----
public Object create(@MetaDataKeyParam String entityType, @Default("#[payload]") Object entityData) {
    ...
}
----

请参阅： link:#AnnotationReference-metan[@MetaDataCategory] link:#AnnotationReference-mtkran[@MetaDataKeyRetriever] +
  link:#AnnotationReference-mtoran[@MetaDataOutputRetriever] link:#AnnotationReference-mtran[@MetaDataRetriever] link:#AnnotationReference-mtsan[@MetaDataScope] +
  link:#AnnotationReference-noman[@NoMetaData] link:#AnnotationReference-quan[@Query] link:#AnnotationReference-qupan[@QueryPart] link:#AnnotationReference-qutan[@QueryTranslator]

==  @ MetaDataKeyRetriever

类别：DataSense +
  Mule版本：3.5及更高版本

用于注释负责返回服务的实体名称的方法。

鉴于此注释的功能，此Java方法的返回类型必须是`List<MetaDataKey>`。

从此方法返回的实体来自使用@MetaDataRetriever获得的详细描述之后的查询。

在@Connector上下文中或在 link:#AnnotationReference-metan[@MetaDataCategory]中使用此批注。

[source,java, linenums]
----
@MetaDataKeyRetriever
   public List<MetaDataKey> getMetaDataKeys() throws Exception {
       ...
   }
----

请参阅： link:#AnnotationReference-metan[@MetaDataCategory] link:#AnnotationReference-mtkpan[@MetaDataKeyParam] +
  link:#AnnotationReference-mtoran[@MetaDataOutputRetriever] link:#AnnotationReference-mtran[@MetaDataRetriever] link:#AnnotationReference-mtsan[@MetaDataScope] +
  link:#AnnotationReference-noman[@NoMetaData] link:#AnnotationReference-quan[@Query] link:#AnnotationReference-qupan[@QueryPart] link:#AnnotationReference-qutan[@QueryTranslator]

==  @ MetaDataOutputRetriever

类别：DataSense +
  Mule版本：3.5及更高版本

对于给定的@MetaDataKey，将方法标记为输出场景@MetaData的描述器。

[source,java, linenums]
----
@MetaDataOutputRetriever
public MetaData getMetaDataOutputRestImplCategory(MetaDataKey key) throws Exception {
    checkProperConnectorInjection();
    return new DefaultMetaData(resolveOutputMetaDataModel(key));
    ...
}
----

请参阅： link:#AnnotationReference-metan[@MetaDataCategory] link:#AnnotationReference-mtkpan[@MetaDataKeyParam] link:#AnnotationReference-mtkran[@MetaDataKeyRetriever] +
  link:#AnnotationReference-mtran[@MetaDataRetriever] link:#AnnotationReference-mtsan[@MetaDataScope] link:#AnnotationReference-noman[@NoMetaData] link:#AnnotationReference-quan[@Query] link:#AnnotationReference-qupan[@QueryPart] link:#AnnotationReference-qutan[@QueryTranslator]

==  @ MetaDataRetriever

类别：DataSense +
  Mule版本：3.5及更高版本

用@MetaDataRetriever注解的方法描述接收到的元数据关键参数的元数据。

使用由@MetadataKeyRetriever检索的元数据键列表来检索每个实体类型的实体组成。

[source,java, linenums]
----
@MetaDataRetriever
public MetaData getMetadata(MetaDataKey key) {
    ...
}
----

请参阅： link:#AnnotationReference-metan[@MetaDataCategory] link:#AnnotationReference-mtkpan[@MetaDataKeyParam] link:#AnnotationReference-mtkran[@MetaDataKeyRetriever] +
  link:#AnnotationReference-mtoran[@MetaDataOutputRetriever] link:#AnnotationReference-mtsan[@MetaDataScope] link:#AnnotationReference-noman[@NoMetaData] link:#AnnotationReference-quan[@Query] link:#AnnotationReference-qupan[@QueryPart] link:#AnnotationReference-qutan[@QueryTranslator]

==  @ MetaDataScope

类别：DataSense +
  Mule版本：3.5及更高版本

[source,java, linenums]
----
@MetaDataScope(DefaultCategory.class)
@Connector(name = "my-connector", minMuleVersion = "3.6")
public class MyConnector {
   ...
}
----

请参阅： link:#AnnotationReference-metan[@MetaDataCategory] link:#AnnotationReference-mtkpan[@MetaDataKeyParam] link:#AnnotationReference-mtkran[@MetaDataKeyRetriever] +
  link:#AnnotationReference-mtoran[@MetaDataOutputRetriever] link:#AnnotationReference-mtran[@MetaDataRetriever] +
  link:#AnnotationReference-noman[@NoMetaData] link:#AnnotationReference-quan[@Query] link:#AnnotationReference-qupan[@QueryPart] link:#AnnotationReference-qutan[@QueryTranslator]

==  @ MetaDataStaticKey

类别：参数+
Mule版本：3.5及更高版本

定义注释值的特定元数据类型。当应用于 link:#AnnotationReference-procan[@处理器]时，它会影响（默认情况下）输出，否则会影响字段参数。

[source,java, linenums]
----
@Processor
@MetaDataStaticKey(type = "CLIENT")
public Map<String, Object> getClient(String id) {
    return createClientObject();
}
----

请参阅： link:#AnnotationReference-conkan[@ConnectionKey，] link:#AnnotationReference-defan[@默认，] link:#AnnotationReference-eman[@电子邮件]， link:#AnnotationReference-excpan[@ExceptionPayload]， link:#AnnotationReference-optan[@可选的]， link:#AnnotationReference-refan[@RefOnly]

==  @默

类别：通用+
  Mule版本：3.5及更高版本

生成适当的消息头。

[source,java, linenums]
----
@Processor
@Mime("application/json")
public String search(String keyword) {
    ...
}
----

请参阅： link:#AnnotationReference-catan[@类别] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-expran[@Expr] link:#AnnotationReference-expenan[@ExpressionEnricher] +
  link:#AnnotationReference-exevan[@ExpressionEvaluator] link:#AnnotationReference-exlan[@ExpressionLanguage] link:#AnnotationReference-filan[@过滤] link:#AnnotationReference-iconan[@Icons] link:#AnnotationReference-ignan[@忽视] +
  link:#AnnotationReference-modulean[@Module] link:#AnnotationReference-pagean[@Paged] link:#AnnotationReference-procan[@处理器] link:#AnnotationReference-srcan[@资源] link:#AnnotationReference-tranan[@变压器] link:#AnnotationReference-trsan[@TransformerResolver]

==  @模块

类别：通用+
Mule版本：3.5及更高版本

定义一个将其功能导出为Mule模块的类。

类级注释@Module指示需要由DevKit注释处理工具处理Java类并将其视为Mule模块。

@Module不能应用于：

* 接口
* 最终课程
* 参数化类
* 非公开课程

[source,java, linenums]
----
@Module(name="animal-search", schemaVersion="3.6.1")
public class AnimalSearchModule {
    ...
}
----

请参阅： link:#AnnotationReference-catan[@类别] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-expran[@Expr] link:#AnnotationReference-expenan[@ExpressionEnricher] +
  link:#AnnotationReference-exevan[@ExpressionEvaluator] link:#AnnotationReference-exlan[@ExpressionLanguage] link:#AnnotationReference-filan[@过滤] link:#AnnotationReference-iconan[@Icons] link:#AnnotationReference-ignan[@忽视] link:#AnnotationReference-mimean[@哑剧] +
  link:#AnnotationReference-pagean[@Paged] link:#AnnotationReference-procan[@处理器] link:#AnnotationReference-srcan[@资源] link:#AnnotationReference-tranan[@变压器] link:#AnnotationReference-trsan[@TransformerResolver]

==  @ NoMetaData

类别：DataSense +
  Mule版本：3.5及更高版本

标记 link:#AnnotationReference-procan[@处理器]以避免使用@MetaDataRetriever和@MetaDataKeyRetriever机制发现元数据。

请参阅： link:#AnnotationReference-metan[@MetaDataCategory] link:#AnnotationReference-mtkpan[@MetaDataKeyParam] link:#AnnotationReference-mtkran[@MetaDataKeyRetriever] +
  link:#AnnotationReference-mtoran[@MetaDataOutputRetriever] link:#AnnotationReference-mtran[@MetaDataRetriever] link:#AnnotationReference-mtsan[@MetaDataScope] +
  link:#AnnotationReference-quan[@Query] link:#AnnotationReference-qupan[@QueryPart] link:#AnnotationReference-qutan[@QueryTranslator]

==  @的OAuth

类别：OAuth +
  Mule版本：3.5及更高版本

注释使用OAuth 1.0a协议进行认证的连接器。

[source,java, linenums]
----
@Connector(name = "myconnector", friendlyName = "MyConnector")
@OAuth(requestTokenUrl = "https://api.me.com/uas/oauth/requestToken",
accessTokenUrl = "https://api.me.com/uas/oauth/accessToken",
authorizationUrl = "https://api.me.com/uas/oauth/authorize")
public class MyConnector {
    ...
}
----

请参阅： link:#AnnotationReference-oa2an[@的OAuth2] link:#AnnotationReference-oatan[@OAuthAccessToken] link:#AnnotationReference-oatian[@OAuthAccessTokenIdentifier] +
  link:#AnnotationReference-oatsan[@OAuthAccessTokenSecret] link:#AnnotationReference-oaupan[@OAuthAuthorizationParameter] +
  link:#AnnotationReference-oacban[@OAuthCallbackParameter] link:#AnnotationReference-oackan[@OAuthConsumerKey] link:#AnnotationReference-oacsan[@OAuthConsumerSecret] +
  link:#AnnotationReference-oaitan[@OAuthInvalidateAccessTokenOn] link:#AnnotationReference-oapan[@OAuthPostAuthorization] +
  link:#AnnotationReference-oapran[@OAuthProtected] link:#AnnotationReference-oasan[@OAuthScope]

==  @的OAuth2

类别：OAuth +
  Mule版本：3.5及更高版本

注释使用OAuth 2协议进行认证的连接器。

[source,java, linenums]
----
@Connector(name = "oauth2connector")
@OAuth2(authorizationUrl = "http://someUrl", accessTokenUrl = "http://someOtherUrl")
public class MyConnector {
    ...
}
----

请参阅： link:#AnnotationReference-oa1an[@OAuth] link:#AnnotationReference-oatan[@OAuthAccessToken] link:#AnnotationReference-oatian[@OAuthAccessTokenIdentifier] +
  link:#AnnotationReference-oatsan[@OAuthAccessTokenSecret] link:#AnnotationReference-oaupan[@OAuthAuthorizationParameter] +
  link:#AnnotationReference-oacban[@OAuthCallbackParameter] link:#AnnotationReference-oackan[@OAuthConsumerKey] link:#AnnotationReference-oacsan[@OAuthConsumerSecret] +
  link:#AnnotationReference-oaitan[@OAuthInvalidateAccessTokenOn] link:#AnnotationReference-oapan[@OAuthPostAuthorization] +
  link:#AnnotationReference-oapran[@OAuthProtected] link:#AnnotationReference-oasan[@OAuthScope]

==  @ OAuthAccessToken

类别：OAuth +
  Mule版本：3.3及更高版本

持有访问令牌。在调用 link:#AnnotationReference-procan[@处理器]方法时，如果资源所有者已授权使用者，则设置OAuth访问令牌;否则不会调用该方法，并且根据所使用的类级别注释将资源所有者重定向到OAuth或OAuth2授权URL。

*Note*：此注释仅支持类字段。

用 link:#AnnotationReference-oa1an[@OAuth]或 link:#AnnotationReference-oa2an[@的OAuth2]注释的类需要具有一个由@OAuthAccessToken注解的字段。

该字段必须是String类型。

[source,java, linenums]
----
@OAuthAccessToken private String accessToken;
----


请参阅： link:#AnnotationReference-oa1an[@OAuth] link:#AnnotationReference-oa2an[@的OAuth2] link:#AnnotationReference-oatian[@OAuthAccessTokenIdentifier] +
  link:#AnnotationReference-oatsan[@OAuthAccessTokenSecret] link:#AnnotationReference-oaupan[@OAuthAuthorizationParameter] +
  link:#AnnotationReference-oacban[@OAuthCallbackParameter] link:#AnnotationReference-oackan[@OAuthConsumerKey] link:#AnnotationReference-oacsan[@OAuthConsumerSecret] +
  link:#AnnotationReference-oaitan[@OAuthInvalidateAccessTokenOn] link:#AnnotationReference-oapan[@OAuthPostAuthorization] +
  link:#AnnotationReference-oapran[@OAuthProtected] link:#AnnotationReference-oasan[@OAuthScope]

==  @ OAuthAccessTokenIdentifier

类别：OAuth +
  Mule版本：3.5及更高版本

将方法标记为负责识别访问令牌的用户。该方法由连接器的访问令牌管理器调用。该标识被用作存储访问令牌的关键。

[source,java, linenums]
----
@OAuthAccessTokenIdentifier
public String getUserId() {
    return api.getUserId(myAccessToken);
}
----

请参阅： link:#AnnotationReference-oa1an[@OAuth] link:#AnnotationReference-oa2an[@的OAuth2] link:#AnnotationReference-oatan[@OAuthAccessToken] link:#AnnotationReference-oatsan[@OAuthAccessTokenSecret] +
  link:#AnnotationReference-oaupan[@OAuthAuthorizationParameter] link:#AnnotationReference-oacban[@OAuthCallbackParameter] link:#AnnotationReference-oackan[@OAuthConsumerKey] +
  link:#AnnotationReference-oacsan[@OAuthConsumerSecret] link:#AnnotationReference-oaitan[@OAuthInvalidateAccessTokenOn] link:#AnnotationReference-oapan[@OAuthPostAuthorization] +
  link:#AnnotationReference-oapran[@OAuthProtected] link:#AnnotationReference-oasan[@OAuthScope]

==  @ OAuthAccessTokenSecret

类别：OAuth +
  Mule版本：3.5及更高版本

持有访问令牌的秘密。

[source,java, linenums]
----
@OAuthAccessTokenSecret private String accessTokenSecret;
----

请参阅： link:#AnnotationReference-oa1an[@OAuth] link:#AnnotationReference-oa2an[@的OAuth2] link:#AnnotationReference-oatan[@OAuthAccessToken] link:#AnnotationReference-oatian[@OAuthAccessTokenIdentifier] +
  link:#AnnotationReference-oaupan[@OAuthAuthorizationParameter] link:#AnnotationReference-oacban[@OAuthCallbackParameter] link:#AnnotationReference-oackan[@OAuthConsumerKey] +
  link:#AnnotationReference-oacsan[@OAuthConsumerSecret] link:#AnnotationReference-oaitan[@OAuthInvalidateAccessTokenOn] link:#AnnotationReference-oapan[@OAuthPostAuthorization] +
  link:#AnnotationReference-oapran[@OAuthProtected] link:#AnnotationReference-oasan[@OAuthScope]

==  @ OAuthAuthorizationParameter

类别：OAuth +
  Mule版本：3.5及更高版本

附加授权参数以授权URL。

[source,java, linenums]
----
@OAuthAuthorizationParameter(name = "xxx", type = xxx, description = "xxx")
----

请参阅： link:#AnnotationReference-oa1an[@OAuth] link:#AnnotationReference-oa2an[@的OAuth2] link:#AnnotationReference-oatan[@OAuthAccessToken] link:#AnnotationReference-oatian[@OAuthAccessTokenIdentifier] +
  link:#AnnotationReference-oatsan[@OAuthAccessTokenSecret] link:#AnnotationReference-oacban[@OAuthCallbackParameter] link:#AnnotationReference-oackan[@OAuthConsumerKey] +
  link:#AnnotationReference-oacsan[@OAuthConsumerSecret] link:#AnnotationReference-oaitan[@OAuthInvalidateAccessTokenOn] link:#AnnotationReference-oapan[@OAuthPostAuthorization] +
  link:#AnnotationReference-oapran[@OAuthProtected] link:#AnnotationReference-oasan[@OAuthScope]

==  @ OAuthCallbackParameter

类别：OAuth +
  Mule版本：3.5及更高版本

标识表示服务OAuth响应中每个参数的模块属性。

[source,java, linenums]
----
@OAuthCallbackParameter(expression = "#[json:instance_url]")
private String instanceId;
----

请参阅： link:#AnnotationReference-oa1an[@OAuth] link:#AnnotationReference-oa2an[@的OAuth2] link:#AnnotationReference-oatan[@OAuthAccessToken] link:#AnnotationReference-oatian[@OAuthAccessTokenIdentifier] +
  link:#AnnotationReference-oatsan[@OAuthAccessTokenSecret] link:#AnnotationReference-oaupan[@OAuthAuthorizationParameter] +
  link:#AnnotationReference-oackan[@OAuthConsumerKey] link:#AnnotationReference-oacsan[@OAuthConsumerSecret] link:#AnnotationReference-oaitan[@OAuthInvalidateAccessTokenOn] +
  link:#AnnotationReference-oapan[@OAuthPostAuthorization] link:#AnnotationReference-oapran[@OAuthProtected] link:#AnnotationReference-oasan[@OAuthScope]

==  @ OAuthConsumerKey

类别：OAuth +
  Mule版本：3.5及更高版本

持有OAuth使用者密钥。该字段必须包含由服务提供商提供并在OAuth规范中描述的OAuth使用者密钥。

[source,java, linenums]
----
@Configurable @OAuthConsumerKey private String consumerKey;
----

请参阅： link:#AnnotationReference-oa1an[@OAuth] link:#AnnotationReference-oa2an[@的OAuth2] link:#AnnotationReference-oatan[@OAuthAccessToken] link:#AnnotationReference-oatian[@OAuthAccessTokenIdentifier] +
  link:#AnnotationReference-oatsan[@OAuthAccessTokenSecret] link:#AnnotationReference-oaupan[@OAuthAuthorizationParameter] +
  link:#AnnotationReference-oacban[@OAuthCallbackParameter] link:#AnnotationReference-oacsan[@OAuthConsumerSecret] +
  link:#AnnotationReference-oaitan[@OAuthInvalidateAccessTokenOn] link:#AnnotationReference-oapan[@OAuthPostAuthorization] +
  link:#AnnotationReference-oapran[@OAuthProtected] link:#AnnotationReference-oasan[@OAuthScope]

==  @ OAuthConsumerSecret

类别：OAuth +
  Mule版本：3.5及更高版本

拥有OAuth消费者机密。该字段必须包含由服务提供商提供并在OAuth规范中描述的OAuth使用者密钥。

[source,java, linenums]
----
@Configurable @OAuthConsumerSecret private String consumerSecret;
----

请参阅： link:#AnnotationReference-oa1an[@OAuth] link:#AnnotationReference-oa2an[@的OAuth2] link:#AnnotationReference-oatan[@OAuthAccessToken] link:#AnnotationReference-oatian[@OAuthAccessTokenIdentifier] +
  link:#AnnotationReference-oatsan[@OAuthAccessTokenSecret] link:#AnnotationReference-oaupan[@OAuthAuthorizationParameter] +
  link:#AnnotationReference-oacban[@OAuthCallbackParameter] link:#AnnotationReference-oackan[@OAuthConsumerKey] +
  link:#AnnotationReference-oaitan[@OAuthInvalidateAccessTokenOn] link:#AnnotationReference-oapan[@OAuthPostAuthorization] +
  link:#AnnotationReference-oapran[@OAuthProtected] link:#AnnotationReference-oasan[@OAuthScope]

==  @ OAuthInvalidateAccessTokenOn

类别：OAuth +
  Mule版本：3.5及更高版本

标记一种自动刷新令牌的方法。

*Note*：此注释已被弃用。改用@ReconnectOn。

[source,java, linenums]
----
@Processor
@OAuthInvalidateAccessTokenOn(exception = RuntimeException.class)
public void processor() {
    ...
}
----

请参阅： link:#AnnotationReference-oa1an[@OAuth] link:#AnnotationReference-oa2an[@的OAuth2] link:#AnnotationReference-oatan[@OAuthAccessToken] link:#AnnotationReference-oatian[@OAuthAccessTokenIdentifier] +
  link:#AnnotationReference-oatsan[@OAuthAccessTokenSecret] link:#AnnotationReference-oaupan[@OAuthAuthorizationParameter] +
  link:#AnnotationReference-oacban[@OAuthCallbackParameter] link:#AnnotationReference-oackan[@OAuthConsumerKey] link:#AnnotationReference-oacsan[@OAuthConsumerSecret] +
  link:#AnnotationReference-oapan[@OAuthPostAuthorization] link:#AnnotationReference-oapran[@OAuthProtected] link:#AnnotationReference-oasan[@OAuthScope] link:#AnnotationReference-httpbasicauthan[@HTTPBasicAuth]

==  @ OAuthPostAuthorization

类别：OAuth +
  Mule版本：3.5及更高版本

在OAuth内部标记一个方法，作为负责设置连接器_after_ OAuth完成的方法。

[source,java, linenums]
----
@OAuthPostAuthorization
public void postAuthorize() throws ConnectionException, MalformedURLException, AsyncApiException {
    ...
}
----

请参阅： link:#AnnotationReference-oa1an[@OAuth] link:#AnnotationReference-oa2an[@的OAuth2] link:#AnnotationReference-oatan[@OAuthAccessToken] link:#AnnotationReference-oatian[@OAuthAccessTokenIdentifier] +
  link:#AnnotationReference-oatsan[@OAuthAccessTokenSecret] link:#AnnotationReference-oaupan[@OAuthAuthorizationParameter] +
  link:#AnnotationReference-oacban[@OAuthCallbackParameter] link:#AnnotationReference-oackan[@OAuthConsumerKey] link:#AnnotationReference-oacsan[@OAuthConsumerSecret] +
  link:#AnnotationReference-oaitan[@OAuthInvalidateAccessTokenOn] link:#AnnotationReference-oapran[@OAuthProtected] link:#AnnotationReference-oasan[@OAuthScope]

==  @ OAuthProtected

类别：OAuth +
  Mule版本：3.5及更高版本

将连接器内部的方法标记为需要OAuth访问令牌。当连接器未被授权时，这种方法无法执行。因此，迫使OAuth首先发生。

[source,java, linenums]
----
@OAuthProtected
@Processor
public void logInfo() {
   logger.info(String.format("OAuthAccessToken=%s", getAccessToken()));
   logger.info(String.format("OAuthAccessTokenSecret=%s", getAccessTokenSecret()));
}
----

请参阅： link:#AnnotationReference-oa1an[@OAuth] link:#AnnotationReference-oa2an[@的OAuth2] link:#AnnotationReference-oatan[@OAuthAccessToken] link:#AnnotationReference-oatian[@OAuthAccessTokenIdentifier] +
  link:#AnnotationReference-oatsan[@OAuthAccessTokenSecret] link:#AnnotationReference-oaupan[@OAuthAuthorizationParameter] +
  link:#AnnotationReference-oacban[@OAuthCallbackParameter] link:#AnnotationReference-oackan[@OAuthConsumerKey] link:#AnnotationReference-oacsan[@OAuthConsumerSecret] +
  link:#AnnotationReference-oaitan[@OAuthInvalidateAccessTokenOn] link:#AnnotationReference-oapan[@OAuthPostAuthorization] +
  link:#AnnotationReference-oasan[@OAuthScope]

==  @ OAuthScope

类别：OAuth +
  Mule版本：3.5及更高版本

表示对受保护资源的访问权限必须受到限制。用@OAuthScope注释的字段必须存在，并包含一个指示所需范围的字符串。

[source,java, linenums]
----
@Configurable
@OAuthScope
@Optional
@Default("")
private String scope;
----

请参阅： link:#AnnotationReference-oa1an[@OAuth] link:#AnnotationReference-oa2an[@的OAuth2] link:#AnnotationReference-oatan[@OAuthAccessToken] link:#AnnotationReference-oatian[@OAuthAccessTokenIdentifier] +
  link:#AnnotationReference-oatsan[@OAuthAccessTokenSecret] link:#AnnotationReference-oaupan[@OAuthAuthorizationParameter] +
  link:#AnnotationReference-oacban[@OAuthCallbackParameter] link:#AnnotationReference-oackan[@OAuthConsumerKey] link:#AnnotationReference-oacsan[@OAuthConsumerSecret] +
  link:#AnnotationReference-oaitan[@OAuthInvalidateAccessTokenOn] link:#AnnotationReference-oapan[@OAuthPostAuthorization] link:#AnnotationReference-oapran[@OAuthProtected]

==  @ onException的

类别：异常处理+
  Mule版本：3.6及更高版本

在某些情况下，对于意外情况，连接器可以通过以一种或多种方法集中异常处理来改善其用户体验。

当由外部API引发的异常包含导致以下情况的信息时，会出现这些情况：

* 重新连接 - 重试一个操作
* 失败 - 操作失败

在Mule版本3.6之前，当使用@InvalidateConnectionOn或@ReconnectOn引发具体的和预期的异常时，DevKit仅提供了重试当前操作的机制。这需要为每个@Processor添加自定义`try {} catch (){}`代码** **并分析堆栈。

在Mule版本3.6和更高版本中，@OnException机制减少了连接器的代码，并且提高了代码的粒度，因此您可以为不同的处理器定义具体的处理程序。 @OnException标识一个处理程序。使用 link:#AnnotationReference-handleran[@Handler]指定异常处理类，并使用 link:#AnnotationReference-handlean[@处理]来标识异常处理方法。

例：

[source,java, linenums]
----
@OnException (handler=GenericHandler.class)
@Connector ( name = "foo", friendlyName = "Foo" )
{
   @Processor
   public void someOp (...)
   {
      ...
   }
   @OnException (handler=CustomHandler.class)
   @Processor
   public void anotherOp ()
   {
      ...
   }
}
----

另请参阅： link:#AnnotationReference-handlean[@处理] link:#AnnotationReference-handleran[@Handler]


==  @可选

类别：参数+
  Mule版本：3.5及更高版本

将@Configurable字段或@Processor或@Source参数标记为可选。

[source,java, linenums]
----
@Configurable
@Optional
String path;
----

另请参阅： link:#AnnotationReference-conkan[@ConnectionKey] link:#AnnotationReference-defan[@默认] link:#AnnotationReference-eman[@电子邮件] link:#AnnotationReference-excpan[@ExceptionPayload]
link:#AnnotationReference-mtskan[@MetaDataStaticKey] link:#AnnotationReference-refan[@RefOnly]

==  @ OutboundHeaders

类别：参数传递+
  Mule版本：3.5及更高版本

用于传递出站标题。

[source,java, linenums]
----
@Processor
public void outboundHeaders(@OutboundHeaders
Map<String, Object> outboundHeaders) {
    ...
}
----

另请参阅： link:#AnnotationReference-inhean[@InboundHeaders] link:#AnnotationReference-ivhean[@InvocationHeaders] link:#AnnotationReference-payan[@Payload] link:#AnnotationReference-sessa[@SessionHeaders]

==  @分页

类别：通用+
  Mule版本：3.5及更高版本

将 link:#AnnotationReference-connan[@Connector]中的方法标记为返回分页结果集的操作。使用此接口注释的方法也必须使用 link:#AnnotationReference-procan[@处理器]进行注释，并且必须返回@ProviderAwarePagingDelegate的实例。

[source,java, linenums]
----
@Processor
@Paged
public ProviderAwarePagingDelegate paginationTestOperation (String ble, PagingConfiguration pagingConfiguration) throws WrongParameterConfiguredException {
    ...
}
----

请参阅： link:#AnnotationReference-catan[@类别] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-expran[@Expr] link:#AnnotationReference-expenan[@ExpressionEnricher] +
  link:#AnnotationReference-exevan[@ExpressionEvaluator] link:#AnnotationReference-exlan[@ExpressionLanguage] link:#AnnotationReference-filan[@过滤] link:#AnnotationReference-iconan[@Icons] link:#AnnotationReference-ignan[@忽视] link:#AnnotationReference-mimean[@哑剧] +
  link:#AnnotationReference-modulean[@Module] link:#AnnotationReference-procan[@处理器] link:#AnnotationReference-srcan[@资源] link:#AnnotationReference-tranan[@变压器] link:#AnnotationReference-trsan[@TransformerResolver]

==  @密码

类别：显示+
  Mule版本：3.5及更高版本

将字段或方法参数标识为密码，或更一般地将其指定为包含无法以纯文本显示的数据的变量。

[source,java, linenums]
----
@Connect
public void connect(@ConnectionKey String username,
  @Password String password)
        throws ConnectionException {
     ...
}
----

以下内容显示密码如何显示在全局元素属性中：

image:password-screenshot.png[密码截图]

请参阅： link:#AnnotationReference-fnan[@友好名称] link:#AnnotationReference-pathan[@路径] link:#AnnotationReference-plcan[@放置] link:#AnnotationReference-suman[@概要] link:#AnnotationReference-textan[@文本]

==  @路径

类别：显示+
  Mule版本：3.5及更高版本

将字段或方法参数标识为文件的路径。这会在Studio中显示一个窗口，从文件系统中选择一个文件。

[source,java, linenums]
----
@Configurable
@Path
String path;
----

请参阅： link:#AnnotationReference-fnan[@友好名称] link:#AnnotationReference-passan[@密码] link:#AnnotationReference-plcan[@放置] link:#AnnotationReference-suman[@概要] link:#AnnotationReference-textan[@文本]

==  @净荷

类别：参数传递+
  Mule版本：3.5及更高版本

标记参数以接收有效载荷。

[source,java, linenums]
----
@Processor
public String setPayload(@Payload String payload) {
    ...
}
----

另请参阅： link:#AnnotationReference-inhean[@InboundHeaders] link:#AnnotationReference-ivhean[@InvocationHeaders] link:#AnnotationReference-outhan[@OutboundHeaders] link:#AnnotationReference-sessa[@SessionHeaders]

==  @放置

类别：显示+
  Mule版本：3.5及更高版本

定义Anypoint Studio配置中可配置属性的位置。

使用此注释来实例变量和方法参数。它接受以下参数：

*  *order*  - 组内注释元素的相对顺序。如果提供的值是重复的，那么这些元素的顺序是任意定义的。价值是相对的;具有顺序10的元素具有比具有值25的元素更高的优先级。
*  *group*  - 一种显示一个或多个变量的逻辑方法。如果你没有指定一个组，那么Mule会默认一个默认组。要将多个元素放置在同一组中，请为此属性分配相同的值。
*  *tab*  - 将注释元素分组在一起的合理方法。此属性指定要在其中显示注释元素的选项卡的名称。如果没有指定标签，那么Mule将采用默认标签。要在同一选项卡中显示多个参数，请为此属性分配相同的值。

[source,java, linenums]
----
@Configurable
@Placement(group = "Basic Settings", order = 1)
private String consumerKey;
----

以下代码为*Consumer Key*和*Consumer Secret*设置创建*General*> *Basic Settings*：

[source,java, linenums]
----
@Configurable
@Placement(group = "Basic Settings", order = 1)
@FriendlyName("Consumer Key")
private String consumerKey;

@Configurable
@Placement(group = "Basic Settings", order = 3)
@FriendlyName("Consumer Secret")
@Summary("consumer secret for authentication")
private String consumerSecret;
----

生成的屏幕是：

image:placement-1-screenshot.png[放置-1-截图]

此代码在“常规信息”部分下创建*Advanced Settings*> *Application Name*设置：

[source,java, linenums]
----
@Configurable
@Placement(tab="Advanced Settings", group = "General Information", order = 2)
@Summary("the application name")
@FriendlyName("Application Name")
private String applicationName;
----

生成的屏幕是：

image:placement-2-screenshot.png[放置-2-截图]

请参阅： link:#AnnotationReference-fnan[@友好名称] link:#AnnotationReference-passan[@密码] link:#AnnotationReference-pathan[@路径] link:#AnnotationReference-suman[@概要] link:#AnnotationReference-textan[@文本]

==  @处理器

类别：通用+
  Mule版本：3.5及更高版本

将方法标记为连接器中的操作。 @Processor方法生成通用消息处理器。此注释的参数是可选的。 friendlyName让您指定操作的显示名称。

[source,java, linenums]
----
@Processor(friendlyName="OperationName", name="SchemaName")
 public String putInBarn(String animal) {
     return animal + " has been placed in the barn";
 }
----

请参阅： link:#AnnotationReference-catan[@类别] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-expran[@Expr] link:#AnnotationReference-expenan[@ExpressionEnricher] +
  link:#AnnotationReference-exevan[@ExpressionEvaluator] link:#AnnotationReference-exlan[@ExpressionLanguage] link:#AnnotationReference-filan[@过滤] link:#AnnotationReference-iconan[@Icons] link:#AnnotationReference-ignan[@忽视] link:#AnnotationReference-mimean[@哑剧] +
  link:#AnnotationReference-modulean[@Module] link:#AnnotationReference-pagean[@Paged] link:#AnnotationReference-srcan[@资源] link:#AnnotationReference-tranan[@变压器] link:#AnnotationReference-trsan[@TransformerResolver]

==  @查询

类别：DataSense +
  Mule版本：3.5及更高版本

通过使用DataSense查询语言（DSQL）支持简单的查询构建。在 link:#AnnotationReference-connan[@Connector]范围内定义@Query。

[source,java, linenums]
----
@Processor
public void setQuery(@Query DsglQuery query) {
    ...
}
----

请参阅： link:#AnnotationReference-metan[@MetaDataCategory] link:#AnnotationReference-mtkpan[@MetaDataKeyParam] link:#AnnotationReference-mtkran[@MetaDataKeyRetriever] +
  link:#AnnotationReference-mtoran[@MetaDataOutputRetriever] link:#AnnotationReference-mtran[@MetaDataRetriever] link:#AnnotationReference-mtsan[@MetaDataScope] +
  link:#AnnotationReference-noman[@NoMetaData] link:#AnnotationReference-qupan[@QueryPart] link:#AnnotationReference-qutan[@QueryTranslator]

==  @ QueryPart

类别：DataSense +
  Mule版本：3.5及更高版本

用于高级@Query场景。

请参阅： link:#AnnotationReference-metan[@MetaDataCategory] link:#AnnotationReference-mtkpan[@MetaDataKeyParam] link:#AnnotationReference-mtkran[@MetaDataKeyRetriever] +
  link:#AnnotationReference-mtoran[@MetaDataOutputRetriever] link:#AnnotationReference-mtran[@MetaDataRetriever] link:#AnnotationReference-mtsan[@MetaDataScope] +
  link:#AnnotationReference-noman[@NoMetaData] link:#AnnotationReference-quan[@Query] link:#AnnotationReference-qutan[@QueryTranslator]

==  @ QueryTranslator

类别：DataSense +
  Mule版本：3.5及更高版本

将DSQL查询翻译为本地语言。

[source,java, linenums]
----
@QueryTranslator
public String toNativeQuery(DsqlQuery query){
    SimpleSyntaxVisitor visitor = new SimpleSyntaxVisitor();
    query.accept(visitor);
    return visitor.dsqlQuery();
}
----

请参阅： link:#AnnotationReference-metan[@MetaDataCategory] link:#AnnotationReference-mtkpan[@MetaDataKeyParam] link:#AnnotationReference-mtkran[@MetaDataKeyRetriever] +
  link:#AnnotationReference-mtoran[@MetaDataOutputRetriever] link:#AnnotationReference-mtran[@MetaDataRetriever] link:#AnnotationReference-mtsan[@MetaDataScope] +
  link:#AnnotationReference-noman[@NoMetaData] link:#AnnotationReference-quan[@Query] link:#AnnotationReference-qupan[@QueryPart]

==  @ ReconnectOn

类别：连接管理+
  Mule版本：3.5及更高版本

此注释用于与连接相关的异常处理。它可以在类级别（使用`@Connector`批注注释）或方法级别（使用`@Processor`批注批注）使用。如果连接器或处理器引发此类的异常，则`@ReconnectOn`会自动使连接失效。 `@ReconnectOn`接收包含要捕获的异常类的列表（请参阅下面的示例）。发生异常时，`@ReconnectOn`的行为基于配置的重新连接策略。

用于使连接无效。您可以将此注释附加到使用@Processor注释的任何方法。如果Processor或Source引发与@ReconnectOn注释中指定的任何异常相匹配的异常，则连接将失效。

[source,java, linenums]
----
@Processor
@ReconnectOn(exceptions = {InvalidSessionFault.class, PasswordChangedException.class})
public void myOperation(@Optional String source,
  @Optional Object destination) throws InvalidSessionFault, PasswordChangedException, InvalidParameterException
{
    /**
    * CODE FOR MY OPERATION
    */
}
----

请参阅： link:/anypoint-connector-devkit/v/3.6/connection-management[连接管理] link:#AnnotationReference-cnctan[@Connect] link:#AnnotationReference-coidan[@ConnectionIdentifier] link:#AnnotationReference-discan[@断开] +
  link:#AnnotationReference-invan[@InvalidateConnectionOn] link:#AnnotationReference-valcan[@ValidateConnection]

==  @ RefOnly

类别：参数+
  Mule版本：3.5及更高版本

将 link:#AnnotationReference-confan[@Configurable]字段， link:#AnnotationReference-procan[@处理器]参数或 link:#AnnotationReference-srcan[@资源]参数标记为仅以参考形式传递。

请参阅： link:#AnnotationReference-conkan[@ConnectionKey] link:#AnnotationReference-defan[@默认] link:#AnnotationReference-eman[@电子邮件] link:#AnnotationReference-excpan[@ExceptionPayload] link:#AnnotationReference-mtskan[@MetaDataStaticKey]

==  @ RequiresEntitlement

检查 link:#AnnotationReference-module[@Module]或 link:#AnnotationReference-procan[@处理器]是否需要具有特定权利的Enterprise许可证。在连接器级别工作。仅限企业。

[source,java, linenums]
----
@RequiresEntitlement
@Connector
public class SuperConnector(){
 .....
}
----

==  @ RequiresEnterpriseLicense

检查 link:#AnnotationReference-module[@Module]或 link:#AnnotationReference-procan[@处理器]是否需要Enterprise许可证。许可证可以是评估许可证或不是。在连接器级别工作。仅限企业。

[source,java, linenums]
----
@RequiresEnterpriseLicense
@Connector
public class SuperConnector(){
 ...
}
----

==  @ RestCall

类别：REST +
  Mule版本：3.5及更高版本

与 link:#AnnotationReference-procan[@处理器]注释一起使用。指示在调用时，处理器发出RESTful请求。

DevKit提供了一组注释来简化使用RESTful API的工作。这些注释处理所有必要的操作，生成每个REST调用，并合并每个REST调用参数。

必需的参数：

*  *uri*：要查询的REST资源的URI
*  *method*：使用的HTTP方法

生成的代码基于传递给@RestCall注释的参数创建URI，并使用由@RestCall的方法参数指定的动词发出请求。

[source,java, linenums]
----
@Processor
@RestCall(uri = "{url}/list", method = org.mule.api.annotations.rest.HttpMethod.GET)
public abstract String showAll() throws IOException;
----

可选参数：

*  *contentType*：来自此方法调用的响应的内容类型。
+
[source,java, linenums]
----
@Processor
@RestCall(uri = "{url}/list", method = HttpMethod.POST, contentType = "application/json")
exceptions: A list of exceptions to throw, configured by pairing an exception type and an expression which is evaluated.
----

*  *exceptions*：抛出异常列表，通过配对异常类型和被评估的表达式进行配置。
+
[source,java, linenums]
----
@Processor
@RestCall(uri = "{url}/list", method = HttpMethod.POST, contentType = "application/json", exceptions = {@RestExceptionOn(expression="#[message.inboundProperties['http.status'] != 200]", exception = AnimalNotFoundException.class)})
----
+
在这种情况下，@RestExceptionOn注释用于在指定的条件下抛出异常。在上例中，如果HTTP状态不是200，则会引发异常。

请参阅： link:#AnnotationReference-binpan[@BinaryParam] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-rstean[@RestExceptionOn] link:#AnnotationReference-rstpan[@RestHeaderParam] link:#AnnotationReference-rshcan[@RestHttpClient] +
  link:#AnnotationReference-rsppan[@RestPostParam] link:#AnnotationReference-rsqpan[@RestQueryParam] link:#AnnotationReference-rstoan[@RestTimeout] link:#AnnotationReference-rsupan[@RestUriParam]

==  @ RestExceptionOn

类别：REST +
  Mule版本：3.5及更高版本

根据指定的条件抛出异常。

[source,java, linenums]
----
@Processor
@RestCall(uri = "{url}/animals", method = HttpMethod.GET, exceptions = {@RestExceptionOn(expression="#[message.inboundProperties['http.status'] != 200]", exception = AnimalNotFoundException.class)})
public abstract List<Animal> listAnimals(@RestQueryParam("type") String type) throws IOException;
----

请参阅： link:#AnnotationReference-binpan[@BinaryParam] link:#AnnotationReference-rstcan[@RestCall] link:#AnnotationReference-rstpan[@RestHeaderParam] link:#AnnotationReference-rshcan[@RestHttpClient] link:#AnnotationReference-rsppan[@RestPostParam] +
  link:#AnnotationReference-rsqpan[@RestQueryParam] link:#AnnotationReference-rstoan[@RestTimeout] link:#AnnotationReference-rsupan[@RestUriParam]

==  @ RestHeaderParam

类别：REST +
  Mule版本：3.5及更高版本

允许您在HTTP请求中插入自定义标头。使用此注释时，您必须指定要包含在呼叫中的标题的名称。与@RestURIParam注释一样，您可以将此注释应用于@Processor方法参数或标记为@Configurable的连接器字段。

使用@RestHeaderParam注释特定的可配置变量时，变量存在于所有HTTP请求中。

[source,java, linenums]
----
@Configurable
@RestHeaderParam(value = "emptyHeaderField", ignoreIfEmpty = true)
private String emptyHeaderField;
----

在方法的特定参数上使用@RestHeaderParam时，只有在调用方法时才会包含标题。

[source,java, linenums]
----
@Processor
@RestCall(uri = "{url}/create", method = org.mule.api.annotations.rest.HttpMethod.POST)
public abstract String create( @RestHeaderParam("age")
int age)
throws IOException;
----

请参阅： link:#AnnotationReference-binpan[@BinaryParam] link:#AnnotationReference-rstcan[@RestCall] link:#AnnotationReference-rstean[@RestExceptionOn] link:#AnnotationReference-rshcan[@RestHttpClient] link:#AnnotationReference-rsppan[@RestPostParam] +
  link:#AnnotationReference-rsqpan[@RestQueryParam] link:#AnnotationReference-rstoan[@RestTimeout] link:#AnnotationReference-rsupan[@RestUriParam]

==  @ RestHttpClient

类别：REST +
  Mule版本：3.5及更高版本

标记模块使用的HttpClient的注释。这样，您可以避免创建多个客户端，并有机会执行自己的调用或配置HttpClient以满足特殊需求：

[source,java, linenums]
----
@RestHttpClient
HttpClient client = new HttpClient();
----

请参阅： link:#AnnotationReference-binpan[@BinaryParam] link:#AnnotationReference-rstcan[@RestCall] link:#AnnotationReference-rstean[@RestExceptionOn] link:#AnnotationReference-rstpan[@RestHeaderParam] link:#AnnotationReference-rsppan[@RestPostParam] +
  link:#AnnotationReference-rsqpan[@RestQueryParam] link:#AnnotationReference-rstoan[@RestTimeout] link:#AnnotationReference-rsupan[@RestUriParam]

==  @ RestPostParam

类别：REST +
  Mule版本：3.5及更高版本

允许您在POST方法调用的主体中设置参数。使用@RestCall定义POST方法并使用@RestPostParam设置其参数。

您可以将此注释应用于@Processor方法参数或标记为@Configurable的连接器字段。 DevKit确保您仅将此注释应用于POST方法。

用@RestPostParam注解的处理器方法不能使用未注释的参数或@Payload注释的参数。

例如：

[source,java, linenums]
----
@Processor
@RestCall(uri = "{url}/form", method = HttpMethod.POST)
public abstract String addAnimal(@RestPostParam("type") String type) throws IOException;
----

另一种方法是用@RestPostParam注释一个@Configurable变量，如下所示：

[source,java, linenums]
----
@Configurable
@RestPostParam("category")
private String category;

@Processor
@RestCall(uri = "http://localhost:8089/product/", method = HttpMethod.POST)
  public abstract Result createProduct(String name) throws IOException;
----

请参阅： link:#AnnotationReference-binpan[@BinaryParam] link:#AnnotationReference-rstcan[@RestCall] link:#AnnotationReference-rstean[@RestExceptionOn] link:#AnnotationReference-rstpan[@RestHeaderParam] link:#AnnotationReference-rshcan[@RestHttpClient] link:#AnnotationReference-rsqpan[@RestQueryParam] link:#AnnotationReference-rstoan[@RestTimeout] link:#AnnotationReference-rsupan[@RestUriParam]

==  @ RestQueryParam

类别：REST +
  Mule版本：3.5及更高版本

指定URI查询参数，这些参数被附加到URI的路径后面？或＆符号。您可以将此注释应用于@Processor方法参数或标记为@Configurable的连接器字段。这使您可以将动态生成的参数用作查询参数。

必需参数：要追加的参数的名称的字符串表示形式。

[source,java, linenums]
----
@Processor
@RestCall(uri = "{url}/listName", method = org.mule.api.annotations.rest.HttpMethod.GET)
public abstract String getByType(
@RestQueryParam("type") String type)
throws IOException;
----

当以`mule`作为参数调用getByType消息处理器时，结果调用将为：

[source,html, linenums]
----
http://localhost:8089/animals?type=mule
----

请参阅： link:#AnnotationReference-binpan[@BinaryParam] link:#AnnotationReference-rstcan[@RestCall] link:#AnnotationReference-rstean[@RestExceptionOn] link:#AnnotationReference-rstpan[@RestHeaderParam] link:#AnnotationReference-rshcan[@RestHttpClient] +
  link:#AnnotationReference-rsppan[@RestPostParam] link:#AnnotationReference-rstoan[@RestTimeout] link:#AnnotationReference-rsupan[@RestUriParam]

==  @ RestTimeout

类别：REST +
  Mule版本：3.5及更高版本

指定其余呼叫的超时时间。此注释可以附加到@RestCall，以便为其余的调用指定一个以毫秒为单位的超时值。如果其余调用超过指定的时间，则会抛出RuntimeException，除非为超时指定了异常。

[source,java, linenums]
----
@Processor
@RestTimeout(timeout = 1, exception = TimeoutException.class)
@RestCall(uri = "{url}/list/timeout", method = HttpMethod.GET)
public abstract String listAnimalsTimeout() throws IOException;
----

请参阅： link:#AnnotationReference-binpan[@BinaryParam] link:#AnnotationReference-rstcan[@RestCall] link:#AnnotationReference-rstean[@RestExceptionOn] link:#AnnotationReference-rstpan[@RestHeaderParam] link:#AnnotationReference-rshcan[@RestHttpClient] +
  link:#AnnotationReference-rsppan[@RestPostParam] link:#AnnotationReference-rsqpan[@RestQueryParam] link:#AnnotationReference-rsupan[@RestUriParam]

==  @ RestUriParam

类别：REST +
  Mule版本：3.5及更高版本

允许您通过插入使用@RestUriParam批注注释的参数动态生成URI。

您可以在连接器的`@Processor`方法参数或 link:#AnnotationReference-confan[@Configurable]字段上使用 link:#AnnotationReference-rsupan[@RestUriParam]批注以及其他相关批注。

当生成请求调用时，DevKit包含一个未注释的参数和一个用 link:#AnnotationReference-payan[@Payload]注释的参数作为调用的主体。

将注释应用于@Processor方法时，通过用花括号括住占位符来指定URI中的占位符，例如`{type}.`

您可以将@RestUriParam应用于@Processor方法参数，如下所示：

[source,java, linenums]
----
@Processor
@RestCall(uri = "{url}/create/{type}", method = org.mule.api.annotations.rest.HttpMethod.POST)
public abstract String create(@RestUriParam("type") String type)  throws IOException;
----

另一种方法是用@RestUriParam注释@Configurable变量，如下所示：

[source,java, linenums]
----
@Configurable
@RestUriParam("url")
@Default("http://localhost:8089")
private String url;

@Processor
@RestCall(uri = "{url}/listType", method = org.mule.api.annotations.rest.HttpMethod.GET)
  public abstract String getByType(@RestQueryParam("type") String type)
   throws IOException;
----

下一个例子取代了路径：

[source,java, linenums]
----
@RestCall(uri = "http://myservice.com/{path}", method = HttpMethod.HEAD)
----

引用路径参数：

[source,java, linenums]
----
...
Public abstract String setPath(@RestURIParam String path ...
----

请参阅： link:#AnnotationReference-binpan[@BinaryParam] link:#AnnotationReference-rstcan[@RestCall] link:#AnnotationReference-rstean[@RestExceptionOn] link:#AnnotationReference-rstpan[@RestHeaderParam] +
  link:#AnnotationReference-rshcan[@RestHttpClient] link:#AnnotationReference-rsppan[@RestPostParam] link:#AnnotationReference-rsqpan[@RestQueryParam] link:#AnnotationReference-rstoan[@RestTimeout]

==  @ SessionHeaders

类别：参数传递+
  Mule版本：3.5及更高版本

标记传入一个或多个收到标题的方法参数。

此注释值可以定义单个标题，标题名称的逗号分隔列表，星号“*' to denote all headers, or a comma-separated list of wildcard expressions such as `MULE_*，X  -  *”。默认情况下，如果当前消息中不存在已命名的标头，则会引发异常。但是，如果标头名称是用'？'定义的后期修复，它被标记为可选。

定义多个标题名称或使用通配符时，此参数可以是Map或List。如果使用Map，则会传递标题名称和值。如果使用List，则仅使用标题值。

如果定义了单个标题名称，则可以将标题类型用作参数类型，但也可以使用List或Map。

Inbound头部集合是不可变的，所以传入的头部Map或List也是不可变的。试图写入映射或列表结果的UnsupportedOperationException。

另请参阅： link:#AnnotationReference-inhean[@InboundHeaders] link:#AnnotationReference-ivhean[@InvocationHeaders] link:#AnnotationReference-outhan[@OutboundHeaders] link:#AnnotationReference-payan[@Payload]

==  //开始

类别：LifeCycle +
  Mule版本：3.5及更高版本

在方法的`org.mule.lifecycle.Startable`阶段标记要启动的方法。 *Note:* `start`是保留字，不能用作方法的名称。

[source,java, linenums]
----
@Start
public void mystart() {
     this.sessionId = serviceProvider.login(username, password);
}
----

另请参阅： link:#AnnotationReference-displ[@Dispose] link:#AnnotationReference-initan[@Initialise] link:#AnnotationReference-stopan[@停止]

==  @停止

类别：LifeCycle +
  Mule版本：3.5及更高版本

在方法的`org.mule.lifecycle.Stoppable`阶段标记要停止的方法。 *Note:* `stop`是保留字，不能用作方法的名称。

[source,java, linenums]
----
@Start
public void mystop() {
    if ( this.sessionId != null ) {
       serviceProvider.logout(sessionId);
    }
}
----

另请参阅： link:#AnnotationReference-displ[@Dispose] link:#AnnotationReference-initan[@Initialise] link:#AnnotationReference-stan[@开始]

==  @源

类别：通用+
  Mule版本：3.5及更高版本

将 link:#AnnotationReference-connan[@Connector]内的方法标记为可从Mule流中调用，并且能够生成Mule事件。

此注释将 link:http://mulesoft.github.io/mule-devkit/3.6.2/apidocs/org/mule/api/annotations/Module.html[模]中的方法标记为可从Mule流中调用，并且能够生成Mule事件。每个标记的方法都有一个`org.mule.api.source.MessageSource`生成。该方法必须接收SourceCallback作为其参数之一。只要它在那里，哪个参数是无关紧要的。

[source,java, linenums]
----
@Source
public void subscribeTopic(String topic, final SourceCallback callback) {
  getBayeuxClient().subscribe(topic, new ClientSessionChannel.MessageListener() {
    @Override
    public void onMessage(ClientSessionChannel channel, Message message) {
      try {
        callback.process(message.getData());
      } catch (Exception e) {
        LOGGER.error(e);
      }
    }
  });
}
----

调用此方法如下：

[source,xml, linenums]
----
<flow name="myFlow">
  <sfdc:subscribe-topic topic="/someTopic"/>
  <logger level="INFO" message="#[payload]"/>
  ...
</flow>
----

此流程订阅了一个主题，当出现更新时，调用记录器消息处理器。

请参阅： link:#AnnotationReference-catan[@类别] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-expran[@Expr] link:#AnnotationReference-expenan[@ExpressionEnricher] +
  link:#AnnotationReference-exevan[@ExpressionEvaluator] link:#AnnotationReference-exlan[@ExpressionLanguage] link:#AnnotationReference-filan[@过滤] link:#AnnotationReference-iconan[@Icons] link:#AnnotationReference-ignan[@忽视] link:#AnnotationReference-mimean[@哑剧] +
  link:#AnnotationReference-modulean[@Module] link:#AnnotationReference-pagean[@Paged] link:#AnnotationReference-procan[@处理器] link:#AnnotationReference-tranan[@变压器] link:#AnnotationReference-trsan[@TransformerResolver]



==  @摘要

类别：显示+
  Mule版本：3.5及更高版本

将显示信息添加到字段或参数。使用此注释来实例变量和方法参数，以提供覆盖 link:#AnnotationReference-confan[@Configurable]变量或 link:#AnnotationReference-procan[@处理器]， link:#AnnotationReference-srcan[@资源]， link:#AnnotationReference-tranan[@变压器]方法参数的默认推断描述的方法。

[source,java, linenums]
----
@Processor
@Summary("This processor puts an animal in the barn")
public String putInBarn(String animal)
{
    return animal + "has been placed in the barn";
}
----

请参阅： link:#AnnotationReference-fnan[@友好名称] link:#AnnotationReference-passan[@密码] link:#AnnotationReference-pathan[@路径] link:#AnnotationReference-plcan[@放置] link:#AnnotationReference-textan[@文本]

==  @ TestConnectivity

类别：连接管理+
Mule版本：3.6及更高版本

指示用于测试连接连接的类。 @TestConnectivity使连接器更简单，并有助于构建更好的连接策略。

以下示例适用于具有连接管理和连接测试的连接器：

[source,java, linenums]
----
@ConnectionManagement
public class BasicAuthConnectionStrategy{
  @Connect
  @TestConnectivity //(active=true) default
  //Connection management methods
}
----

以下示例适用于具有连接管理和无连接测试的连接器：

[source,java, linenums]
----
@ConnectionManagement
public class BasicAuthConnectionStrategy{
  @Connect
  @TestConnectivity(active=false)
  //Connection management methods
}
----

以下示例适用于没有连接管理和连接测试的连接器：

[source,java, linenums]
----
@Configuration
public class BasicConnectionStrategy{
  @TestConnectivity//(active=true) default
  public void myCustomMethodForTestingConnectivity() throws ConnectionException{
    //code that uses @Configurable
    ..
    if ("something went wrong"){
      throw new ConnectionException(
         ConnectionExceptionCode.CANNOT_REACH,
         "what your API has returned, if it did..",
         "some meaninful stuff about your API")
    }
    ...
    //if we manage to get here, it means that the connection was
    // successful, hence, no need to return a boolean
  }
}
----

@TestConnectivity方法必须：

* 接收零参数。当使用@TestConnectivity注释时，此约束不适用于@Connect方法。
* 抛出`org.mule.api.ConnectionException`。
* 公开而不是静态的。
* 不包含任何状态，只使用@Configurable（或@Connect参数，如果这是注释的方法）。
* 在没有连接管理器的情况下工作在@Connector中（因为测试连接方案在@Connect方法中进行了介绍）。

另请参阅： link:#AnnotationReference-configan[@组态] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-cnctan[@Connect]

==  @文本

类别：显示+
  Mule版本：3.5及更高版本

将参数标识为大型文本输入。此标记为模式生成生成子元素而不是属性，但它也使用文本区域而不是Anypoint Studio对话框生成中的文本字段。

请参阅： link:#AnnotationReference-fnan[@友好名称] link:#AnnotationReference-passan[@密码] link:#AnnotationReference-pathan[@路径] link:#AnnotationReference-plcan[@放置] link:#AnnotationReference-suman[@概要]

==  @变压器

类别：通用+
  Mule版本：3.5及更高版本

在连接器的上下文中将方法标记为数据类型的Transformer或数据格式。

这个注释标识了一个变成Mule变换器的方法。

[source,java, linenums]
----
@Transformer(sourceTypes = { Object[].class })
public static List transformArrayToList(@Payload Object[] payload)
----

请参阅： link:#AnnotationReference-catan[@类别] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-expran[@Expr] link:#AnnotationReference-expenan[@ExpressionEnricher] +
  link:#AnnotationReference-exevan[@ExpressionEvaluator] link:#AnnotationReference-exlan[@ExpressionLanguage] link:#AnnotationReference-filan[@过滤] link:#AnnotationReference-iconan[@Icons] link:#AnnotationReference-ignan[@忽视] +
  link:#AnnotationReference-mimean[@哑剧] link:#AnnotationReference-modulean[@Module] link:#AnnotationReference-pagean[@Paged] link:#AnnotationReference-procan[@处理器] link:#AnnotationReference-srcan[@资源] link:#AnnotationReference-trsan[@TransformerResolver]

==  @ TransformerResolver

类别：通用+
  Mule版本：3.5及更高版本

查找符合注册表中的标准的变换器。该接口的实现使用传入的一些或全部信息来发现匹配的变压器。

在实现之前注册与注册表的接口的实现可以被获取。通常使用`registry-bootstrap.properties`完成。

[source,java, linenums]
----
@TransformerResolver
public static org.mule.api.transformer.Transformer
  transformerResolver(DataType source, DataType result,
  MuleContext muleContext) throws Exception {
    if(source.getType().equals(Book.class) &&
      result.getType().equals(String.class)) {
        BookToString bookToString = new BookToString();
        muleContext.getRegistry().
          applyProcessorsAndLifecycle(bookToString);
        return bookToString;
   }
      return null;
}
----

请参阅： link:#AnnotationReference-catan[@类别] link:#AnnotationReference-confan[@Configurable] link:#AnnotationReference-connan[@Connector] link:#AnnotationReference-expran[@Expr] link:#AnnotationReference-expenan[@ExpressionEnricher] link:#AnnotationReference-exevan[@ExpressionEvaluator] link:#AnnotationReference-exlan[@ExpressionLanguage] link:#AnnotationReference-filan[@过滤] link:#AnnotationReference-iconan[@Icons] {{ 9}} link:#AnnotationReference-mimean[@哑剧] +
  link:#AnnotationReference-modulean[@Module] link:#AnnotationReference-pagean[@Paged] link:#AnnotationReference-procan[@处理器] link:#AnnotationReference-srcan[@资源] link:#AnnotationReference-tranan[@变压器]

==  @ ValidateConnection

类别：连接管理+
  Mule版本：3.5及更高版本

在每次调用 link:#AnnotationReference-procan[@处理器]注释公开的操作之前验证连接。

这个方法被Mule调用来检查连接是否实际打开。

用`@ValidateConnection`注释的方法必须：

* 为`public`
* 不要输入参数
*  {返回{1}}或`java.lang.Boolean`

只有`@Connector`类中的一种方法可以用`@ValidateConnection.`进行注释

以下示例确定连接是否处于活动状态。代码只是检查连接参数是否为空。取决于协议，其他连接器可能需要不同的实现。

[source,java, linenums]
----
@ValidateConnection
public boolean isConnected() {
    return connection != null;
}
----

请参阅： link:/anypoint-connector-devkit/v/3.6/connection-management[连接管理] link:#AnnotationReference-cnctan[@Connect] link:#AnnotationReference-coidan[@ConnectionIdentifier] link:#AnnotationReference-discan[@断开] link:#AnnotationReference-invan[@InvalidateConnectionOn] link:#AnnotationReference-recan[@ReconnectOn]
