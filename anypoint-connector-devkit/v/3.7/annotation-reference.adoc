= 注释参考
:keywords: devkit, annotation, reference

本文档列出了MuleSoft DevKit核心Java注释。

*{{0}}*

== 类别摘要

[%header,cols="2*"]
|===
| {类别{1}}注解
| *Newest Annotations* a |
Mule 3.6：xref：configan [@Configuration] xref：connmgmtan [@ConnectionManagement] xref：connstratan [@ConnectionStrategy] xref：handlean [@Handle] xref：handleran [@Handler] xref：httpbasicauthan [@HTTPBasicAuth] xref：literalan [文字] xref：onexceptionan [@OnException] xref：reqentitlean [@RequiresEntitlement] xref：reqentlican [@RequiresEnterpriseLicense] xref：testconnan [@TestConnectivity]

Mule 3.7：xref：userdefan [@UserDefinedMetaData] xref：wsdlprovan [@WsdlProvider] xref：wsdlservendan [@WsdlServiceEndpoint] xref：wsdlservretan [@WsdlServiceRetriever] xref：confan [@Configurable]和xref：testconnan [@TestConnectivity]

{@ 1}} *General*  | xref：catan [@Category] ​​xref：confan [@Configurable] xref：connan [@Connector] xref：expran [@Expr] xref：
外部参照：exevan [@ExpressionEvaluator]外部参照：EXLAN [@ExpressionLanguage]外部参照：菲兰[@Filter]外部参照：iconan [@Icons]
外部参照：ignan [@Ignore]外部参照：mimean [@Mime]外部参照：modulean [@Module]外部参照：pagean [@Paged]外部参照：procan [@Processor]
外部参照：srcan [@Source]外部参照：tranan [@Transformer]外部参照：trsan [@TransformerResolver]

{@ 1}} *Argument Passing*  | xref：inhean [@InboundHeaders] xref：ivhean [@InvocationHeaders] xref：literalan [@Literal] xref：outhan [@OutboundHeaders]
xref：payan [@Payload] xref：sessa [@SessionHeaders]

{@ 1}} *Connection Management*  | xref：cnctan [@Connect] xref：coidan [@ConnectionIdentifier] xref：connmgmtan [@ConnectionManagement] xref：connstratan [@ConnectionStrategy] xref：discan [@Disconnect] xref：invan [@InvalidateConnectionOn] xref：recan [@ReconnectOn] xref：valcan [@ValidateConnection]

| *DataSense*  | xref：metan [@MetaDataCategory] ​​xref：mtkpan [@MetaDataKeyParam] xref：mtkran [@MetaDataKeyRetriever]
xref：mtoran [@MetaDataOutputRetriever] xref：mtran [@MetaDataRetriever] xref：mtsan [@MetaDataScope] xref：noman [@NoMetaData] xref：quan [@Query] xref：qupan [@QueryPart] xref：qutan [@QueryTranslator]

{@ 1}} *Display*  | xref：fnan [@FriendlyName] xref：passan [@Password] xref：pathan [@Path] xref：plcan [@Placement] xref：suman [@Summary]外部参照：textan [@Text]

| *Exception Management*  | xref：onexceptionan [@OnException] xref：handleran [@Handler] xref：handlean [@Handle]

{@ 1}} *Lifecycle*  | xref：displ [@Dispose] xref：initan [@Initialise] xref：stan [@Start] xref：stopan [@Stop]

| *Authentication*  |外部参照：httpbasicauthan [@HTTPBasicAuth]

{@ 0}} xref：oa1an [@OAuth] xref：oa2an [@ OAuth2] xref：oatan [@OAuthAccessToken] xref：oatian [@OAuthAccessTokenIdentifier]
xref：oatsan [@OAuthAccessTokenSecret] xref：oaupan [@OAuthAuthorizationParameter]
xref：oacban [@OAuthCallbackParameter] xref：oackan [@OAuthConsumerKey] xref：oacsan [@OAuthConsumerSecret]
xref：oaitan [@OAuthInvalidateAccessTokenOn] xref：oapan [@OAuthPostAuthorization]
xref：oapran [@OAuthProtected] xref：oasan [@OAuthScope]

| *Parameters*  | xref：conkan [@ConnectionKey] xref：defan [@Default] xref：eman [@Email] xref：e [@ExceptionPayload]
xref：mtskan [@MetaDataStaticKey] xref：optan [@可选] xref：refan [@RefOnly]

{@ 1}} *REST*  | xref：binpan [@BinaryParam] xref：rstcan [@RestCall] xref：rstean [@RestExceptionOn] xref：rstpan [@RestHeaderParam]
xref：rshcan [@RestHttpClient] xref：rsppan [@RestPostParam] xref：rsqpan [@RestQueryParam] xref：rstoan [@RestTimeout]
外部参照：rsupan [@RestUriParam]
|===

[[binpan]]
==  @ BinaryParam

类别：REST +
Mule版本：3.5和更新

指定有效负载是否是二进制类型。

另请参见：xref：rstcan [@RestCall] xref：rstean [@RestExceptionOn] xref：rstpan [@RestHeaderParam] xref：rshcan [@RestHttpClient]
外部参照：rsppan [@RestPostParam]外部参照：rsqpan [@RestQueryParam]外部参照：rstoan [@RestTimeout]外部参照：rsupan [@RestUriParam]

[[catan]]
==  @类别

类别：通用+
Mule版本：3.5和更新

Anypoint Studio和doclet使用@Category注释来组织消息处理器。您可以在类定义级别（连接器或模块）使用@Category注释来选择您希望您的扩展名列入的类别：

[source, code, linenums]
----
@Connector(name = "ldap", schemaVersion = "3.6", 
  friendlyName="LDAP", minMuleVersion="3.6",
  description="The LDAP connector connects to an  
    LDAP server and performs LDAP operations")
@Category(name = "org.mule.tooling.category.core",  
  description = "Components")
  public class LDAPConnector
    {
      ...
    }
----

笔记：

* 您只能将连接器添加到其中一个现有的Studio类别中（这意味着您无法定义自己的类别）
*  @Category的名称和描述属性的值只能包含以下值：
** 端点：`org.mule.tooling.category.endpoints`
** 范围：`org.mule.tooling.category.scopes`
** 组件：`org.mule.tooling.category.core`
** 变形金刚：`org.mule.tooling.category.transformers`
** 过滤器：`org.mule.tooling.category.filters`
** 流量控制：`org.mule.tooling.category.flowControl`
** 错误处理：`org.mule.tooling.ui.modules.core.exceptions`
** 云连接器（默认）：`org.mule.tooling.category.cloudconnector`
** 其他：`org.mule.tooling.ui.modules.core.miscellaneous`
** 安全性：`org.mule.tooling.category.security`

您可以使用以下来指定允许的类别：

[source, code, linenums]
----
import org.mule.api.annotations.Category;
@Category(name = "org.mule.tooling.category.endpoints", description = "Endpoints")
@Category(name = "org.mule.tooling.category.scopes", description = "Scopes")
@Category(name = "org.mule.tooling.category.core", description = "Components")
@Category(name = "org.mule.tooling.category.transformers", description = "Transformers")
@Category(name = "org.mule.tooling.category.filters", description = "Filters")
@Category(name = "org.mule.tooling.category.flowControl", description = "Flow Control")
@Category(name = "org.mule.tooling.ui.modules.core.exceptions", description = "Error Handling")
@Category(name = "org.mule.tooling.category.cloudconnector", description = "Cloud Connectors")
@Category(name = "org.mule.tooling.ui.modules.core.miscellaneous", description = "Miscellaneous")
@Category(name = "org.mule.tooling.category.security", description = "Security")
----

另请参阅：xref：confan [@Configurable] xref：connan [@Connector] xref：expran [@Expr] xref：费恩[@ExpressionEnricher] xref：exevan [@ExpressionEvaluator] xref：exlan [@ExpressionLanguage] xref：filan [过滤] xref：iconan [@Icons] xref：ignan [@Ignore] xref：mimean [@Mime] xref：modulean [@Module] xref：pagean [@Paged] xref：procan [@Processor] xref：srcan [@Source ]外部参照：tranan [@Transformer]外部参照：trsan [@TransformerResolver]

[[confan]]
==  @配置

类别：通用+
Mule版本：3.5和更新

*Mule 3.7 Note*：@Configurable不再支持用于@Connector。此更改不赞成在xref：connan [@Connector]或xref：modulean [@Module]中定义的@Configurable字段，并鼓励您将这些字段移至@Config。

将@Connector中的字段标记为可配置的。 @Configurable注释指示生成器通过XML语法或连接器配置对话框为每个连接器实例创建一个可配置的属性。除了@Configurable注释之外，您还需要至少一个公共get和set函数。

[source, code, linenums]
----
@Configurable
 private String url;
  
 public String getUrl() {
      return url;
 }
  
 public void setUrl(String url) {
      this.url = url;
 }
----

另见：xref：catan [@Category] ​​xref：connan [@Connector] xref：expran [@Expr] xref：费昂[@ExpressionEnricher] xref：exevan [@ExpressionEvaluator] +
  xref：exlan [@ExpressionLanguage] xref：filan [@Filter] xref：iconan [@Icons] xref：ignan [@Ignore] xref：mimean [@Mime] xref：modulean [@Module] xref：pagean [@Paged] xref：procan [@Processor] +
  xref：srcan [@Source] xref：tranan [@Transformer] xref：trsan [@TransformerResolver]

[[configan]]
==  @配置

类别：连接管理+
Mule版本：3.6和更新

表示没有连接管理策略的类;也就是说，没有合并配置文件或重新连接的能力。为没有任何连接管理的全局元素提供通用策略。

使用此注释时，连接器或模块可以在不需要身份验证和/或连接管理时使用xref：confan [@Configurable]在全局元素级别配置不同的参数。

[source, code, linenums]
----
@Configuration
public class GenericStrategy{
 
    @Configurable
    private String myConfigurable
    ...
}
----

笔记：

*  @Configuration策略没有用于共享配置文件或重新连接的任何连接管理选项卡，并且默认情况下不创建连接组。
* 默认情况下，所有配置都会进入`General`组。
* 定义您自己的组和/或使用连接性测试。

另请参阅：xref：confan [@Configurable] xref：cnctan [@Connect] xref：coidan [@ConnectionIdentifier] xref：connmgmtan [@ConnectionManagement] xref：connstratan [@ConnectionStrategy] xref：discan [@Disconnect] xref：invan [ InvalidateConnectionOn]外部参照：recan [@ReconnectOn]外部参照：VALCAN [@ValidateConnection]

[[cnctan]]
==  @连接

类别：连接管理+
Mule版本：3.5和更新

将@Connector作用域内的方法标记为负责创建连接。

此方法可以有多个参数，并且可以包含注释，例如@ConnectionKey或@Password。 @Connect注释保证在调用任何消息处理器之前调用该方法。

此方法指定`@Connector`类中的哪个方法负责创建到目标的连接。当连接器启动时，或者与API的连接已经丢失并且必须重新建立，Mule会自动调用`@Connect`方法。当此方法结束时，如果认证成功，则连接器实例已准备好向API发出请求。

用`@Connect`注释的方法必须：

* 为`public`
* 抛出`org.mule.api.ConnectionException`（并且没有其他例外）
* 有一个`void`返回类型
* 如果使用用户名和密码身份验证的自动连接管理，则只需注释一个方法`@Connect`;否则编译失败
* 参数不能是基本类型，例如int，bool，short等。

例1：

[source, code, linenums]
----
@Connect
public void connect(@ConnectionKey String username, String password) throws   ConnectionException { ... }
----

例2：

[source, code, linenums]
----
@Connect
public void connect(@ConnectionKey String username, String password)
throws ConnectionException
{
   ConnectorConfig config = new ConnectorConfig();
   config.setUsername(username);
   config.setPassword(password);
   try
   {
      connection = com.mycompany.ws.Connector.newConnection(config);
   }
   catch (com.mycompany.ws.ConnectionException e)
   {
      throw new org.mule.api.ConnectionException(ConnectionExceptionCode.UNKNOWN, null, e.getMessage(), e);
   }
}
----

此方法所需的参数是认证所需的凭证，在这种情况下是用户名和密码。由于此方法使用`@Connect`进行了注释，Anypoint DevKit使这些参数在该连接器的配置元素中都可用（与`@Configurable`字段一样），以及在消息处理器被拖入时流量。指定的凭据会覆盖配置元素中设置的凭据。

另请参阅： link:/anypoint-connector-devkit/v/3.7/connection-management[连接管理] xref：cnctan [@Connect] xref：coidan [@ConnectionIdentifier] xref：discan [@Disconnect] xref：invan [@InvalidateConnectionOn]
外部参照：recan [@ReconnectOn]外部参照：VALCAN [@ValidateConnection]

[[coidan]]
==  @ ConnectionIdentifier

类别：连接管理+
Mule版本：3.5和更新

在xref：connan [@Connector]中标记一个方法，负责识别连接。

用`@ConnectionIdentifier`注释的方法必须：

* 为`public`
* 不是`static`
* 不接受参数
*  {返回{1}}

使用连接管理进行基本身份验证的`@Connector`类必须只有一个注释为`@ConnectionIdentifier`的方法;否则编译失败。

出于调试目的，连接器的连接管理器调用用@ConnectionIdentifier注解的方法。

此注释必须用于不带参数的非静态方法，并且必须返回包含连接标识符表示的字符串。

以下示例代码返回连接SessionId作为标识符（如果可用）。在这种情况下，SessionHeader对象包含有关当前连接到API的头信息，包括会话ID。

[source, code, linenums]
----
@ConnectionIdentifier
   public String connectionId() {
    if (connection != null){
     return connection.getSessionHeader().getSessionId();
    } else {
     return null;
    }
   }
----

另请参阅： link:/anypoint-connector-devkit/v/3.7/connection-management[连接管理] xref：cnctan [@Connect] xref：discan [@Disconnect] xref：invan [@InvalidateConnectionOn] +
xref：recan [@ReconnectOn] xref：valcan [@ValidateConnection]

[[conkan]]
==  @ ConnectionKey

类别：参数+
Mule版本：3.5和更新

将连接方法内的参数标记为连接器查找的关键字的一部分。这只能用作xref：cnctan [@Connect]方法的一部分。

[source, code, linenums]
----
@Connect(strategy=ConnectStrategy.SINGLE_INSTANCE)
public void connect(@ConnectionKey String username, @Password String password)
throws ConnectionException { ... }
----

另请参阅：xref：defan [@Default] xref：eman [@Email] xref：开发[@ExceptionPayload] xref：mtskan [@MetaDataStaticKey] xref：optan [@Optional] xref：refan [@RefOnly]

[[connmgmtan]]
==  @ ConnectionManagement

类别：连接管理+
Mule版本：3.6和更新

表示为基本用户名和密码身份验证定义连接策略的类。

例子

[source, code, linenums]
----
@ConnectionManagement(friendlyName = "Connection Management type Strategy", 
     configElementName="config-type")
public class ConnectionManagementStrategy implements StrategyCommonInterface {
     
    MyDummyService service;
     
    public ConnectionManagementStrategy(){
        service = new MyDummyService();
    }
     
    @TestConnectivity
    @Connect
    public void connect(@ConnectionKey String username, @Password String password)
        throws ConnectionException {
        Boolean result = service.connectService(username, password);
        if(result == false){
            throw new ConnectionException(null, "Invalid Username or password",
              "Please review Username or Password values");
        }
    }
----

以下示例适用于具有连接管理和连接测试的连接器。

[source, code, linenums]
----
@ConnectionManagement
public class BasicAuthConnectionStrategy{
  @Connect
  @TestConnectivity //(active=true) default
  //Connection management methods
}
----

以下示例适用于具有连接管理和无连接测试的连接器：

[source, code, linenums]
----
@ConnectionManagement
public class BasicAuthConnectionStrategy{
  @Connect
  @TestConnectivity //(active=true) default
  //Connection management methods
}
----

表示连接器策略类。有关更多示例，请参见xref：connstrat [@ConnectionStrategy]。

另请参阅：xref：configan [@Configuration] xref：confan [@Configurable] xref：cnctan [@Connect] xref：coidan [@ConnectionIdentifier]
外部参照：connstratan [@ConnectionStrategy]外部参照：discan [@Disconnect]外部参照：invan [@InvalidateConnectionOn]外部参照：recan [@ReconnectOn]
xref：testconnan [@TestConnectivity] xref：valcan [@ValidateConnection]

[[connstratan]]
==  @ ConnectionStrategy

类别：身份验证+
Mule版本：3.6和更新

表示连接的连接策略类。该类由新的@ConnectionManagement批注，新的@Configuration批注，新的@HTTPBasicAuth批注或现有的@ OAuth2批注定义。在以前的Mule版本中，只能通过继承来添加连接策略，这使得编码更加困难，并在新的DevKit功能出现时导致扩展性问题。新的连接策略功能可以解决这些问题。

=====  xref：oa2an示例[@ OAuth2]

[source, code, linenums]
----
@Connector
public class MyConnector {
 
    @ConnectionStrategy
    private OAuth2Strategy connection;
 
    @Processor
    public void doSomething(){
        connection.getClient().doSomething();
    }
}
----

[source, code, linenums]
----
@OAuth2(friendlyName="oauth2", configElementName="oauth2", ...)
public class OAuth2Strategy implements BaseConnectionStrategy {
 
    @Override
    public Client getClient(){
        return this.client;
    }
 
    /**
     * Your application's client identifier (consumer key in Remote Access Detail).
     */
    @OAuthConsumerKey
    private String consumerKey;
 
    /**
     * Your application's client secret (consumer secret in Remote Access Detail).
     */
    @OAuthConsumerSecret
    private String consumerSecret;
 
    @OAuthAccessToken
    private String accessToken;
 
    @OAuthPostAuthorization
    public void postAuthorize() {...}
 
    ...
} 
----

使用@ConnectionManagement的===== 示例

[source, code, linenums]
----
@Connector
public class MyConnector {
 
    @ConnectionStrategy
    private ConnectionManagementStrategy connection;
 
    @Processor
    public void doSomething(){
        connection.getClient().doSomething();
    }
}
----

[source, code, linenums]
----
@ConnectionManagement(friendlyName="ConnectionManagement", configElementName="connection-management")
public class ConnectionManagementStrategy implements BaseConnectionStrategy {
 
    @Override
    public Client getClient(){
        return this.client;
    }
 
    @Connect
    public void connect(...){
        this.client = new Client(...);
    }
 
    @Disconnect
    public void disconnect() {...}
 
    @ValidateConnection
    public boolean isConnected() {...}
 
    @ConnectorIdentifier
    public String getIdentifier() {...}
 
} 
----

*Multiple Connection Strategies*

上面的每个连接策略扩展了BaseConnectionStrategy接口。

[source, code, linenums]
----
public interface BaseConnectionStrategy{
    private Client client;
   
    Client getClient();
}
----

@ConnectorStrategy字段类型是通用接口。

[source, code, linenums]
----
@Connector
public class MyConnector {
 
   
    @ConnectionStrategy
    private BaseConnectionStrategy connection;
 
    @Processor
    public void doSomething(){
        connection.getClient().doSomething();
    }
    ...
}
----

现在，您可以在设计时选择要使用的连接器类型。

image:Screen+Shot+2014-12-30+at+1.06.11+PM.png[屏幕+镜头+情节中字+在+ 11年6月1日下午+] +

link:https://github.com/mulesoft-labs/multiple-strategies-example-connector[这里]是github中多策略连接器的示例。

*Compatibility*

@Processor调用不能覆盖@Connect参数。

对于这种情况，DevKit中的@ConnectionManagement组件允许您使用@O​​verrideAtProcessors注释@ConnetionStrategy，将@Connect参数添加为@Processor块的可选参数。这样，您可以直接从@Processor调用覆盖属性。

@OverrideAtProcessor批注在Mule 3.6和更新版本中被弃用，并且仅为了向后兼容而存在。

*Execution Time: Connector Pooling*

最简单的方法是维护当前的DevKit连接器的体系结构，并为每个配置继续使用连接器池。使用下面的例子：

[source, xml, linenums]
----
<my-connector:connection-management name="connection-management" username="mule" password="mulemanishere"/>
<my-connector:oauth name="oauth2" consumerkey="..." consumerSecret="..." />
 
<flow>
  <my-connector:do-something config-ref="basic"/>
</flow>
----

在两个元素的后面：basic-auth和：oauth是MyConnector类的两个不同的池，分别配置为分别注入BasicStrategy和OAuthStrategy实例。这可以通过在MyConnector <Strategy>上使用泛型来完成。下面介绍了此替代方案的执行流程图。

.  Spring bean注入从：basic-auth元素到MyConnectorPool <BasicStrategy> bean对象。
.  Spring Bean注入：do-something到DoSomethingMessageProcessor（引用MyConnectorPool）。
. 稍后进行DoSomethingMessageProcessor.doProcess（）调用。 MyConnector实例取自包含已连接的ConnectionManagement连接的MyConnectorPool <ConnectionManagement>。如果没有，则创建一个新的。

另请参阅：xref：connan [@Connector] xref：confan [@Configurable] xref：cnctan [@Connect] xref：coidan [@ConnectionIdentifier] xref：connmgmtan [@ConnectionManagement] xref：discan [@Disconnect] xref： InvalidateConnectionOn]外部参照：recan [@ReconnectOn]外部参照：VALCAN [@ValidateConnection]

[[connan]]
==  @连接器

类别：通用+
Mule版本：3.5和更新

定义一个将其功能作为Mule连接器导出的类。当您首次在Studio中创建Anypoint Connector Project时，Maven会为您生成一个支架@Connector类。创建一个连接器假定你增强了这个类来使你的代码访问一个目标资源。

此类级别注释将Java类标识为云连接器。

@连接器限制：

* 不适用于接口
* 不适用于最终课程
* 仅适用于公共课程
* 不能有类型化的参数（没有泛型）
* 具有`@Connector`的类必须只包含一个用`@Connect`注释的方法
* 具有`@Connector`的类必须只包含一个用`@Disconnect`注释的方法

[source, code, linenums]
----
@Connector(name = "hello", schemaVersion = "1.0", friendlyName = "Hello", minMuleVersion = "3.6")
public class HelloConnector {
  ...
}
----

@连接器参数：

[%header,cols="4*"]
|===
一个|
*Annotation Type Element*

 为|
*Description*

 为|
*Required?*

 为|
*Default Value*

| *`name`*  |连接器的名称。此值必须是简单的字符串，不得有空格。  |✓ | 
| *`schemaVersion`*  |由DevKit生成的模式版本。 |   | `1.0-SNAPSHOT`
| *`friendlyName`*  |这是连接器的人类可读名称。它可以包含空格。 Mule仅将它用于标记Studio调色板中的连接器。 |✓ | 
| *`description`*  |描述连接器及其操作的较长字符串。 Mule Studio将描述显示为工具提示。 |   | 
| *`namespace`*  |连接器的名称空间。 |   | `+http://www.mulesoft.org/schema/mule/name+`
| *`schemaLocation`*  |写入`spring.schemas`文件的模式文件的位置。 |   | `+http://www.mulesoft.org/schema/mule/name/schemaVersion/mule-name.xsd+` +
 +
和+
 +
  `+http://www.mulesoft.org/schema/mule/name/current/mule-name.xsd+`
| *`minMuleVersion`*  |连接器可以使用的最小Mule版本。 Mule会在运行时检查版本，如果版本不兼容会引发错误。 |   |最新的稳定版Mule运行时版本
|===

另见：xref：catan [@Category] ​​xref：confan [@Configurable] xref：expran [@Expr] xref：费桑[@ExpressionEnricher] xref：exevan [@ExpressionEvaluator]
 外部参照：EXLAN [@ExpressionLanguage]外部参照：菲兰[@Filter]外部参照：iconan [@Icons]外部参照：ignan [@Ignore]外部参照：mimean [@Mime]外部参照：modulean [@Module]外部参照：pagean [@Paged]外部参照：procan [@Processor]
  外部参照：srcan [@Source]外部参照：tranan [@Transformer]外部参照：trsan [@TransformerResolver]

[[defan]]
==  @默认

类别：参数+
Mule版本：3.5和更新

指定@Configurable字段或@Processor或@Source参数的默认值。

[source, code, linenums]
----
@Configurable
@Default("mule")
private String type;
----

要么：

[source, code, linenums]
----
@Processor
public abstract String listAnimals(@Default("mule") String type) throws IOException;
----

另请参阅：xref：conkan [@ConnectionKey] xref：eman [@Email] xref：excpan [@ExceptionPayload] xref：mtskan [@MetaDataStaticKey]
外部参照：optan [@optional]外部参照：REFAN [@RefOnly]

[[discan]]
==  @断开

类别：连接管理+
Mule版本：3.5和更新

在负责处理连接的@Connector类中标记一个方法。连接器关闭或连接终止时，由连接器的连接管理器调用。

用`@Disconnect`注释的方法必须：

* 为`public`
* 不要输入参数
* 有一个`void`返回类型

如果使用连接管理（用户名和密码）进行认证，则`@Connector`类必须只有一个带注释的`@Disconnect`方法;否则编译失败。

在3.6及更新版本中，@Disconnect方法仅支持RuntimeException，其他任何异常都会导致连接器编译失败：

[source, code, linenums]
----
@Connector(...)
public myConnector(){
    ...
    @Disconnect
    public void disconnect() throws RuntimeException{
        ...
    }
    ...
}
----

此方法作为维护连接池的一部分进行调用。该池配置了最大空闲时间值。

当连接位于池中而不超过配置的时间时，则调用使用@Disconnect注释的方法，然后调用@Connect方法。另外，当在方法上使用@InvalidateConnectionOn注释来捕获异常时，同样会调用@Disconnect方法并进行后续的重新连接。

[source, code, linenums]
----
@Disconnect
public void disconnect() { 
   if (connection != null)
   {
      try
         {
         connection.logout();
         }
      catch (ConnectionException e)
         {
         e.printStackTrace();
         }
      finally
         {
         connection = null;
         }
   }
}
----

另见： link:/anypoint-connector-devkit/v/3.7/connection-management[连接管理] xref：cnctan [@Connect] xref：coidan [@ConnectionIdentifier] xref：invan [@InvalidateConnectionOn]
xref：recan [@ReconnectOn] xref：valcan [@ValidateConnection]

[[dispan]]
==  @处置

类别：LifeCycle +
Mule版本：3.5和更新

在方法的`org.mule.lifecycle.Disposable`阶段标记要处理的方法。

[source, code, linenums]
----
@Dispose
public void mydispose()  {
    if ( this.sessionId != null ) {
        serviceProvider.dispose(sessionId);
    }
}
----

*Note:* `dispose`是一个保留字，不能用作方法的名称。

另请参阅：xref：initan [@Initialise] xref：stan [@Start] xref：stopan [@Stop]

[[eman]]
==  @电子邮件

类别：参数+
Mule版本：3.5和更新

指定默认的电子邮件模式。

另请参阅：xref：conkan [@ConnectionKey] xref：defan [@Default] xref：excpan [@ExceptionPayload] xref：mtskan [@MetaDataStaticKey] xref：optan [@Optional] xref：refan [@RefOnly]

[[excpan]]
==  @ ExceptionPayload

类别：参数+
Mule版本：3.5和更新

指定异常的有效负载。

[source, code, linenums]
----
@Processor
public Object returnExceptionPayload(@ExceptionPayload Object payload) {
    return payload;
}
----

另请参阅：xref：conkan [@ConnectionKey] xref：defan [@Default] xref：eman [@Email] xref：mtskan [@MetaDataStaticKey] xref：optan [@Optional] xref：refan [@RefOnly]

[[expran]]
==  @ Expr的

类别：通用+
Mule版本：3.5和更新

将xref：procan [@Processor]方法中的参数绑定到表达式。

将参数绑定到表达式与xref：payan [@Payload]类似，因为模块的用户将无法更改XML中参数的表达式或值。绑定是硬编码的，用户不能更改它。

以下示例将`myFlowVarXXX`参数映射到表达式`flowVars['xxx']`的结果：

[source, code, linenums]
----
@Processor       
public String myProcessor(@Expr("flowVars['xxx']") 
   String myFlowVarXXX) {
     ...
   }
----

另请参阅：xref：catan [@Category] ​​xref：confan [@Configurable] xref：connan [@Connector] xref：费恩[@ExpressionEnricher] xref：exevan [@ExpressionEvaluator]
xref：exlan [@ExpressionLanguage] xref：filan [@Filter] xref：iconan [@Icons] xref：ignan [@Ignore] xref：mimean [@Mime] xref：modulean [@Module] xref：pagean [@Paged] xref ：procan [@Processor] xref：srcan [@Source] xref：tranan [@Transformer] xref：trsan [@TransformerResolver]

[[expenan]]
==  @ ExpressionEnricher

类别：通用+
Mule版本：3.5和更新

在xref：exlan [@ExpressionLanguage]中标记一个方法，负责根据表达式丰富mule消息。

以下示例显示如何使用@ExpressionEnricher注释使用“map-payload”表达式语言在enrich（）方法中设置有效负载（预期为映射）：

[source, code, linenums]
----
@ExpressionLanguage(name = "map-payload")
public class MapPayloadExpressionLanguage {
    @ExpressionEnricher
    public void enrich() {
        ...
    }
}
----

另请参阅：xref：catan [@Category] ​​xref：confan [@Configurable] xref：connan [@Connector] xref：expran [@Expr] xref：exevan [@ExpressionEvaluator]
xref：exlan [@ExpressionLanguage] xref：filan [@Filter] xref：iconan [@Icons] xref：ignan [@Ignore] xref：mimean [@Mime] xref：modulean [@Module] xref：pagean [@Paged]
xref：procan [@Processor] xref：srcan [@Source] xref：tranan [@Transformer] xref：trsan [@TransformerResolver]

[[exevan]]
==  @的ExpressionEvaluator

类别：通用+
Mule版本：3.5和更新

将xref：exlan [@ExpressionLanguage]注释中的方法标记为负责评估表达式。

[source, code, linenums]
----
@ExpressionLanguage(name = "expr")
public class ExprExpressionLanguage {
    @ExpressionEvaluator
    public Object evaluate() {
        ...
    }
}
----

另见：xref：catan [@Category] ​​xref：confan [@Configurable] xref：connan [@Connector] xref：expran [@Expr] xref：费恩[@ExpressionEnricher]
xref：exlan [@ExpressionLanguage] xref：filan [@Filter] xref：iconan [@Icons] xref：ignan [@Ignore] xref：mimean [@Mime] xref：modulean [@Module] xref：pagean [@Paged]
xref：procan [@Processor] xref：srcan [@Source] xref：tranan [@Transformer] xref：trsan [@TransformerResolver]

[[exlan]]
==  @表达式语言

类别：通用+
Mule版本：3.5和更新

定义一个将其功能导出为Mule表达式语言的类。

对哪些类型有效的@ExpressionLanguage限制：

* 不能成为界面
* 必须公开
* 不能有类型化的参数（没有泛型）

[source, code, linenums]
----
@ExpressionLanguage(name = "expr")
public class ExprExpressionLanguage {
    @ExpressionEvaluator
    public Object evaluate() {
        ...
    }
}
----

另见：xref：catan [@Category] ​​xref：confan [@Configurable] xref：connan [@Connector] xref：expran [@Expr] xref：费恩[@ExpressionEnricher]
xref：exevan [@ExpressionEvaluator] xref：filan [@Filter] xref：iconan [@Icons] xref：ignan [@Ignore] xref：mimean [@Mime] xref：modulean [@Module] xref：pagean [@Paged]
xref：procan [@Processor] xref：srcan [@Source] xref：tranan [@Transformer] xref：trsan [@TransformerResolver]

[[filan]]
==  @过滤

类别：通用+
Mule版本：3.5和更新

将@Connector内部的方法标记为可从过滤消息的Mule流中调用。此方法中的每个参数都被用作Mule XML调用的属性。

通过将此注释添加到@Connector中的方法中，将创建一个过滤器，该过滤器可以从Mule流中用于基于此方法的实现过滤消息。

[source, code, linenums]
----
@Filter
    public boolean shouldFilter() throws Exception {
        ...
   }
----

另见：xref：catan [@Category] ​​xref：confan [@Configurable] xref：connan [@Connector] xref：expran [@Expr] xref：费恩[@ExpressionEnricher]
xref：exevan [@ExpressionEvaluator] xref：exlan [@ExpressionLanguage] xref：iconan [@Icons] xref：ignan [@Ignore] xref：mimean [@Mime] xref：modulean [@Module] xref：pagean [@Paged] xref ：procan [@Processor] xref：srcan [@Source] xref：tranan [@Transformer] xref：trsan [@TransformerResolver]

[[fnan]]
==  @的FriendlyName

类别：显示+
Mule版本：3.5和更新

为注释元素提供简短的名称。如果未指定值，则从注释元素的名称中推断出该名称。

使用此批注实例变量和方法参数来提供一种方法来覆盖xref：confan [@Configurable]变量或xref：procan [@Processor]，xref：srcan [@Source]，xref：tranan的默认推断昵称[@Transformer]方法参数。提供一个参数，如果用这个注释。

例：

[source, code, linenums]
----
@FriendlyName("Consumer Key")
private String consumerKey;
// Alternate: Declare in a method's arguments:
  public abstract String getByTypeAndName(
  @RestQueryParam("name") @FriendlyName("name") String uname)
      throws IOException;
----

另一个示例说明友好名称如何显示在Anypoint Studio连接器列表中：

[source, code, linenums]
----
@Connector(name="barn", schemaVersion="1.0", friendlyName="Barn", minMuleVersion="3.6")
public class BarnConnector
{  
    ...
}
----

示例Barn连接器显示在Anypoint Studio的连接器列表中，如下所示：

image:friendlyName-screenshot.png[的friendlyName-截图]

另请参阅：xref：passan [@Password] xref：pathan [@Path] xref：plcan [@Placement] xref：suman [@Summary] xref：textan [@Text]

[[handlean]]
==  @拉手

类别：例外管理+
Mule版本：3.6和更新

指示处理和描述异常的方法。每个@Handler类有一个@Handle类。

使用xref：handleran [@Handler]：

[source, code, linenums]
----
@Handler
public class GenericHandler
{
   @Inject                    //optional
   FooConnector fooConnector; //optional
 
   @Handle
   public void customHandler (Exception e) throws Exception
   {
      // Analyze the stack within "e"...
      throw new MyDescriptiveException(e);
   }  
    
   public void setFooConnector(Foo foo)
   {
      this.fooConnector=foo;
   }
}
----

@Handle方法可以返回两个结果：

*  RECONNECT  - 如果@Processor具有xref：recan [@ReconnectOn]，则重试该操作，并且@Handle引发该类型的异常。
* 失败 - 抛出一个不属于xref：recan [@ReconnectOn]的异常，或者处理器不支持重新连接。

*Note*：如果使用@Handle注解的方法在执行过程中不会引发异常，则会重新引发原始异常。

另请参阅：xref：onexceptionan [@OnException] xref：handleran [@Handler]

[[handleran]]
==  @处理程序

类别：例外管理+
Mule版本：3.6和更新

指示处理异常的类。与xref一起使用：onexceptionan [@OnException]和xref：handlean [@Handle]。

[source, code, linenums]
----
@OnException (handler=GenericHandler.class)
@Connector (name = "foo", friendlyName = "Foo")
{
   @Processor
   public void someOp (...)
   {
      ...
   }   
   @OnException (handler=CustomHandler.class)
   @Processor
   public void anotherOp ()
   {
      ...
   }
}
----

@Handler类的约束条件是：

* 必须公开
* 必须使用@Handler进行注释
* 必须有一个空的构造函数
* 可能有一个具有相同类型连接器的@Inject参数
* 必须有一个用@Handle注解的方法
** 带有@Handle的带注释的方法必须接收一个Exception作为参数
** 带注释的方法必须返回void
** 带注释的方法必须用`throws Exception`声明

另请参阅：xref：onexceptionan [@OnException] xref：handlean [@Handle]

[[httpbasicauthan]]
==  @ HTTPBasicAuth

类别：身份验证+
Mule版本：3.6和更新

表示 link:http://tools.ietf.org/html/rfc2617[RFC-2617] "HTTP Authentication: Basic and Digest Access Authentication"的实现。

[source, code, linenums]
----
@HTTPBasicAuth(headerName = "Authorization", prefix="Basic ", friendlyName="Http Basic Auth")
public class HTTPBasicAuthStrategy implements BaseConnectionStrategy {
   ...
     
   @Configurable
   @BasicAuthUsername
   private String username;
     
   @Configurable
   @BasicAuthPassword
   private String password;
}
----

用法：

* 用户名和密码合并为一个字符串"username:password"。
* 然后使用Base64的 link:http://tools.ietf.org/html/rfc2045[RFC-2045] MIME变体对结果字符串进行编码。
* 头部参数名称的默认值："Authorization"，以及前缀参数的默认值："Basic "
* 头部参数和前缀参数的值可以由用户修改。
* 支持空密码，例如：Stripe。
*  @ BasicAuthUsername仅在@HTTPBasicAuth下有效。
*  @ BasicAuthPassword仅在@BasicAuthUsername存在时有效，反之亦然。
* 这仅适用于@RestCall连接器。

示例API：+
Stripe：https://stripe.com/docs/api/curl#authentication +
Twilio：http://www.twilio.com/docs/security +
JIRA：https://developer.atlassian.com/display/JIRADEV/JIRA+REST+API+Example+-+Basic+Authentication

JIRAs API需要一个内容为"Basic "的授权标头，后面跟着编码字符串。例如，字符串"fred:fred"在base64中编码为"ZnJlZDpmcmVk"，因此按如下方式进行请求。

[source, code, linenums]
----
curl -D- -X GET -H "Authorization: Basic ZnJlZDpmcmVk" -H "Content-Type: application/json" "http://<url>"
----

另请参阅：xref：rstcan [@RestCall] xref：oa2an [@ OAuth2] xref：oatan [@OAuthAccessToken] xref：oatian [@OAuthAccessTokenIdentifier]

外部参照：oatsan [@OAuthAccessTokenSecret]外部参照：oaupan [@OAuthAuthorizationParameter]
外部参照：oacban [@OAuthCallbackParameter]外部参照：oackan [@OAuthConsumerKey]外部参照：oacsan [@OAuthConsumerSecret]
外部参照：oaitan [@OAuthInvalidateAccessTokenOn]外部参照：oapan [@OAuthPostAuthorization]
外部参照：oapran [@OAuthProtected]外部参照：oasan [@OAuthScope]外部参照：httpbasicauthan [@HTTPBasicAuth]

[[iconan]]
==  @图标

类别：通用+
Mule版本：3.5和更新

自定义调色板和流编辑器图标。

在连接器类上使用此注释来覆盖一个或多个所需图标的默认位置。路径需要相对于`/src/main/java`目录。

[source, code, linenums]
----
@Icons(connectorLarge="barn-icon-large.png", connectorSmall="barn-icon-small.png")
@Connector(name="barn", schemaVersion="1.0", friendlyName="Barn", minMuleVersion="3.6")
public class BarnConnector
{
   ...
}
----

另见：xref：catan [@Category] ​​xref：confan [@Configurable] xref：connan [@Connector] xref：expran [@Expr] xref：费恩[@ExpressionEnricher]
xref：exevan [@ExpressionEvaluator] xref：exlan [@ExpressionLanguage] xref：filan [@Filter] xref：ignan [@Ignore] xref：mimean [@Mime] xref：modulean [@Module]
外部参照：pagean [@Paged]外部参照：procan [@Processor]外部参照：srcan [@Source]外部参照：tranan [@Transformer]外部参照：trsan [@TransformerResolver]

[[ignan]]
==  @忽略

类别：通用+
Mule版本：3.5和更新

忽略复杂对象内的字段。

[source, code, linenums]
----
public class MyComplexType
{
    private String color;
       
    @Ignore
    private String description;
}
   
@Processor
public void receiveAComplexType(MyComplexType myComplexType) {
    ... 
}
----

另见：xref：catan [@Category] ​​xref：confan [@Configurable] xref：connan [@Connector] xref：expran [@Expr] xref：费恩[@ExpressionEnricher]
xref：exevan [@ExpressionEvaluator] xref：exlan [@ExpressionLanguage] xref：filan [@Filter] xref：iconan [@Icons] xref：mimean [@Mime] xref：modulean [@Module]
xref：pagean [@Paged] xref：procan [@Processor] xref：srcan [@Source] xref：tranan [@Transformer] xref：trsan [@TransformerResolver]

[[inhean]]
==  @ InboundHeaders

类别：参数传递+
Mule版本：3.5和更新

传入入站标题。

[source, code, linenums]
----
@Processor
public String getInboundHeaders(@InboundHeaders("myHeader") String myHeader) { ... }
----

另见：xref：ivhean [@InvocationHeaders] xref：outhan [@OutboundHeaders] xref：payan [@Payload] xref：sessa [@SessionHeaders]

[[initan]]
==  @初始化

类别：LifeCycle +
Mule版本：3.5和更新

在方法的`org.mule.lifecycle.Initialisable`阶段标记要初始化的方法。

[source, code, linenums]
----
@Initialise
public void initialize() {
    if ( this.sessionId != null ) {
        serviceProvider.initialise(sessionId);
    }
}
----

*Note:* `iniitalise`是一个保留字，不能用作方法的名称。

另请参阅：xref：displ [@Dispose] xref：stan [@Start] xref：stopan [@Stop]

[[invan]]
==  @ InvalidateConnectionOn

类别：连接管理+
Mule版本：3.5和更新

用于捕获异常的方法 - 不推荐使用xref：recan [@ReconnectOn]。

[source, code, linenums]
----
@Processor
@InvalidateConnectionOn(exception=AnimalException.class)
public Animal getAnimal (String id ) {
    ... 
}
----

另请参阅： link:/anypoint-connector-devkit/v/3.7/connection-management[连接管理] xref：cnctan [@Connect] xref：coidan [@ConnectionIdentifier] xref：discan [@Disconnect]
外部参照：recan [@ReconnectOn]外部参照：VALCAN [@ValidateConnection]
  
[[ivhean]]
==  @ InvocationHeaders

类别：参数传递+
Mule版本：3.5和更新

传递调用标头。这可以是一个单独的标题，一个逗号分隔的标题名称列表，一个星号'*'表示所有标题，或一个逗号分隔的通配表达式列表。默认情况下，如果一个指定的头文件不存在，则抛出异常。但是，如果标头名称是用'？'定义的后期修复，它被标记为可选。

[source, code, linenums]
----
@Processor
public String getInvocationHeaders(@InvocationHeaders("myHeader")
String myHeader) { 
    ... 
}
----

另请参阅：xref：inhean [@InboundHeaders] xref：outhan [@OutboundHeaders] xref：payan [@Payload] xref：sessa [@SessionHeaders]

[[literalan]]
==  @字面

类别：参数+
Mule版本：3.6和更新

将 link:/mule-user-guide/v/3.7/mule-expression-language-mel[骡子表达语言（MEL）]指定为方法参数，而不需要DevKit解析表达式。您可以对此注释使用任何MEL代码。

*Problem*

鉴于以下处理器方法：

[source]
----
public void enrich(Object source, String targetExpression)
----

鉴于以下Mule XML：

[source, xml]
----
<mymodule:enrich targetExpression="#[variable:myexpr]" ... /> 
----

*enrich*方法接收评估以下表达式的结果：

[source]
----
#[variable:myexpr]
----

而不是这个字符串：

[source]
----
[variable:myexpr]
----

这是因为DevKit的生成代码会尝试自动解析表达式。

*Solution*

@Literal注解标记一个方法参数，以便它来自Mule XML的值如果是Mule表达式则不会被解析：

[source]
----
public void enrich(Object source, @Literal String targetExpression) 
----

在这种情况下，表达式评估不适用于targetExpression参数的值。

而且，这个注解可以用于字符串列表，其中每个元素都是在不评估表达式的情况下传递的。例如：

[source, xml]
----
public void enrich(Object source, @Literal List<String> targetExpressions) 
----

另请参阅：xref：inhean [@InboundHeaders] xref：ivhean [@InvocationHeaders] xref：outhan [@OutboundHeaders] xref：payan [@Payload] xref：sessa [@SessionHeaders]

[[metan]]
==  @ MetaDataCategory

类别：DataSense +
Mule版本：3.5和更新

描述一个分组DataSense具体类，它返回任何这些类型的类型和描述。

Mule 3.6和更新版本支持@Module和@Connector注释中的@MetaDataCategory。

用于注释一个类，该类将使用DataSense提供有关连接器的元数据的方法分组。

[source, code, linenums]
----
@MetaDataCategory
public class MyCategory {
    ...
}
----

另见：xref：mtkpan [@MetaDataKeyParam] xref：mtkran [@MetaDataKeyRetriever]
xref：mtoran [@MetaDataOutputRetriever] xref：mtran [@MetaDataRetriever] xref：mtsan [@MetaDataScope]
xref：noman [@NoMetaData] xref：quan [@Query] xref：qupan [@QueryPart] xref：qutan [@QueryTranslator]

[[mtkpan]]
==  @ MetaDataKeyParam

类别：DataSense +
Mule版本：3.5和更新

将@Processor内部的参数标记为元数据查找的关键字。

[source, code, linenums]
----
public Object create(@MetaDataKeyParam String entityType, @Default("#[payload]") Object entityData) {
    ...
}
----

另见：xref：metan [@MetaDataCategory] ​​xref：mtkran [@MetaDataKeyRetriever]
xref：mtoran [@MetaDataOutputRetriever] xref：mtran [@MetaDataRetriever] xref：mtsan [@MetaDataScope]
xref：noman [@NoMetaData] xref：quan [@Query] xref：qupan [@QueryPart] xref：qutan [@QueryTranslator]

[[mtkran]]
==  @ MetaDataKeyRetriever

类别：DataSense +
Mule版本：3.5和更新

用于注释负责返回服务的实体名称的方法。

鉴于此注释的功能，此Java方法的返回类型必须是`List<MetaDataKey>`。

从此方法返回的实体来自使用@MetaDataRetriever获得的详细描述之后的查询。

在@Connector上下文中或在xref：metan [@MetaDataCategory]中使用此批注。

[source, code, linenums]
----
@MetaDataKeyRetriever
   public List<MetaDataKey> getMetaDataKeys() throws Exception {
       ...
   }
----

另请参见：xref：metan [@MetaDataCategory] ​​xref：mtkpan [@MetaDataKeyParam]
  xref：mtoran [@MetaDataOutputRetriever] xref：mtran [@MetaDataRetriever] xref：mtsan [@MetaDataScope]
  xref：noman [@NoMetaData] xref：quan [@Query] xref：qupan [@QueryPart] xref：qutan [@QueryTranslator]

[[mtoran]]
==  @ MetaDataOutputRetriever

类别：DataSense +
  Mule版本：3.5和更新

对于给定的@MetaDataKey，将方法标记为输出场景@MetaData的描述器。

[source, code, linenums]
----
@MetaDataOutputRetriever
public MetaData getMetaDataOutputRestImplCategory(MetaDataKey key) throws Exception {
    checkProperConnectorInjection();
    return new DefaultMetaData(resolveOutputMetaDataModel(key));
    ...
}
----

另见：xref：metan [@MetaDataCategory] ​​xref：mtkpan [@MetaDataKeyParam] xref：mtkran [@MetaDataKeyRetriever]
  xref：mtran [@MetaDataRetriever] xref：mtsan [@MetaDataScope] xref：noman [@NoMetaData] xref：quan [@Query] xref：qupan [@QueryPart] xref：qutan [@QueryTranslator]

[[mtran]]
==  @ MetaDataRetriever

类别：DataSense +
  Mule版本：3.5和更新

用@MetaDataRetriever注解的方法描述接收到的元数据关键参数的元数据。

使用由@MetadataKeyRetriever检索的元数据键列表来检索每个实体类型的实体组成。

[source, code, linenums]
----
@MetaDataRetriever
public MetaData getMetadata(MetaDataKey key) {
    ...  
}
----

另见：xref：metan [@MetaDataCategory] ​​xref：mtkpan [@MetaDataKeyParam] xref：mtkran [@MetaDataKeyRetriever]
  xref：mtoran [@MetaDataOutputRetriever] xref：mtsan [@MetaDataScope] xref：noman [@NoMetaData] xref：quan [@Query] xref：qupan [@QueryPart] xref：qutan [@QueryTranslator]

[[mtsan]]
==  @ MetaDataScope

类别：DataSense +
  Mule版本：3.5和更新

[source, code, linenums]
----
@MetaDataScope(DefaultCategory.class)
@Connector(name = "my-connector", minMuleVersion = "3.6")
public class MyConnector {
    ...
} 
----

另见：xref：metan [@MetaDataCategory] ​​xref：mtkpan [@MetaDataKeyParam] xref：mtkran [@MetaDataKeyRetriever]
xref：mtoran [@MetaDataOutputRetriever] xref：mtran [@MetaDataRetriever]
xref：noman [@NoMetaData] xref：quan [@Query] xref：qupan [@QueryPart] xref：qutan [@QueryTranslator]

[[mtskan]]
==  @ MetaDataStaticKey

类别：参数+
Mule版本：3.5和更新

定义注释值的特定元数据类型。当应用于xref：procan [@Processor]时，它会影响（默认情况下）输出，否则会影响字段参数。

[source, code, linenums]
----
@Processor
@MetaDataStaticKey(type = "CLIENT")
public Map<String, Object> getClient(String id) {
    return createClientObject();
} 
----

另请参阅：xref：conkan [@ConnectionKey] xref：defan [@Default] xref：eman [@Email] xref：excpan [@ExceptionPayload] xref：optan [@Optional] xref：refan [@RefOnly]

[[mimean]]
==  @默

类别：通用+
Mule版本：3.5和更新

生成适当的消息头。

[source, code, linenums]
----
@Processor
@Mime("application/json")
public String search(String keyword) { 
    ... 
}
----

另见：xref：catan [@Category] ​​xref：confan [@Configurable] xref：connan [@Connector] xref：expran [@Expr] xref：费恩[@ExpressionEnricher]
{@ 0}} xref：exevan [@ExpressionEvaluator] xref：exlan [@ExpressionLanguage] xref：filan [@Filter] xref：iconan [@Icons] xref：ignan [@Ignore]
{@ 0}} xref：modulean [@Module] xref：pagean [@Paged] xref：procan [@Processor] xref：srcan [@Source] xref：tranan [@Transformer] xref：trsan [@TransformerResolver]

[[modulean]]
==  @模块

类别：通用+
Mule版本：3.5和更新

定义一个将其功能导出为Mule模块的类。

类级注释@Module指示需要由DevKit注释处理工具处理Java类并将其视为Mule模块。

@Module不能应用于：

* 接口
* 最终课程
* 参数化类
* 非公开课程

[source, code, linenums]
----
@Module(name="animal-search", schemaVersion="3.6.1")
public class AnimalSearchModule { 
    ... 
}
----

另见：xref：catan [@Category] ​​xref：confan [@Configurable] xref：connan [@Connector] xref：expran [@Expr] xref：费恩[@ExpressionEnricher]
{@ 0}} xref：exevan [@ExpressionEvaluator] xref：exlan [@ExpressionLanguage] xref：filan [@Filter] xref：iconan [@Icons] xref：ignan [@Ignore] xref：mimean [@Mime]
  xref：pagean [@Paged] xref：procan [@Processor] xref：srcan [@Source] xref：tranan [@Transformer] xref：trsan [@TransformerResolver]

[[noman]]
==  @ NoMetaData

类别：DataSense +
  Mule版本：3.5和更新

标记xref：procan [@Processor]以避免使用@MetaDataRetriever和@MetaDataKeyRetriever机制发现元数据。

另见：xref：metan [@MetaDataCategory] ​​xref：mtkpan [@MetaDataKeyParam] xref：mtkran [@MetaDataKeyRetriever]
  xref：mtoran [@MetaDataOutputRetriever] xref：mtran [@MetaDataRetriever] xref：mtsan [@MetaDataScope]
  xref：quan [@Query] xref：qupan [@QueryPart] xref：qutan [@QueryTranslator]

[[oa1an]]
==  @的OAuth

类别：OAuth +
Mule版本：3.5和更新

注释使用OAuth 1.0a协议进行认证的连接器。

[source, xml, linenums]
----
@Connector(name = "myconnector", friendlyName = "MyConnector")
@OAuth(requestTokenUrl = "https://example.com/uas/oauth/requestToken",
accessTokenUrl = "https://example.com/uas/oauth/accessToken",
authorizationUrl = "https://example.com/uas/oauth/authorize")
public class MyConnector { 
    ... 
}
----

另见：xref：oa2an [@ OAuth2] xref：oatan [@OAuthAccessToken] xref：oatian [@OAuthAccessTokenIdentifier]
  xref：oatsan [@OAuthAccessTokenSecret] xref：oaupan [@OAuthAuthorizationParameter]
  xref：oacban [@OAuthCallbackParameter] xref：oackan [@OAuthConsumerKey] xref：oacsan [@OAuthConsumerSecret]
  xref：oaitan [@OAuthInvalidateAccessTokenOn] xref：oapan [@OAuthPostAuthorization]
  xref：oapran [@OAuthProtected] xref：oasan [@OAuthScope]

[[oa2an]]
==  @的OAuth2

类别：OAuth +
Mule版本：3.5和更新

注释使用OAuth 2协议进行认证的连接器。

[source, code, linenums]
----
@Connector(name = "oauth2connector")
@OAuth2(authorizationUrl = "http://someUrl", accessTokenUrl = "http://someOtherUrl")
public class MyConnector { 
    ... 
}
----

另见：xref：oa1an [@OAuth] xref：oatan [@OAuthAccessToken] xref：oatian [@OAuthAccessTokenIdentifier]
  xref：oatsan [@OAuthAccessTokenSecret] xref：oaupan [@OAuthAuthorizationParameter]
  xref：oacban [@OAuthCallbackParameter] xref：oackan [@OAuthConsumerKey] xref：oacsan [@OAuthConsumerSecret]
  xref：oaitan [@OAuthInvalidateAccessTokenOn] xref：oapan [@OAuthPostAuthorization]
  xref：oapran [@OAuthProtected] xref：oasan [@OAuthScope]

[[oatan]]
==  @ OAuthAccessToken

类别：OAuth +
Mule版本：3.3和更新

持有访问令牌。当调用xref：procan [@Processor]方法时，会设置一个OAuth访问令牌，以防资源所有者已授权使用者;否则不会调用该方法，并且根据所使用的类级别注释将资源所有者重定向到OAuth或OAuth2授权URL。

*Note*：此注释仅支持类字段。

用xref：oa1an [@OAuth]或xref：oa2an [@ OAuth2]注解的类只需要有一个用@OAuthAccessToken注解的字段。

该字段必须是String类型。

[source, code, linenums]
----
@OAuthAccessToken private String accessToken;
----

另见：xref：oa1an [@OAuth] xref：oa2an [@ OAuth2] xref：oatian [@OAuthAccessTokenIdentifier]
  xref：oatsan [@OAuthAccessTokenSecret] xref：oaupan [@OAuthAuthorizationParameter]
  xref：oacban [@OAuthCallbackParameter] xref：oackan [@OAuthConsumerKey] xref：oacsan [@OAuthConsumerSecret]
  xref：oaitan [@OAuthInvalidateAccessTokenOn] xref：oapan [@OAuthPostAuthorization]
  xref：oapran [@OAuthProtected] xref：oasan [@OAuthScope]

[[oatian]]
==  @ OAuthAccessTokenIdentifier

类别：OAuth +
Mule版本：3.5和更新

将方法标记为负责识别访问令牌的用户。该方法由连接器的访问令牌管理器调用。该标识被用作存储访问令牌的关键。

[source, code, linenums]
----
@OAuthAccessTokenIdentifier
public String getUserId() {
    return api.getUserId(myAccessToken);
}
----

另见：xref：oa1an [@OAuth] xref：oa2an [@ OAuth2] xref：oatan [@OAuthAccessToken] xref：oatsan [@OAuthAccessTokenSecret]
xref：oaupan [@OAuthAuthorizationParameter] xref：oacban [@OAuthCallbackParameter] xref：oackan [@OAuthConsumerKey]
xref：oacsan [@OAuthConsumerSecret] xref：oaitan [@OAuthInvalidateAccessTokenOn] xref：oapan [@OAuthPostAuthorization] xref：oapran [@OAuthProtected] xref：oasan [@OAuthScope]

[[oatsan]]
==  @ OAuthAccessTokenSecret

类别：OAuth +
Mule版本：3.5和更新

持有访问令牌的秘密。

[source, code, linenums]
----
@OAuthAccessTokenSecret private String accessTokenSecret;
----

另见：xref：oa1an [@OAuth] xref：oa2an [@ OAuth2] xref：oatan [@OAuthAccessToken] xref：oatian [@OAuthAccessTokenIdentifier]
xref：oaupan [@OAuthAuthorizationParameter] xref：oacban [@OAuthCallbackParameter] xref：oackan [@OAuthConsumerKey]
xref：oacsan [@OAuthConsumerSecret] xref：oaitan [@OAuthInvalidateAccessTokenOn] xref：oapan [@OAuthPostAuthorization]
xref：oapran [@OAuthProtected] xref：oasan [@OAuthScope]

[[oaupan]]
==  @ OAuthAuthorizationParameter

类别：OAuth +
Mule版本：3.5和更新

附加授权参数以授权URL。

[source, code, linenums]
----
@OAuthAuthorizationParameter(name = "xxx", type = xxx, description = "xxx")
----

另请参阅：xref：oa1an [@OAuth] xref：oa2an [@ OAuth2] xref：oatan [@OAuthAccessToken] xref：oatian [@OAuthAccessTokenIdentifier] xref：oatsan [@OAuthAccessTokenSecret] xref：oacban [@OAuthCallbackParameter] xref：oackan [ OAuthConsumerKey]
xref：oacsan [@OAuthConsumerSecret] xref：oaitan [@OAuthInvalidateAccessTokenOn] xref：oapan [@OAuthPostAuthorization]
xref：oapran [@OAuthProtected] xref：oasan [@OAuthScope]

[[oacban]]
==  @ OAuthCallbackParameter

类别：OAuth +
  Mule版本：3.5和更新

标识表示服务OAuth响应中每个参数的模块属性。

[source, code, linenums]
----
@OAuthCallbackParameter(expression = "#[json:instance_url]")
private String instanceId;
----

另见：xref：oa1an [@OAuth] xref：oa2an [@ OAuth2] xref：oatan [@OAuthAccessToken] xref：oatian [@OAuthAccessTokenIdentifier]
xref：oatsan [@OAuthAccessTokenSecret] xref：oaupan [@OAuthAuthorizationParameter]
xref：oackan [@OAuthConsumerKey] xref：oacsan [@OAuthConsumerSecret] xref：oaitan [@OAuthInvalidateAccessTokenOn]
xref：oapan [@OAuthPostAuthorization] xref：oapran [@OAuthProtected] xref：oasan [@OAuthScope]

[[oackan]]
==  @ OAuthConsumerKey

类别：OAuth +
  Mule版本：3.5和更新

持有OAuth使用者密钥。该字段必须包含由服务提供商提供并在OAuth规范中描述的OAuth使用者密钥。

[source, code, linenums]
----
@Configurable @OAuthConsumerKey private String consumerKey;
----

另见：xref：oa1an [@OAuth] xref：oa2an [@ OAuth2] xref：oatan [@OAuthAccessToken] xref：oatian [@OAuthAccessTokenIdentifier]
xref：oatsan [@OAuthAccessTokenSecret] xref：oaupan [@OAuthAuthorizationParameter]
xref：oacban [@OAuthCallbackParameter] xref：oacsan [@OAuthConsumerSecret]
xref：oaitan [@OAuthInvalidateAccessTokenOn] xref：oapan [@OAuthPostAuthorization]
xref：oapran [@OAuthProtected] xref：oasan [@OAuthScope]

[[oacsan]]
==  @ OAuthConsumerSecret

类别：OAuth +
Mule版本：3.5和更新

拥有OAuth消费者机密。该字段必须包含由服务提供商提供并在OAuth规范中描述的OAuth使用者密钥。

[source, code, linenums]
----
@Configurable @OAuthConsumerSecret private String consumerSecret;
----

另见：xref：oa1an [@OAuth] xref：oa2an [@ OAuth2] xref：oatan [@OAuthAccessToken] xref：oatian [@OAuthAccessTokenIdentifier]
xref：oatsan [@OAuthAccessTokenSecret] xref：oaupan [@OAuthAuthorizationParameter]
xref：oacban [@OAuthCallbackParameter] xref：oackan [@OAuthConsumerKey]
xref：oaitan [@OAuthInvalidateAccessTokenOn] xref：oapan [@OAuthPostAuthorization]
xref：oapran [@OAuthProtected] xref：oasan [@OAuthScope]

[[oaitan]]
==  @ OAuthInvalidateAccessTokenOn

类别：OAuth +
  Mule版本：3.5和更新

标记一种自动刷新令牌的方法。

*Note*：此注释已被弃用。改用@ReconnectOn。

[source, code, linenums]
----
@Processor
@OAuthInvalidateAccessTokenOn(exception = RuntimeException.class)
public void processor() { 
    ... 
}
----

另见：xref：oa1an [@OAuth] xref：oa2an [@ OAuth2] xref：oatan [@OAuthAccessToken] xref：oatian [@OAuthAccessTokenIdentifier]
  xref：oatsan [@OAuthAccessTokenSecret] xref：oaupan [@OAuthAuthorizationParameter]
  xref：oacban [@OAuthCallbackParameter] xref：oackan [@OAuthConsumerKey] xref：oacsan [@OAuthConsumerSecret]
  xref：oapan [@OAuthPostAuthorization] xref：oapran [@OAuthProtected] xref：oasan [@OAuthScope] xref：httpbasicauthan [@HTTPBasicAuth]

[[oapan]]
==  @ OAuthPostAuthorization

类别：OAuth +
  Mule版本：3.5和更新

在OAuth内部标记一个方法，作为负责设置连接器_after_ OAuth完成的方法。

[source, code, linenums]
----
@OAuthPostAuthorization
public void postAuthorize() throws ConnectionException, MalformedURLException, AsyncApiException { 
    ... 
}
----

另见：xref：oa1an [@OAuth] xref：oa2an [@ OAuth2] xref：oatan [@OAuthAccessToken] xref：oatian [@OAuthAccessTokenIdentifier]
  xref：oatsan [@OAuthAccessTokenSecret] xref：oaupan [@OAuthAuthorizationParameter]
  xref：oacban [@OAuthCallbackParameter] xref：oackan [@OAuthConsumerKey] xref：oacsan [@OAuthConsumerSecret]
  xref：oaitan [@OAuthInvalidateAccessTokenOn] xref：oapran [@OAuthProtected] xref：oasan [@OAuthScope]

[[oapran]]
==  @ OAuthProtected

类别：OAuth +
  Mule版本：3.5和更新

将连接器内部的方法标记为需要OAuth访问令牌。当连接器未被授权时，这种方法无法执行。因此，迫使OAuth首先发生。

[source, code, linenums]
----
@OAuthProtected
@Processor
public void logInfo() {
   logger.info(String.format("OAuthAccessToken=%s", getAccessToken()));
   logger.info(String.format("OAuthAccessTokenSecret=%s", getAccessTokenSecret()));
} 
----

另见：xref：oa1an [@OAuth] xref：oa2an [@ OAuth2] xref：oatan [@OAuthAccessToken] xref：oatian [@OAuthAccessTokenIdentifier]
  xref：oatsan [@OAuthAccessTokenSecret] xref：oaupan [@OAuthAuthorizationParameter]
  xref：oacban [@OAuthCallbackParameter] xref：oackan [@OAuthConsumerKey] xref：oacsan [@OAuthConsumerSecret]
  xref：oaitan [@OAuthInvalidateAccessTokenOn] xref：oapan [@OAuthPostAuthorization]
 外部参照：oasan [@OAuthScope]

[[oasan]]
==  @ OAuthScope

类别：OAuth +
  Mule版本：3.5和更新

表示对受保护资源的访问权限必须受到限制。用@OAuthScope注释的字段必须存在，并包含一个指示所需范围的字符串。

[source, code, linenums]
----
@Configurable
@OAuthScope
@Optional
@Default("")
private String scope;
----

另见：xref：oa1an [@OAuth] xref：oa2an [@ OAuth2] xref：oatan [@OAuthAccessToken] xref：oatian [@OAuthAccessTokenIdentifier]
  xref：oatsan [@OAuthAccessTokenSecret] xref：oaupan [@OAuthAuthorizationParameter]
  xref：oacban [@OAuthCallbackParameter] xref：oackan [@OAuthConsumerKey] xref：oacsan [@OAuthConsumerSecret]
  xref：oaitan [@OAuthInvalidateAccessTokenOn] xref：oapan [@OAuthPostAuthorization] xref：oapran [@OAuthProtected]
[[onexceptionan]]
==  @ onException的

类别：异常处理+
  Mule版本：3.6及更新版本

在某些情况下，对于意外情况，连接器可以通过以一种或多种方法集中异常处理来改善其用户体验。

当由外部API引发的异常包含导致以下情况的信息时，会出现这些情况：

* 重新连接 - 重试一个操作
* 失败 - 操作失败

在Mule版本3.6之前，当使用@InvalidateConnectionOn或@ReconnectOn引发具体的和预期的异常时，DevKit仅提供了重试当前操作的机制。这需要为每个@Processor添加自定义`try {} catch (){}`代码** **并分析堆栈。

在Mule 3.6及更新版本中，@OnException机制减少了连接器的代码，并且改善了代码的粒度，以便为不同的处理器定义具体的处理程序。 @OnException标识一个处理程序。使用xref：handleran [@Handler]指定一个异常处理类，并使用xref：handlean [@Handle]来标识异常处理方法。

例：

[source, code, linenums]
----
@OnException (handler=GenericHandler.class)
@Connector ( name = "foo", friendlyName = "Foo" )
{
   @Processor
   public void someOp (...)
   {
      ...
   }   
   @OnException (handler=CustomHandler.class)
   @Processor
   public void anotherOp ()
   {
      ...
   }
}
----

另请参见：xref：handlean [@Handle] xref：handleran [@Handler]

[[optan]]
==  @可选

类别：参数+
  Mule版本：3.5和更新

将@Configurable字段或@Processor或@Source参数标记为可选。

[source, code, linenums]
----
@Configurable
@Optional
String path;
----

另请参阅：xref：conkan [@ConnectionKey] xref：defan [@Default] xref：eman [@Email] xref：excpan [@ExceptionPayload]
xref：mtskan [@MetaDataStaticKey] xref：refan [@RefOnly]

[[outhan]]
==  @ OutboundHeaders

类别：参数传递+
  Mule版本：3.5和更新

用于传递出站标题。

[source, code, linenums]
----
@Processor
public void outboundHeaders(@OutboundHeaders
Map<String, Object> outboundHeaders) { 
    ... 
}
----

另请参阅：xref：inhean [@InboundHeaders] xref：ivhean [@InvocationHeaders] xref：payan [@Payload] xref：sessa [@SessionHeaders]

[[pagean]]
==  @分页

类别：通用+
  Mule版本：3.5和更新

将xref：connan [@Connector]中的方法标记为返回分页结果集的操作。使用此接口注释的方法也必须用xref：procan [@Processor]进行注释，并且必须返回@ProviderAwarePagingDelegate的实例。

[source, code, linenums]
----
@Processor
@Paged
public ProviderAwarePagingDelegate paginationTestOperation (String ble, PagingConfiguration pagingConfiguration) throws WrongParameterConfiguredException { 
    ... 
}
----

另见：xref：catan [@Category] ​​xref：confan [@Configurable] xref：connan [@Connector] xref：expran [@Expr] xref：费恩[@ExpressionEnricher]
{@ 0}} xref：exevan [@ExpressionEvaluator] xref：exlan [@ExpressionLanguage] xref：filan [@Filter] xref：iconan [@Icons] xref：ignan [@Ignore] xref：mimean [@Mime]
  xref：modulean [@Module] xref：procan [@Processor] xref：srcan [@Source] xref：tranan [@Transformer] xref：trsan [@TransformerResolver]

[[passan]]
==  @密码

类别：显示+
  Mule版本：3.5和更新

将字段或方法参数标识为密码，或更一般地将其指定为包含无法以纯文本显示的数据的变量。

[source, code, linenums]
----
@Connect
public void connect(@ConnectionKey String username,
  @Password String password)
        throws ConnectionException {
     ...
}
----

以下内容显示密码如何显示在全局元素属性中：

image:password-screenshot.png[密码截图]

另见：xref：fnan [@FriendlyName] xref：pathan [@Path] xref：plcan [@Placement] xref：suman [@Summary] xref：textan [@Text]

[[pathan]]
==  @路径

类别：显示+
  Mule版本：3.5和更新

将字段或方法参数标识为文件的路径。这会在Studio中显示一个窗口，从文件系统中选择一个文件。

[source, code, linenums]
----
@Configurable
@Path
String path;
----

另请参阅：xref：fnan [@FriendlyName] xref：passan [@Password] xref：plcan [@Placement] xref：suman [@Summary] xref：textan [@Text]

[[payan]]
==  @净荷

类别：参数传递+
  Mule版本：3.5和更新

标记参数以接收有效载荷。

[source, code, linenums]
----
@Processor
public String setPayload(@Payload String payload) { 
    ... 
}
----

另请参阅：xref：inhean [@InboundHeaders] xref：ivhean [@InvocationHeaders] xref：outhan [@OutboundHeaders] xref：sessa [@SessionHeaders]

[[plcan]]
==  @放置

类别：显示+
  Mule版本：3.5和更新

定义Anypoint Studio配置中可配置属性的位置。

使用此注释来实例变量和方法参数。它接受以下参数：

*  *order*  - 组内注释元素的相对顺序。如果提供的值是重复的，那么这些元素的顺序是任意定义的。价值是相对的;具有顺序10的元素具有比具有值25的元素更高的优先级。
*  *group*  - 一种显示一个或多个变量的逻辑方法。如果你没有指定一个组，那么Mule会默认一个默认组。要将多个元素放置在同一组中，请为此属性分配相同的值。
*  *tab*  - 将注释元素分组在一起的合理方法。此属性指定要在其中显示注释元素的选项卡的名称。如果没有指定标签，那么Mule将采用默认标签。要在同一选项卡中显示多个参数，请为此属性分配相同的值。

[source, code, linenums]
----
@Configurable
@Placement(group = "Basic Settings", order = 1)
private String consumerKey;
----

以下代码为*Consumer Key*和*Consumer Secret*设置创建*General*> *Basic Settings*：

[source, code, linenums]
----
@Configurable
@Placement(group = "Basic Settings", order = 1)
@FriendlyName("Consumer Key")
private String consumerKey;
   
@Configurable
@Placement(group = "Basic Settings", order = 3)
@FriendlyName("Consumer Secret")
@Summary("consumer secret for authentication")
private String consumerSecret;
----

生成的屏幕是：

image:placement-1-screenshot.png[放置-1-截图]

此代码在“常规信息”部分下创建*Advanced Settings*> *Application Name*设置：

[source, code, linenums]
----
@Configurable
@Placement(tab="Advanced Settings", group = "General Information", order = 2)
@Summary("the application name")
@FriendlyName("Application Name")
private String applicationName;
----

生成的屏幕是：

image:placement-2-screenshot.png[放置-2-截图]

另请参阅：xref：fnan [@FriendlyName] xref：passan [@Password] xref：pathan [@Path] xref：suman [@Summary] xref：textan [@Text]

[[procan]]
==  @处理器

类别：通用+
Mule版本：3.5和更新

将方法标记为连接器中的操作。 @Processor方法生成通用消息处理器。此注释的参数是可选的。 friendlyName让您指定操作的显示名称。

[source, code, linenums]
----
@Processor(friendlyName="OperationName", name="SchemaName")
 public String putInBarn(String animal) {
     return animal + " has been placed in the barn";
 }
----

另见：xref：catan [@Category] ​​xref：confan [@Configurable] xref：connan [@Connector] xref：expran [@Expr] xref：费恩[@ExpressionEnricher]
{@ 0}} xref：exevan [@ExpressionEvaluator] xref：exlan [@ExpressionLanguage] xref：filan [@Filter] xref：iconan [@Icons] xref：ignan [@Ignore] xref：mimean [@Mime]
  xref：modulean [@Module] xref：pagean [@Paged] xref：srcan [@Source] xref：tranan [@Transformer] xref：trsan [@TransformerResolver]

[[quan]]
==  @查询

类别：DataSense +
Mule版本：3.5和更新

通过使用DataSense查询语言（DSQL）支持简单的查询构建。在xref：connan [@Connector]范围内定义@Query。

[source, code, linenums]
----
@Processor
public void setQuery(@Query DsglQuery query) {
    ...
} 
----

另见：xref：metan [@MetaDataCategory] ​​xref：mtkpan [@MetaDataKeyParam] xref：mtkran [@MetaDataKeyRetriever]
  xref：mtoran [@MetaDataOutputRetriever] xref：mtran [@MetaDataRetriever] xref：mtsan [@MetaDataScope]
  xref：noman [@NoMetaData] xref：qupan [@QueryPart] xref：qutan [@QueryTranslator]

[[qupan]]
==  @ QueryPart

类别：DataSense +
  Mule版本：3.5和更新

用于高级@Query场景。

另见：xref：metan [@MetaDataCategory] ​​xref：mtkpan [@MetaDataKeyParam] xref：mtkran [@MetaDataKeyRetriever]
  xref：mtoran [@MetaDataOutputRetriever] xref：mtran [@MetaDataRetriever] xref：mtsan [@MetaDataScope]
  xref：noman [@NoMetaData] xref：quan [@Query] xref：qutan [@QueryTranslator]

[[qutan]]
==  @ QueryTranslator

类别：DataSense +
  Mule版本：3.5和更新

将DSQL查询翻译为本地语言。

[source, code, linenums]
----
@QueryTranslator
public String toNativeQuery(DsqlQuery query){
    SimpleSyntaxVisitor visitor = new SimpleSyntaxVisitor();
    query.accept(visitor);
    return visitor.dsqlQuery();
}
----

另见：xref：metan [@MetaDataCategory] ​​xref：mtkpan [@MetaDataKeyParam] xref：mtkran [@MetaDataKeyRetriever]
  xref：mtoran [@MetaDataOutputRetriever] xref：mtran [@MetaDataRetriever] xref：mtsan [@MetaDataScope]
  xref：noman [@NoMetaData] xref：quan [@Query] xref：qupan [@QueryPart]
[[recan]]
==  @ ReconnectOn

类别：连接管理+
  Mule版本：3.5和更新

此注释用于与连接相关的异常处理。它可以在类级别（使用`@Connector`批注注释）或方法级别（使用`@Processor`批注批注）使用。如果连接器或处理器引发此类的异常，则`@ReconnectOn`会自动使连接失效。 `@ReconnectOn`接收包含要捕获的异常类的列表（请参阅下面的示例）。发生异常时，`@ReconnectOn`的行为基于配置的重新连接策略。

用于使连接无效。您可以将此注释附加到使用@Processor注释的任何方法。如果Processor或Source引发与@ReconnectOn注释中指定的任何异常相匹配的异常，则连接将失效。

[source, code, linenums]
----
@Processor
@ReconnectOn(exceptions = {InvalidSessionFault.class, PasswordChangedException.class})
public void myOperation(@Optional String source,
                        @Optional Object destination) throws InvalidSessionFault, PasswordChangedException, InvalidParameterException
{  
    /**
    * CODE FOR MY OPERATION
    */ 
}
----

另请参阅： link:/anypoint-connector-devkit/v/3.7/connection-management[连接管理] xref：cnctan [@Connect] xref：coidan [@ConnectionIdentifier] xref：discan [@Disconnect]
 外部参照：invan [@InvalidateConnectionOn]外部参照：VALCAN [@ValidateConnection]
  
[[refan]]
==  @ RefOnly

类别：参数+
  Mule版本：3.5和更新

将xref：confan [@Configurable]字段或xref：procan [@Processor]参数标记为仅供引用传递。

另见：xref：conkan [@ConnectionKey] xref：defan [@Default] xref：eman [@Email] xref：excpan [@ExceptionPayload] xref：mtskan [@MetaDataStaticKey]

[[reqentitlean]]
==  @ RequiresEntitlement

检查xref：module [@Module]或xref：procan [@Processor]是否需要具有特定权利的Enterprise许可证。在连接器级别工作。仅限企业。

[source, code, linenums]
----
@RequiresEntitlement(name="peoplesoft")
@Connector
public class SuperConnector(){
 .....
}
----

[[reqentlican]]
==  @ RequiresEnterpriseLicense

检查xref：module [@Module]或xref：procan [@Processor]是否需要Enterprise许可证。许可证可以是评估许可证或不是。在连接器级别工作。仅限企业。

[source, code, linenums]
----
@RequiresEnterpriseLicense
@Connector
public class SuperConnector(){
 .....
}
----

[[rstcan]]
==  @ RestCall

类别：REST +
  Mule版本：3.5和更新

与xref：procan [@Processor]注释一起使用。指示在调用时，处理器发出RESTful请求。

DevKit提供了一组注释来简化使用RESTful API的工作。这些注释处理所有必要的操作，生成每个REST调用，并合并每个REST调用参数。

必需的参数：

*   *uri*：要查询的REST资源的URI
*   *method*：使用的HTTP方法

生成的代码基于传递给@RestCall注释的参数创建URI，并使用由@RestCall的方法参数指定的动词发出请求。

[source, code, linenums]
----
@Processor
@RestCall(uri = "{url}/list", method = org.mule.api.annotations.rest.HttpMethod.GET)
public abstract String showAll() throws IOException;  
----

可选参数：

*  *contentType*：来自此方法调用的响应的内容类型。
+
[source, code, linenums]
----
@Processor
@RestCall(uri = "{url}/list", method = HttpMethod.POST, contentType = "application/json") 
----

*  *exceptions*：抛出异常列表，通过配对异常类型和被评估的表达式进行配置。
+
[source, code, linenums]
----
@Processor
@RestCall(uri = "{url}/list", method = HttpMethod.POST, contentType = "application/json", exceptions = {@RestExceptionOn(expression="#[message.inboundProperties['http.status'] != 200]", exception = AnimalNotFoundException.class)}) 
----
+
在这种情况下，@RestExceptionOn注释用于在指定的条件下抛出异常。在上例中，如果HTTP状态不是200，则会引发异常。

另请参阅：xref：binpan [@BinaryParam] xref：confan [@Configurable] xref：rstean [@RestExceptionOn] xref：rstpan [@RestHeaderParam] xref：rshcan [@RestHttpClient]
  xref：rsppan [@RestPostParam] xref：rsqpan [@RestQueryParam] xref：rstoan [@RestTimeout] xref：rsupan [@RestUriParam]

[[rstean]]
==  @ RestExceptionOn

类别：REST +
  Mule版本：3.5和更新

根据指定的条件抛出异常。

[source, code, linenums]
----
@Processor
@RestCall(uri = "{url}/animals", method = HttpMethod.GET, exceptions = {@RestExceptionOn(expression="#[message.inboundProperties['http.status'] != 200]", exception = AnimalNotFoundException.class)})
public abstract List<Animal> listAnimals(@RestQueryParam("type") String type) throws IOException;  
----

另请参阅：xref：binpan [@BinaryParam] xref：rstcan [@RestCall] xref：rstpan [@RestHeaderParam] xref：rshcan [@RestHttpClient] xref：rsppan [@RestPostParam]
  xref：rsqpan [@RestQueryParam] xref：rstoan [@RestTimeout] xref：rsupan [@RestUriParam]

[[rstpan]]
==  @ RestHeaderParam

类别：REST +
  Mule版本：3.5和更新

允许您在HTTP请求中插入自定义标头。使用此注释时，您必须指定要包含在呼叫中的标题的名称。与@RestURIParam注释一样，您可以将此注释应用于@Processor方法参数或标记为@Configurable的连接器字段。

使用@RestHeaderParam注释特定的可配置变量时，变量存在于所有HTTP请求中。

[source, code, linenums]
----
@Configurable
@RestHeaderParam(value = "emptyHeaderField", ignoreIfEmpty = true)
private String emptyHeaderField; 
----

在方法的特定参数上使用@RestHeaderParam时，只有在调用方法时才会包含标题。

[source, code, linenums]
----
@Processor
@RestCall(uri = "{url}/create", method = org.mule.api.annotations.rest.HttpMethod.POST)
public abstract String create( @RestHeaderParam("age")
int age)
throws IOException; 
----

另请参阅：xref：binpan [@BinaryParam] xref：rstcan [@RestCall] xref：rstean [@RestExceptionOn] xref：rshcan [@RestHttpClient] xref：rsppan [@RestPostParam]
  xref：rsqpan [@RestQueryParam] xref：rstoan [@RestTimeout] xref：rsupan [@RestUriParam]

[[rshcan]]
==  @ RestHttpClient

类别：REST +
  Mule版本：3.5和更新

标记模块使用的HttpClient的注释。这样，您可以避免创建多个客户端，并有机会执行自己的调用或配置HttpClient以满足特殊需求：

[source, code, linenums]
----
@RestHttpClient
HttpClient client = new HttpClient(); 
----

另请参阅：xref：binpan [@BinaryParam] xref：rstcan [@RestCall] xref：rstean [@RestExceptionOn] xref：rstpan [@RestHeaderParam] xref：rsppan [@RestPostParam]
  xref：rsqpan [@RestQueryParam] xref：rstoan [@RestTimeout] xref：rsupan [@RestUriParam]

[[rsppan]]
==  @ RestPostParam

类别：REST +
  Mule版本：3.5和更新

允许您在POST方法调用的主体中设置参数。使用@RestCall定义POST方法并使用@RestPostParam设置其参数。

您可以将此注释应用于@Processor方法参数或标记为@Configurable的连接器字段。 DevKit确保您仅将此注释应用于POST方法。

用@RestPostParam注解的处理器方法不能使用未注释的参数或@Payload注释的参数。

例如：

[source, code, linenums]
----
@Processor
@RestCall(uri = "{url}/form", method = HttpMethod.POST)
public abstract String addAnimal(@RestPostParam("type") String type) throws IOException;  
----

另一种方法是用@RestPostParam注释一个@Configurable变量，如下所示：

[source, code, linenums]
----
@Configurable
@RestPostParam("category")
private String category;
  
@Processor
@RestCall(uri = "http://localhost:8089/product/", method = HttpMethod.POST)
  public abstract Result createProduct(String name) throws IOException;
----

另见：xref：binpan [@BinaryParam] xref：rstcan [@RestCall] xref：rstean [@RestExceptionOn] xref：rstpan [@RestHeaderParam] xref：rshcan [@RestHttpClient] xref：rsqpan [@RestQueryParam] xref：rstoan [ RestTimeout] xref：rsupan [@RestUriParam]

[[rsqpan]]
==  @ RestQueryParam

类别：REST +
  Mule版本：3.5和更新

指定URI查询参数，这些参数被附加到URI的路径后面？或＆符号。您可以将此注释应用于@Processor方法参数或标记为@Configurable的连接器字段。这使您可以将动态生成的参数用作查询参数。

必需参数：要追加的参数的名称的字符串表示形式。

[source, code, linenums]
----
@Processor
@RestCall(uri = "{url}/listName", method = org.mule.api.annotations.rest.HttpMethod.GET)
public abstract String getByType(
@RestQueryParam("type") String type)
throws IOException; 
----

当以`mule`作为参数调用getByType消息处理器时，结果调用将为：`+http://localhost:8089/animals?type=mule+`

另请参阅：xref：binpan [@BinaryParam] xref：rstcan [@RestCall] xref：rstean [@RestExceptionOn] xref：rstpan [@RestHeaderParam] xref：rshcan [@RestHttpClient]
  xref：rsppan [@RestPostParam] xref：rstoan [@RestTimeout] xref：rsupan [@RestUriParam]

[[rstoan]]
==  @ RestTimeout

类别：REST +
  Mule版本：3.5和更新

指定其余呼叫的超时时间。此注释可以附加到@RestCall，以便为其余的调用指定一个以毫秒为单位的超时值。如果其余调用超过指定的时间，则会抛出RuntimeException，除非为超时指定了异常。

[source, code, linenums]
----
@Processor
@RestTimeout(timeout = 1, exception = TimeoutException.class)
@RestCall(uri = "{url}/list/timeout", method = HttpMethod.GET)
public abstract String listAnimalsTimeout() throws IOException;  
----

另请参阅：xref：binpan [@BinaryParam] xref：rstcan [@RestCall] xref：rstean [@RestExceptionOn] xref：rstpan [@RestHeaderParam] xref：rshcan [@RestHttpClient]
  xref：rsppan [@RestPostParam] xref：rsqpan [@RestQueryParam] xref：rsupan [@RestUriParam]

[[rsupan]]
==  @ RestUriParam

类别：REST +
  Mule版本：3.5和更新

允许您通过插入使用@RestUriParam批注注释的参数动态生成URI。

您可以在连接器的`@Processor`方法参数或xref：confan [@Configurable]字段中使用xref：rsupan [@RestUriParam]注释以及其他相关注释。

当生成请求调用时，DevKit包含一个未注释的参数和一个用xref：payan [@Payload]注解的参数作为调用的主体。

将注释应用于@Processor方法时，通过用花括号括住占位符来指定URI中的占位符，例如` {type}. `

您可以将@RestUriParam应用于@Processor方法参数，如下所示：

[source, code, linenums]
----
@Processor
@RestCall(uri = "{url}/create/{type}", method = org.mule.api.annotations.rest.HttpMethod.POST)
public abstract String create(@RestUriParam("type") String type)  throws IOException;  
----

另一种方法是用@RestUriParam注释@Configurable变量，如下所示：

[source, code, linenums]
----
@Configurable
@RestUriParam("url")
@Default("http://localhost:8089")
private String url;
  
@Processor
@RestCall(uri = "{url}/listType", method =    org.mule.api.annotations.rest.HttpMethod.GET)
  public abstract String getByType(@RestQueryParam("type") String type)
   throws IOException;
----

下一个例子取代了路径：

[source, code, linenums]
----
@RestCall(uri = "http://myservice.com/{path}", method = HttpMethod.HEAD)
----

引用路径参数：

[source, code, linenums]
----
...
Public abstract String setPath(@RestURIParam String path ... 
----

另请参阅：xref：binpan [@BinaryParam] xref：rstcan [@RestCall] xref：rstean [@RestExceptionOn] xref：rstpan [@RestHeaderParam]
  xref：rshcan [@RestHttpClient] xref：rsppan [@RestPostParam] xref：rsqpan [@RestQueryParam] xref：rstoan [@RestTimeout]

[[sessan]]
==  @ SessionHeaders

类别：参数传递+
  Mule版本：3.5和更新

标记传入一个或多个收到标题的方法参数。

此注释值可以定义单个标题，标题名称的逗号分隔列表，星号“*' to denote all headers, or a comma-separated list of wildcard expressions such as `MULE_*，X  -  *”。默认情况下，如果当前消息中不存在已命名的标头，则会引发异常。但是，如果标头名称是用'？'定义的后期修复，它被标记为可选。

定义多个标题名称或使用通配符时，此参数可以是Map或List。如果使用Map，则会传递标题名称和值。如果使用List，则仅使用标题值。

如果定义了单个标题名称，则可以将标题类型用作参数类型，但也可以使用List或Map。

Inbound头部集合是不可变的，所以传入的头部Map或List也是不可变的。试图写入映射或列表结果的UnsupportedOperationException。

另见：xref：inhean [@InboundHeaders] xref：ivhean [@InvocationHeaders] xref：outhan [@OutboundHeaders] xref：payan [@Payload]

[[srcan]]
==  @源

类别：通用+
  Mule版本：3.5和更新

将xref：connan [@Connector]中的方法标记为可从Mule流中调用，并且能够生成Mule事件。

此注释将 link:http://mulesoft.github.io/mule-devkit/3.7.2/apidocs/org/mule/api/annotations/Module.html[模]中的方法标记为可从Mule流中调用，并且能够生成Mule事件。每个标记的方法都会生成一个org.mule.api.source.MessageSource。该方法必须接收SourceCallback作为其参数之一。只要它在那里，哪个参数是无关紧要的。

[source, code, linenums]
----
@Source
public void subscribeTopic(String topic, final SourceCallback callback) {
  getBayeuxClient().subscribe(topic, new ClientSessionChannel.MessageListener() {
    @Override
    public void onMessage(ClientSessionChannel channel, Message message) {
      try {
        callback.process(message.getData());
      } catch (Exception e) {
        LOGGER.error(e);
      }
    }
  });
} 
----

调用此方法如下：

[source, xml, linenums]
----
<flow name="myFlow">
  <sfdc:subscribe-topic topic="/someTopic"/>
  <logger level="INFO" message="#[payload]"/>
  ...
</flow>
----

此流程订阅了一个主题，当出现更新时，调用记录器消息处理器。

另见：xref：catan [@Category] ​​xref：confan [@Configurable] xref：connan [@Connector] xref：expran [@Expr] xref：费恩[@ExpressionEnricher]
{@ 0}} xref：exevan [@ExpressionEvaluator] xref：exlan [@ExpressionLanguage] xref：filan [@Filter] xref：iconan [@Icons] xref：ignan [@Ignore] xref：mimean [@Mime]
 外部参照：modulean [@Module]外部参照：pagean [@Paged]外部参照：procan [@Processor]外部参照：tranan [@Transformer]外部参照：trsan [@TransformerResolver]

[[stan]]
==  //开始

类别：LifeCycle +
  Mule版本：3.5和更新

在方法的org.mule.lifecycle.Startable阶段标记一个要启动的方法。

[source, code, linenums]
----
@Start
public void mystart() {
     this.sessionId = serviceProvider.login(username, password);
} 
----

*Note:* `start`是一个保留字，不能用作方法的名称。

另请参阅：xref：displ [@Dispose] xref：initan [@Initialise] xref：stopan [@Stop]

[[stopan]]
==  @停止

类别：LifeCycle +
  Mule版本：3.5和更新

在方法的`org.mule.lifecycle.Stoppable`阶段标记要停止的方法。

[source, code, linenums]
----
@Start
public void mystop() {
    if ( this.sessionId != null ) {
       serviceProvider.logout(sessionId);
    }
} 
----

*Note:* `stop`是一个保留字，不能用作方法的名称。

另见：xref：displ [@Dispose] xref：initan [@Initialise] xref：stan [@Start]

[[suman]]
==  @摘要

类别：显示+
  Mule版本：3.5和更新

将显示信息添加到字段或参数。使用此批注实例变量和方法参数来提供一种方法来覆盖xref：confan [@Configurable]变量或xref：procan [@Processor]，xref：srcan [@Source]，xref：tranan的默认推断描述[@Transformer]方法参数。

[source, code, linenums]
----
@Processor
@Summary("This processor puts an animal in the barn")
public String putInBarn(String animal)
{  
    return animal + "has been placed in the barn";
} 
----

另请参阅：xref：fnan [@FriendlyName] xref：passan [@Password] xref：pathan [@Path] xref：plcan [@Placement] xref：textan [@Text]

[[testconnan]]
==  @ TestConnectivity

类别：连接管理+
Mule版本：3.6和更新

指示用于测试连接连接的类。 @TestConnectivity使连接器更简单，并有助于构建更好的连接策略。 *Note*：对于Mule 3.6，请参阅xref：tc36 [Mule 3.6 Usage]。

===  Mule 3.7更新

实施@ConnectionManagement策略时，有时需要将证书的验证或测试以及整个配置与连接本身分开。例如，如果配置测试为实际连接机制增加了不必要的开销，则是这种情况。

通过这种改进，开发人员可以自由地实现两种不同的方法，一种专门用于测试和验证，另一种专注于实际连接。

现在有两种方法，每种都有一个注释，而不是用@TestConnectivity注释@Connect方法，例如：

[source, code, linenums]
----
@TestConnectivity
public void testConnect(String username, String password, String url, String optionalConnectionParam)
           throws ConnectionException
{
    if (StringUtils.isBlank(username) || StringUtils.isBlank(password)){
        throw new ConnectionException(ConnectionExceptionCode.INCORRECT_CREDENTIALS,
                 "001", "Username or Password is blank");
    }
       
    if ( !StringUtils.isBlank(optionalConnectionParam) && !validParams(optionalConnectionParam)){
        throw new ConnectionException(ConnectionExceptionCode.INCORRECT_CREDENTIALS,
                "002", "Given connection parameters are not valid for this connection");
    }
    UrlValidator urlValidator = new UrlValidator();
    if ( !urlValidator.isValid(url)){
        throw new ConnectionException(ConnectionExceptionCode.UNKNOWN_HOST, "003", "Url is not valid");
    }
    Result result = new ServiceClient(username, password).test(url);
    if ( !result.success()){
        throw new ConnectionException(result.cause(), result.code(), result.message());
    }
}
@Connect
public void connect(@ConnectionKey String username, @Password String password,
                                @Optional @Default("http://www.mulesoft.org") String url,
                                @Optional String optionalConnectionParam)
    throws ConnectionException
{
    ServiceClient client = new ServiceClient(username, password);
    try {
        client.connect(url, optionalConnectionParams);       
    } catch (SerivceConnectionException e) {
        throw new ConnectionException(getExceptionCode(e.getCause()), e.getCode(), e.getMessage(), e);
    }
}
----

*Restrictions*：

* 只有一个方法可以用@TestConnectivity进行注释。
* 使用@TestConnectivity注释的方法必须以相同的顺序具有与@Connect方法完全相同的参数。
* 方法应声明抛出ConnectionException。

===  Mule 3.6用法

以下示例适用于具有连接管理和连接测试的连接器：

[source, code, linenums]
----
@ConnectionManagement
public class BasicAuthConnectionStrategy{
  @Connect
  @TestConnectivity //(active=true) default
  //Connection management methods
}
----

以下示例适用于具有连接管理和无连接测试的连接器：

[source, code, linenums]
----
@ConnectionManagement
public class BasicAuthConnectionStrategy{
  @Connect
  @TestConnectivity(active=false)
  //Connection management methods
}
----

以下示例适用于没有连接管理和连接测试的连接器：

[source, code, linenums]
----
@Configuration
public class BasicConnectionStrategy{
  @TestConnectivity//(active=true) default
  public void myCustomMethodForTestingConnectivity() throws ConnectionException{
    //code that uses @Configurable
    ..
    if ("something went wrong"){
      throw new ConnectionException(
         ConnectionExceptionCode.CANNOT_REACH,
         "what your API has returned, if it did..",
         "some meaninful stuff about your API")
    }
    ...
    //if we manage to get here, it means that the connection was 
    // successful, hence, no need to return a boolean
  }
}
----

@TestConnectivity方法必须：

* 接收零参数。当使用@TestConnectivity注释时，此约束不适用于@Connect方法。
* 抛出`org.mule.api.ConnectionException`。
* 公开而不是静态的。
* 不包含任何状态，只使用@Configurable（或@Connect参数，如果这是注释的方法）。
* 在没有连接管理器的情况下工作在@Connector中（因为测试连接方案在@Connect方法中进行了介绍）。

另请参阅：xref：configan [@Configuration] xref：confan [@Configurable] xref：cnctan [@Connect]

[[textan]]
==  @文本

类别：显示+
  Mule版本：3.5和更新

将参数标识为大型文本输入。此标记为模式生成生成子元素而不是属性，但它也使用文本区域而不是Anypoint Studio对话框生成中的文本字段。

另见：xref：fnan [@FriendlyName] xref：passan [@Password] xref：pathan [@Path] xref：plcan [@Placement] xref：suman [@Summary]

[[tranan]]
==  @变压器

类别：通用+
  Mule版本：3.5和更新

在连接器的上下文中将方法标记为数据类型的Transformer或数据格式。

这个注释标识了一个变成Mule变换器的方法。

[source, code, linenums]
----
@Transformer(sourceTypes = { Object[].class })
public static List transformArrayToList(@Payload Object[] payload) 
----

另见：xref：catan [@Category] ​​xref：confan [@Configurable] xref：connan [@Connector] xref：expran [@Expr] xref：费恩[@ExpressionEnricher]
 外部参照：exevan [@ExpressionEvaluator]外部参照：EXLAN [@ExpressionLanguage]外部参照：菲兰[@Filter]外部参照：iconan [@Icons]外部参照：ignan [@Ignore]
 外部参照：mimean [@Mime]外部参照：modulean [@Module]外部参照：pagean [@Paged]外部参照：procan [@Processor]外部参照：srcan [@Source]外部参照：trsan [@TransformerResolver]

[[trsan]]
==  @ TransformerResolver

类别：通用+
  Mule版本：3.5和更新

查找符合注册表中的标准的变换器。该接口的实现使用传入的一些或全部信息来发现匹配的变压器。

在实现之前注册与注册表的接口的实现可以被获取。通常使用`registry-bootstrap.properties`完成。

[source, code, linenums]
----
@TransformerResolver
public static org.mule.api.transformer.Transformer 
  transformerResolver(DataType source, DataType result,
  MuleContext muleContext) throws Exception {
    if(source.getType().equals(Book.class) &&
      result.getType().equals(String.class)) {
        BookToString bookToString = new BookToString(); 
        muleContext.getRegistry().
          applyProcessorsAndLifecycle(bookToString);
        return bookToString;
   }
      return null;
} 
----

另请参阅：xref：catan [@Category] ​​xref：confan [@Configurable] xref：connan [@Connector] xref：expran [@Expr]外部参考：费恩[@ExpressionEnricher] xref：exevan [@ExpressionEvaluator] xref：exlan [表达式语言]外部参照：菲兰[@Filter]外部参照：iconan [@Icons]外部参照：ignan [@Ignore]外部参照：mimean [@Mime]
 外部参照：modulean [@Module]外部参照：pagean [@Paged]外部参照：procan [@Processor]外部参照：srcan [@Source]外部参照：tranan [@Transformer]

[[userdefan]]
==  @ UserDefinedMetaData

Mule版本：3.7和更新

为Anypoint Studio用户提供MetaData选项卡以启用更改元数据传播信息。

如果使用@UserDefinedMetaData（在使用TransformingValue时不强制）注释xref：procan [@Processor]，则它还应该将自定义属性添加到editors.xml文件。如果需要，该属性可帮助Studio用户在以后的用法中更改给定处理器的元数据。

启用后，Studio的最终用户应该看到每个@Processor用@UserDefinedMetaData注释了UI中的一个选项卡，使用户可以更改MetaData传播的信息（查找*MetaData tab*）。

@UserDefinedMetaData的一个用途是为连接器的目标资源返回的内容定义MIME类型。

例如：

[source, code, linenums]
----
@Processor
@UserDefinedMetaData
public TransformingValue<InputStream, DataType<InputStream>> 
 
//The object represents the Java class of the DataType's type class
getFileFromSystem(String filePathBleh) {
    DataType<InputStream> dataType = DataTypeFactory.create(InputStream.class, MimeTypes.APPLICATION_XML);
    dataType.setEncoding(StandardCharsets.UTF_8.name());
    return new DefaultTranformingValue("CREATE YOUR STREAM HERE", dataType);
}
----

[[valcan]]
==  @ ValidateConnection

类别：连接管理+
  Mule版本：3.5和更新

在每次调用由xref：procan [@Processor]注释公开的操作之前验证连接。

这个方法被Mule调用来检查连接是否实际打开。

用`@ValidateConnection`注释的方法必须：

* 为`public`
* 不要输入参数
*  {返回{1}}或`java.lang.Boolean`

只有`@Connector`类中的一种方法可以用`@ValidateConnection.`进行注释

以下示例确定连接是否处于活动状态。代码只是检查连接参数是否为空。取决于协议，其他连接器可能需要不同的实现。

[source, code, linenums]
----
@ValidateConnection
public boolean isConnected() {
    return connection != null;
} 
----

另请参阅： link:/anypoint-connector-devkit/v/3.7/connection-management[连接管理] xref：cnctan [@Connect] xref：coidan [@ConnectionIdentifier] xref：discan [@Disconnect] xref：invan [@InvalidateConnectionOn] xref：recan [@ReconnectOn]

[[wsdlprovan]]
==  @ WsdlProvider

Mule版本：3.7和更新

默认情况下为SOAP连接器创建。 @WsdlProvider类驻留在**src/main/java**> **org.mule.modules** ._ <connector_name> _。*config*。该类包含@WsdlServiceRetriever和@WsdlServiceEndpoint的注释。检索器注释检索完整的一组WSDL文件。服务端点注释提供了一种解决跨一个或多个WSDL的端点的方法。

[source, code, linenums]
----
package org.mule.modules.demoflow.config;
  
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.components.WsdlProvider;
import org.mule.api.annotations.ws.WsdlServiceEndpoint;
import org.mule.api.annotations.ws.WsdlServiceRetriever;
import org.mule.devkit.api.ws.definition.DefaultServiceDefinition;
import org.mule.devkit.api.ws.definition.ServiceDefinition;
import org.mule.api.annotations.param.Default;
  
@WsdlProvider(friendlyName = "Configuration")
public class ConnectorConfig {
  
    @Configurable
    @Default("MyWsdl")
    private String endpoint;
  
    @WsdlServiceRetriever
    public ServiceDefinition getServiceDefinition() {
           return new DefaultServiceDefinition(
                "MyWsdl");
    }
  
    @WsdlServiceEndpoint
    public String getServiceEndpoint(ServiceDefinition definition) {
         return endpoint;
    }
  
    public String getEndpoint() {
        return endpoint;
    }
    public void setEndpoint(String endpoint) {
        this.endpoint = endpoint;
    }
}
----

[[wsdlservendan]]
==  @ WsdlServiceEndpoint

Mule版本：3.7和更新

默认情况下在SOAP连接器中创建，以跨一个或多个WSDL文件解析端点。

有关示例，请参见xref：wsdlprovan [@WsdlProvider]。

[[wsdlservretan]]
==  @ WsdlServiceRetriever

Mule版本：3.7和更新

默认情况下在SOAP连接器中创建，以从一个或多个WSDL文件中检索WSDL内容。

有关示例，请参见xref：wsdlprovan [@WsdlProvider]。
