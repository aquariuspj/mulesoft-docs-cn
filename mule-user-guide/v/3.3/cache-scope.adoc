= 缓存范围

*_Enterprise Edition_*

==  image:cache_icon.png[cache_icon]概述

通过存储和重复使用经常调用的数据，*Cache Scope*节省时间和处理负载。您可以将任意数量的消息处理器放入缓存作用域，并配置缓存策略以存储由作用域子流生成的响应（其中包含响应消息的有效内容）。 Mule的默认缓存策略定义了如何存储和重用子流响应，但是如果要调整缓存行为，可以在Mule中自定义全局缓存策略，并使其可供应用程序中的所有缓存范围使用。

Mule向缓存作用域子流发送消息，并且父流预期输出。缓存作用域处理消息，将输出传递给父流并保存输出（即缓存响应）。下一次Mule将相同类型的消息发送到其子流时，缓存范围可能会提供缓存响应，而不是再次调用可能耗时的过程。

[NOTE]
您可以将缓存范围中的端点交换模式配置为*request-response*或*one-way*。无论交换模式设置或其中可能发生的任何数据检索活动如何，缓存作用域都会简单地缓存其中的流的输出;当消息接下来进入子流时，缓存范围将提供缓存输出或*cached response*。

您可以使用缓存范围来减少Mule实例的处理负载，并加速流中的消息处理。它特别有效：

* 处理对相同信息的重复请求
* 处理涉及大量非消耗性消息有效载荷的信息请求

例如，您可以使用缓存范围来管理客户的航班信息请求。许多客户可能会要求有关从旧金山到布宜诺斯艾利斯的航班的相同价格信息。您可以使用缓存范围来减少发送请求到数据库的时间 - 比如说每十分钟一次 - 并向用户显示数据，而不是使用大量处理能力向各个航空公司数据库发送单独请求高速缓存的航班定价信息。在数据的及时性不重要的情况下，缓存范围可以节省时间和处理能力。

== 缓存策略

*caching strategy*定义缓存作用域在消息进入其子流时所采取的操作。

* 如果存在_is no_ cached响应事件（缓存“未命中”），则缓存范围将处理该消息。
* 如果存在缓存的响应事件（缓存“命中”），则缓存范围将提供缓存的响应事件，而不是处理该消息。

您可以在Mule中为应用程序中的缓存范围自定义全局缓存策略，也可以使用Mule的默认缓存策略。

=== 默认缓存策略

默认情况下，Mule应用程序中的所有缓存作用域都遵循下面描述的缓存策略过程。如果您想创建自己的自定义全局缓存策略，请参阅下面的<<Creating a Global Caching Strategy>>部分。

. 消息进入缓存范围子流。
. 高速缓存范围确定消息的有效负载是否可用。一个*consumable payload*在丢失之前只能被读取一次 - 比如流式载荷 - 并且不能被缓存。
* 如果消息有效负载是可用的，缓存范围总是处理消息;没有任何东西被缓存，并且缓存策略被放弃。
* 如果消息payload_is不是可用的，则缓存范围将继续执行缓存策略的下一步。
. 缓存范围生成一个密钥来标识消息的有效负载。 Mule使用MD5KeyGenerator和MD5摘要为消息有效载荷生成唯一密钥。
. 高速缓存范围将新生成的密钥与之前处理并保存在InMemoryObjectStore中的高速缓存响应进行比较 - 高速缓存数据的容器。换句话说，缓存范围搜索它可以提供的“缓存命中”而不是处理该消息。
* 存在_cache miss_的地方，缓存作用域会处理新消息并产生响应。高速缓存作用域还将结果响应保存在对象存储中。 （如果响应具有消耗性有效载荷，则不缓存响应。）
* 在存在_cache hit_的情况下，缓存策略使用DefaultResponseGenerator生成一个响应，该响应组合来自新请求和缓存响应的数据。 （如果生成的响应具有可消耗的有效负载，则不会缓存响应。）
. 缓存范围将响应推送到父流中以供继续处理。

== 添加和配置缓存范围

. 将缓存范围图标从调色板拖放到画布上的流中。
+
image:cache_drag.png[cache_drag]

. 双击属性图标以打开“范围属性”面板。
+
image:cache_properties.png[cache_properties]

. 在*General*标签上输入范围的*Display Name*。
. 选择单选按钮以使用Mule的默认缓存策略或引用您自己的自定义全局缓存策略。
+
[%header,cols="20,75"]
|===
|缓存策略 |说明
|使用默认缓存策略 |缓存范围遵循Mule的<<Default Caching Strategy>>。
|引用策略 |缓存范围遵循您创建的全局缓存策略之一;从下拉组合框中选择一个缓存策略。
|===
+
[NOTE]
如果您尚未创建任何全局缓存策略，则*Reference a strategy*下拉组合框将为空。点击组合框旁边的*+*按钮以<<Creating a Global Caching Strategy>>为您的缓存范围引用。

. 选择一个过滤器，从缓存范围中排除特定的邮件。
+
[%header,cols="10,43a,43"]
|===
|过滤器 |描述 |示例条目
|处理所有消息 |缓存作用域为所有进入子流的消息执行缓存策略。 | n / a
|使用表达式 |过滤消息高速缓存范围仅针对与此字段中定义的表达式匹配的消息执行高速缓存策略。

* 消息匹配expression（s）= Mule执行缓存策略。

* 消息与表达式（s）不匹配= Mule通过缓存范围内的所有消息处理器处理消息; Mule从不保存也不提供缓存的响应。 | Mule的统一表达式语言中的任何表达。例如，如果您希望域的高级客户端能够使用缓存的响应，则可以输入表达式`#[user.isPremium()]`。
|使用全局过滤器过滤消息 |高速缓存范围对成功通过指定全局过滤器的消息执行高速缓存策略。

* 消息通过filter = Mule执行缓存策略。
* 消息无法通过filter = Mule通过缓存范围内的所有消息处理器处理消息; Mule从不保存也不提供缓存的响应。 |消息属性，不是通配符
|===

. 如果需要，单击文档选项卡可添加有关范围的注释，然后单击确定保存更改。
. 将构建块从调色板拖入缓存范围，以构建Mule将应用缓存策略的子流。缓存作用域可以包含任意数量的消息处理器。

== 创建全局缓存策略

创建全局缓存策略来自定义缓存作用域执行的一些活动。

例如，处理具有大量有效负载的消息的缓存作用域（这反过来会导致InMemoryObjectStore中的大量缓存响应）可能会迅速耗尽内存存储并降低流的处理性能。在这种情况下，您可能希望创建一个全局缓存策略，将缓存的响应存储在不同类型的对象存储中，并防止内存耗尽。

. 点击画布下方的*Global Elements*标签。
. 点击*Create*，然后在出现的选择全局类型面板中，点击*Caching Strategy*，然后点击*OK*。
+
image:global_element.png[global_element]

. 在出现的全局元素属性面板的*General*选项卡中，输入缓存策略的*Name*。
+
image:global_cache.png[global_cache]
+
[NOTE]
或者，您可以从缓存作用域的<<Adding and Configuring a Cache Scope>>创建全局缓存策略（即访问缓存策略“全局元素属性”面板）。点击*Reference a strategy*下拉组合框旁边的*+*按钮。
+
[TIP]
唯一必须定义的全局缓存策略配置是*Name*;所有其他可配置元素都是可选的。

. 点击*Object Store*字段旁边的*+*按钮来配置一个对象库，其中Mule将存储所有作用域的缓存响应。有关配置细节，请参阅下面的<<Configuring an Object Store for Cache>>部分。
+
[NOTE]
如果您愿意，您可以将*Object Store*字段留空;默认情况下，Mule将所有缓存的响应存储在InMemoryObjectStore中。

. 选择一个事件密钥来定义缓存策略如何为每个消息的有效负载生成密钥。
+
[%header,cols="10,45,43"]
|===
|事件密钥 |描述 |何时使用
|默认 |使用MD5KeyGenerator和MD5摘要生成密钥 |当您的对象为表示相同值的实例返回相同的MD5哈希码时使用，例如String类。
|关键表达式 |使用此字段中定义的表达式来生成关键字;以Mule的统一表达式语言输入任何表达式 |当请求类不会为表示相同值的对象返回相同的MD5哈希码时使用。
|密钥生成器 |标识生成密钥的自定义生成的Spring bean  |当请求类不会为表示相同值的对象返回相同的MD5哈希码时使用。如果您尚未创建任何自定义密钥生成器，则*Response Generator*下拉组合框将为空。单击组合框旁边的*+*按钮为您的缓存策略创建一个新的Spring bean以供引用。
|===

. 点击高级标签。
. 从下拉组合框中选择*Response Generator*，以指示缓存策略使用定制的Spring bean来生成响应，该响应组合新数据请求和缓存响应的数据。
+
[NOTE]
如果您尚未创建任何自定义响应生成器，则*Response Generator*下拉组合框将为空。单击组合框旁边的*+*按钮为您的缓存策略创建一个新的Spring bean以供引用。

. 从下拉组合框中选择*Consumable Message Filter*，以指示缓存策略使用定制的Spring bean来检测消息是否包含可消耗的有效负载。
+
[NOTE]
如果您尚未创建任何自定义消耗品消息过滤器，则*Consumable Message Filter*下拉组合框将为空。单击组合框旁边的*+*按钮为您的缓存策略创建一个新的Spring bean以供引用。

. 选择您希望缓存策略使用的事件复制策略。
+
[%header,cols="20,75"]
|===
|事件复制策略 |行为
|简单的事件复制策略（数据是不可变的） |数据是不可变的，就像一个String，或者Mule流没有突变数据。 Mule缓存的有效载荷与流所返回的相同。每个生成的响应将包含相同的有效负载。
|可序列化的事件复制策略（数据是可变的） |数据是可变的，或者Mule流程已经突变了数据。该骡缓存有效载荷不相同，由流动，这已系列化/反序列化以创建该对象的一个​​新的副本返回。每个生成的响应将包含一个新的有效载荷
|===

. 如果需要，单击文档选项卡添加关于全局缓存策略的注释，然后单击确定保存更改。

== 为高速缓存配置对象存储

默认情况下，Mule将所有缓存的响应存储在InMemoryObjectStore中。如果您想自定义Mule存储缓存响应的方式，请创建一个全局缓存策略并定义一个新的 http://www.psdn.progress.com/realtime/techsupport/documentation/objectstore/r60/ostore/doc/user1/1_cncpts.htm[对象存储]。

. 在全局元素属性面板的*General*选项卡中，点击*Object Store*字段旁边的*+*按钮。
. 在出现的面板中，选择您想要创建的对象存储的类型。
+
image:select_object_store.png[select_object_store]
+
[%header,cols="20,75a"]
|===
|对象商店 |描述
|自定义对象商店 |创建自定义类来指导Mule在何处以及如何存储缓存的响应。
|内存中存储 |为将缓存响应保存在系统内存中的对象存储配置以下设置：

* 商店名称
* 最大条目数（即缓存的响应）
* 对象存储中的缓存响应（即生存时间）的“生命期”
* 过期缓存响应的轮询之间的截止时间间隔
|托管商店 |为将缓存的响应保存在由ListableObjectSTore定义的位置的对象库配置以下设置：

* 商店名称
* 缓存响应的持久性
* 最大条目数（即缓存的响应）
* 对象存储中的缓存响应（即生存时间）的“生命期”
* 过期缓存响应的轮询之间的截止时间间隔
|简单文本文件商店 |为将缓存的响应保存在文件中的对象库配置以下设置：

* 商店名称
* 最大条目数（即缓存的响应）
* 对象存储中的缓存响应（即生存时间）的“生命期”
* 过期缓存响应的轮询之间的截止时间间隔
* 对象存储保存缓存响应的文件的名称和位置
|===

. 单击*Next*按钮配置对象存储。 （如果您点击*Finish*，Mule会保存未配置的对象库;您必须稍后通过单击替换*Object Store*旁边的*+*图标的编辑图标来配置新的对象库全局元素属性面板上的）字段。）
. 配置新对象存储的设置。如果您选择了自定义对象库，请选择或编写一个类和一个Spring属性来定义对象库。按照下表所述配置所有其他对象库的设置。
+
[%header,cols="15,80"]
|===
|字段或复选框 |指示
|商店名称 |输入您的对象商店的唯一名称。
|持久 |检查以确保对象存储将缓存的响应保存在 http://en.wikipedia.org/wiki/Persistent_storage[持久存储]中。
|最大条目 |输入一个整数来限制对象存储将保存的缓存响应的数量。当达到最大条目数时，对象存储将清除缓存的响应，修剪第一个条目（先进先出）和超出其生存时间的条目。
|条目TTL  |（生存时间）输入一个整数，以指示高速缓存的响应在清除之前必须在对象存储中存活的毫秒数。
|到期间隔 |输入一个整数，以毫秒为单位指示对象存储检查应该清除的缓存响应事件的频率。例如，如果输入“1000”，对象存储会每隔一千毫秒检查一次所有缓存的响应事件，以查看哪些超过了其生存时间并应该清除。
|目录 |输入对象存储保存缓存响应的文件的文件路径。
|===

. 点击完成保存您的更改。

== 示例

下面的示例演示了具有Fibonacci函数的缓存范围的强大功能。斐波那契数列是一系列数字，其中系列中的下一个数字总是它前面两个数字的总和。

在这个例子中，Mule流接收并为每个请求执行两个任务：

. 执行，并使用调用者提供的数字（_n_）将答案返回给斐波那契方程（见下文）
+
`F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1`

. 记录并返回计算成本，其中计算任务的每个单独调用（即在序列中添加两个数字）将成本加1
+
image:cache_example.png[cache_example]

如果已经计算并缓存对Fibonacci函数的调用，则该流将返回缓存响应和检索缓存响应的成本，该缓存响应为0.要演示调用cache缓存该函数的次数，此示例包含能力通过向请求URL添加`nocache`参数来强制流程执行完整计算。

以下序列说明了对斐波那契函数的一系列调用。请注意，当流能够返回缓存值时（因为它已经执行了相同的计算），返回的成本为0.当流能够响应一个使用另一个缓存响应计算的值时（如请求中所示）响应C，如下），成本代表缓存响应和新请求之间的差异。 （例如，如果斐波那契函数已经计算并缓存了n = 10的请求，然后接收到n = 13的请求，则返回第二个响应的成本为3）

image:reqA.png[REQA]

image:reqB.png[REQB]

image:reqC.png[REQC]

image:reqD.png[REQD]

如本例所示，缓存通过重用已检索或计算的数据来节省时间和处理负载。
