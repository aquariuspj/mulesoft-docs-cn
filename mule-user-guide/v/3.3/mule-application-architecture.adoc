=  Mule应用程序体系结构

本页面涵盖了您可以在Mule应用程序中构建的结构特征。


== 关于Mule

Mule ESB为小型企业和大型企业提供全面的应用程序集成。 Mule核心的企业服务总线（Enterprise Service Bus，简称ESB）有助于组织内部的Intranet连接，并保证与基于Web的API和其他云资源的外部连接。

所有的Mule应用程序---以及他们的云端表兄弟称为iApps-都很容易构建，因为它们利用预先打包的构建块来“插入”Mule服务总线提供的标准化接口。

Studio界面提供了强大的“拖放”设计画布和应用程序构建器。配套XML编辑环境为喜欢直接编辑代码的开发人员提供了许多便利。

您可以将Mule应用程序部署到功能强大且轻量级的Mule服务器，该服务器在独立和群集拓扑中表现同样出色。管理控制台便于部署到Mule存储库并随后部署到Mule群集。

CloudHub（以前称为Mule iON）提供了一个加速应用程序部署到云的平台。

强大的Anypoint DataMapper功能不仅可以将有效载荷从一种数据格式转换为另一种数据格式，它可以重新映射数据字段以及以复杂的方式过滤，充实和路由有效载荷。

Data Loader选项减轻了将大型数据集上传到基于Web的API服务（例如Salesforce和SAP）的痛苦和不确定性。

一个庞大且不断扩展的捆绑式和高级连接器产品种类可以为您创建的Mule应用程序提供快速，轻松的云集成。

=== 关于Mule应用程序

在最简单的层面上，Mule应用程序一次接受一条消息，按收到的顺序处理收到的消息。这种处理可能会导致各种结果。有时，Mule应用程序会向原始邮件的来源返回已更改或替换的邮件。此外或作为替代，应用程序可以将其原始或更改形式的消息发送给一个或多个第三方。在其他情况下，如果Mule没有达到特定的标准，他们可以拒绝处理这些信息。

复杂的Mule应用程序远远超出了这种线性消息处理。高级机制可以以不同的方式处理不同的消息。此外，您可以构建应用程序，利用：

* 各种队列和线程安排来最大化吞吐量
* 事务性或集群节点来最大化可靠性
* 对象存储以确保数据持久性

这些仅代表您可以通过Mule应用程序实现的一小部分功能。

==== 关于Mule应用程序部署

您可以通过以下三种方式部署Mule应用程序：

* 作为“压缩”存档文件，其中包含您的Mule应用程序以及使其在应用程序服务器（如Mule ESB独立服务器）上运行所需的所有代码资源和配置信息。
* 通过Mule管理控制台管理的Mule *Repository*。使用此选项可将Mule应用程序部署到群集Mule拓扑。
* 到CloudHub平台（以前称为Mule iON）。

== 关于Mule执行单元

Mule ESB支持几种构建Mule应用程序的架构方法。 MuleSoft建议将*Flows*作为大多数Mule应用程序的首选架构，这是最新，最方便，最灵活的方法。但*Configuration Patterns*仍然可用，并且在某些特定情况下可能会证明有用。

=== 流

Flow为构建Mule应用程序提供了最强大，最灵活的方式，因为您可以将便利的预先打包的构建块安排到针对您的应用程序需求量身定制的一系列消息处理事件中。

流程支持同步和异步子流程，单向和请求响应交换模式以及其他架构选项。

流程对于以下用例可能特别有效：

* 简单的集成任务
* 计划的数据处理
* 集成基于云和内部部署的应用程序
* 需要编排多个服务的事件处理

Mule提供了一对构建Flows的接口。您可以选择：

* 将一行代码输入到基于XML的应用程序配置文件中
使用Mule的Studio图形界面* 将构建块图标排列成视觉序列

随后，您可以使用其他Studio图形工具或通过编辑配置文件中的XML代码来配置这些排序的构建基块。

=== 配置模式

Mule ESB提供了预配置的，易于实现的应用程序模式，这些应用程序模式针对常见的消息处理用例进行了优化。您可以通过Studio的XML编辑器设置这种类型的应用程序。

四种预封装的配置模式是：

[TIP]
如果您的用例不在Mule捆绑的配置模式组中，您应该使用Flow来代替。

=== 关于Flows

在最简单的层面上，流程是消息处理事件的序列。如以下示意图所示，进入流程的消息可能是：

. 验证（过滤）
. 丰富（附加）
. 转换为新格式
通过自定义编码的业务逻辑处理. 
记录到数据库的. 
对. 进行评估，以确定将什么样的响应返回给提交原始消息的参与方

image:BellsnWhistles.png[BellsnWhistles]

构建流的单元通常称为构建块。通常，这些对应于Mule应用程序配置文件中的Studio图形 link:/mule-user-guide/v/3.3/mule-studio-essentials[帆布]或 link:/mule-user-guide/v/3.3/mule-studio-essentials[XML元素]上的图标。

以下屏幕截图展示了Studio图形“画布”上布置的Flow。

image:FlowOnCanvas.png[FlowOnCanvas]

以下代码块表示同一个Flow的XML列表。

[source, xml, linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
 
<mule xmlns="http://www.mulesoft.org/schema/mule/core" xmlns:mulexml="http://www.mulesoft.org/schema/mule/xml" xmlns:http="http://www.mulesoft.org/schema/mule/http" xmlns:scripting="http://www.mulesoft.org/schema/mule/scripting" xmlns:doc="http://www.mulesoft.org/schema/mule/documentation" xmlns:spring="http://www.springframework.org/schema/beans" xmlns:core="http://www.mulesoft.org/schema/mule/core" xmlns:wmq="http://www.mulesoft.org/schema/mule/ee/wmq" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="EE-3.2.2" xsi:schemaLocation="
http://www.mulesoft.org/schema/mule/xml http://www.mulesoft.org/schema/mule/xml/current/mule-xml.xsd
http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
http://www.mulesoft.org/schema/mule/scripting http://www.mulesoft.org/schema/mule/scripting/current/mule-scripting.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-current.xsd
http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
http://www.mulesoft.org/schema/mule/ee/wmq http://www.mulesoft.org/schema/mule/ee/wmq/current/mule-wmq-ee.xsd ">
    <flow name="DemoFlow1" doc:name="DemoFlow1">
        <http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" doc:name="HTTP"/>
        <expression-transformer doc:name="Expression"/>
        <append-string-transformer message="" doc:name="Append String"/>
        <mulexml:xml-to-object-transformer doc:name="XML to Object"/>
        <component doc:name="Java"/>
        <logger level="INFO" doc:name="Logger"/>
        <scripting:component doc:name="Groovy">
            <scripting:script engine="Groovy"/>
        </scripting:component>
    </flow>
</mule>
----

=== 流程构建模块

工作室构建块可以分为几个功能类别，其中一些功能类别是由多个构建块本身组成的处理块。

并非所有的构建块都可以占据流内的所有位置。通常，建筑砌块相对于其他流动（或与其附近的建筑砌块有关）的位置会大大影响砌块的行为以及必须如何配置。

以下小节详细介绍了可以填充Mule Flow的各种构建块（和处理块）。

==== 消息源（可选）

大多数流程中的第一个构建块是消息源，它接收来自一个或多个外部源的消息，从而触发Flow实例。每次它收到另一条消息时，消息源都会触发另一个Flow实例。

通常*Inbound Endpoint*充当消息源，但流** connector**也可以执行此角色。

有时消息源会立即将传入消息放入队列中。这允许消息源关闭用于接收消息的接收者线程，并立即打开另一个线程接受另一个传入消息。刚刚放入队列的消息一直等到它到达队列头部，并且可以通过流程的其余部分处理。由于消息由两个不同的线程按顺序处理（在队列内部进行干预等待），因此不可能执行从头到尾的事务处理。

image:ThreadHandoff.png[ThreadHandoff]

有时，消息源可以接受来自多个传输信道的传入消息。例如，您可以将HTTP端点和Servlet端点嵌入到同一个消息源中。或者，您可以创建一个消息源来接收IMAP和POP3邮件。嵌入式端点（即传输通道）只要收到传入消息就可以触发Flow实例。

在某些情况下，流量不需要由消息源触发。例如， link:/mule-user-guide/v/3.3/flow-ref-component-reference[流量参考组件]可以触发私人子流程。同样， link:/mule-user-guide/v/3.3/async-scope-reference[异步范围]可以触发一个异步执行的子流（即与父流平行）。

==== 消息处理器

通常，这些是以各种方式处理消息的预打包功能单元。除了消息源外，Flow中的所有构建块均可限定为消息处理器。消息处理器提供以下优点：

通常* ，它们不必定制编码
* 多个消息处理器可以组合成各种结构，以提供您的应用程序所需的确切功能

您可以用两种截然不同的方式将消息处理器组装成应用程序（即Flow）序列：

通过在Studio画布上排列图标* 
通过将XML代码插入到应用程序配置文件中* 

消息处理器分为许多方便的类别，如下表所示：

[%header,cols="2*"]
|===
|类别 |简要说明
|端点 |它们分为两个子类别（入站和出站），并为Mule应用程序与外部世界进行通信提供了一种手段。
|范围 |它们以各种方式增强其他消息处理器或称为*Processing Blocks*的消息处理器功能组的功能。
|组件 |它们允许您通过附加日志记录，显示输出甚至子流等功能来增强流。或者，他们通过提供针对Mule应用程序的特定语言"shells"来实现软件即服务（SaaS）集成。
|变形金刚 |他们通过增强或改变消息头或消息负载来准备要通过Mule流处理的消息。
|过滤器 |单独和组合，它们确定消息是否可以通过应用程序流进行。
|流量控制 |它们指定消息如何在流中的各种消息处理器之间路由。它们还可以在将消息路由到其他消息处理器之前处理消息（即聚合，拆分或重新排序）。
|错误处理程序 |它们指定在各种情况下处理异常的各种过程。
|连接器 |它们促进了Mule应用程序与基于Web的第三方API（如Salesforce和Mongo DB）的集成。
|其他 |此特殊类别目前仅包含一个成员：*Custom Business Event*构建基块，您可以将其放置在其他构建基块之间以记录*Key Performance Indicator*（KPI）信息，通过Mule控制台进行监控。
|===

将流程中的各个构建块按正确顺序排列后，可能需要使用以下一个或两个可用选项来配置这些消息处理器：

* 从Studio图形界面中的可用选项下拉列表中选择或完成文本字段
* 在XML配置代码中输入属性值。 （一个漂亮的预测“自动完成”功能可以大大简化这项工作）。

==== 消息处理块

Mule提供了几种将多个消息处理器组合成功能处理块的方法。

例如，*Composite Source*范围允许您将单个消息源嵌入两个或更多入站端点，每个端点监听不同的传输通道。只要其中一个侦听器收到传入消息，它就会触发一个流实例并通过消息处理序列启动消息。

其他构建块*Scopes*提供了多种方式将消息处理器组合成方便的功能组，可以：

* 使您的XML代码更易于阅读
* 执行并行处理
* 创建可重复使用的积木序列

==== 端点

如前所述，*Endpoints*实现传输通道，以便于从数据流中插入或提取数据。终端服务于多种角色，具体取决于它们的配置方式。例如，如前所述，他们可以用作*Inbound*或*Outbound*个管道。他们可以实现单向或请求 - 响应交换模式。而且，在某些情况下，您可以将其他类型的消息处理器（如变换器或过滤器）嵌入端点。

===== 入站端点

当放置在一个流的开始时，无论是单独的还是嵌入*Composite Source*组件中的其他端点，端点始终被称为*Inbound Endpoint*，因为它接受来自外部源的消息并将它们传递给它到其余的流程，从而触发一个新的流程实例。

并非所有流程都需要入站端点。例如，子流可以通过流引用来触发，该流引用不会将任何数据导入到子流中。

并非所有端点都可以用作入站端点。例如，SMTP端点只能用作出站端点。

===== 出站端点

在最基本的层面上，出站端点将数据从流中传出。通常它们占用Flow中的最终消息处理器位置，因此当它们将数据从流中传出时，Flow实例被视为完成。

但是，Outbound端点也可以出现在Flow的中间，例如，当数据流的其余部分继续时，将数据传递到数据库。

并非所有端点都可以用作出站端点。例如，POP3和IMAP只能用作入站端点。

出站端点也可以配置为请求 - 响应交换模式，如下节所述。

===== 请求 - 响应端点

当入站端点（例如HTTP或VM）配置为请求 - 响应模式时，它们实际上会成为混合入站出站端点。即使存在其他出站端点来从流中执行数据，为请求 - 响应交换模式配置的入站端点也会通过向该消息的原始发件人返回响应来处理流出的数据。

当出站端点配置为请求 - 响应交换模式时，它们可以与流程外部的资源交换数据，或者使用完全在同一Mule应用程序中的一串消息处理器交换数据，如以下示意图所示：

image:req-resp.png[REQ，RESP]

并非所有端点都可以配置为请求 - 响应交换模式，而且可以将请求响应仅用于其中一些端点的默认交换模式。使问题更加复杂化的是，某些情况下（如JDBC端点）存在请求响应可用的情况，但仅当端点配置为出站端点时才存在。

当主流中没有任何端点配置为请求 - 响应交换模式时，流遵循*One-Way*交换模式，在该交换模式下它接收传入消息，但不期望对原始发件人提供任何响应。但是，流可能会将数据发送给其他方，例如日志文件，数据库，电子邮件服务器或基于Web的API。

==== 处理策略

处理策略决定Mule如何在您的应用程序中执行消息处理器序列。例如，当为请求 - 响应交换模式配置消息源时，Mule将处理策略设置为*Synchronous,*，这意味着整个流程将在单个处理线程上执行，从而确保整个消息序列处理器执行，客户端收到响应，如预期的那样。

相比之下，当流程配置为单向非事务交换模式（即，不需要对原始消息发送者作出响应，并且不需要验证流程中的所有步骤都已完成） ，Mule将处理策略设置为*Queued Asynchronous,*，这有可能提高流量吞吐量。在此处理策略下，入站端点在收到传入消息后立即将其放入队列中，然后关闭接收线程。当消息到达队列顶部时，它恢复处理，但这次是在另一个线程上。这意味着，这种处理不能作为事务端到端的限定，因为从一个线程到下一个线程的传输意味着如果抛出异常，处理将无法回滚。

image:ProcessingStrategies.png[ProcessingStrategies]

有关更多详情，请参阅 link:/mule-user-guide/v/3.3/flow-processing-strategies[流程处理策略]

==== 例外策略

一个例外策略决定了Mule在消息处理过程中是否发生错误以及何时发生错误。在最简单的情况下，错误只是记录到文件中。

您可以配置自定义异常策略，以各种方式响应各种条件。例如，如果在消息转换后引发异常，您可以将消息设置为Mule，以便在消息转换后存在，但紧接在发生错误之前，以便消息不会无意中被处理两次。

Studio提供了四种预先打包的错误处理策略来处理消息处理序列期间在各个点引发的异常。有关详情，请参阅： link:/mule-user-guide/v/3.3/error-handling[错误处理]

== 流程架构

骡流量非常灵活，所以您可以通过多种方式组合砌块，通常可以达到相同的效果。但是，对于许多用例，某些消息处理器倾向于松散排列的模式。例如，假设您想创建一个应用程序，该应用程序从网页接收产品目录请求，然后将该目录的PDF发回给提交请求的客户端。另外，您希望此流程将客户的客户信息记录到数据库并记录事务，以便您可以跟踪每种类型的目录已发送的数量。你的流可能看起来像这样：

image:DiagramCatalogApp.png[DiagramCatalogApp]

请注意，您可以将过滤器和变换器嵌入到入站端点中，但将它们放入主流序列中可使事件序列更容易在Studio消息流画布和基于XML的应用程序配置文件中“读取”。

image:StudioCatalogApp.png[StudioCatalogApp]

image:XMLCatalogApp.png[XMLCatalogApp]

== 子流程

[TIP]
====
*Key to Understanding the Schematics* +

实线（左下）表示沿着单个线程处理*synchronous*，这非常适合事务处理。虚线（在右下方）表示沿多个线程同时并行*asynchronous*处理。 +
 +
  image:DiagramKey.png[DiagramKey]
====

每个基于流量的Mule应用程序都是围绕主要流程构建的。通常，当消息源接收消息时开始处理每个消息，并在主流中的最后一个消息处理器完成其任务时结束。但是，主流还可以产生同步或异步运行的各种类型的分支（即子）流，并且可以提供以下优点：

* 和*asynchronous*分支流（不需要将数据返回到主流）可以执行潜在的耗时任务，例如将数据写入外部数据库或通过电子邮件发送消息。
* 处理与主流执行的任务相比更重要（或更不重要）的操作的子流可以对错误进行不同于主流的响应。
* 子流可以使复杂的应用程序更容易“读取”，既可以作为消息流画布上的图标排列，也可以作为XML编辑器中的代码。
* 只需要创建一次子流程，然后可以在整个应用程序中多次使用_reused_。
* 在某些情况下，多个子流可以通过确保关键事件序列完成来促进*high reliability*。
* 多个子流可以配置为在Mule集群中的“下一个可用节点”上执行，从而促进*high availability*和*high throughput*。

如下面的小节详细描述的，子流程分为两个主要类别：同步和异步。

=== 同步

当主要流程触发同步子流程时，它将程序控制传递给该子流程并暂停其自己的消息处理活动，直到子流程完成其消息处理事件序列并将编程控制返回到主流程。

image:SynchronousChild.png[SynchronousChild]

由于主要流程和子流程彼此交接编程控制，并且暗示所有处理都发生在同一个线程上，因此可以跟踪消息处理序列中的每个事件，并且可以确保*transactional processing*。

[TIP]
====
交易处理处理一个复杂事件（例如由Mule应用程序处理单个消息）为_distinct，individual_事件，该事件完全_或全部_fails，并且永远不会返回中间或不确定的结果。即使Mule应用程序流中只有一个消息处理事件失败，整个流程也会被视为失败。

然后，应用程序可以“回滚”（即撤消）所有成功完成的消息处理步骤，以便例如在流程中的最后一个步骤中的一个最终步骤时，例如在流程中早期发布的客户发票被取消商品邮寄未能发生。

有时，除了回滚原始失败的处理实例中的所有步骤之外，应用程序还可以恢复原始消息并从头开始重新处理它。由于以前的失败尝试的所有痕迹都已被删除，因此一条消息最终只会产生一组结果。

通常，对于跨线程传输处理控制的Mule流，事务性很难实现，这对大多数类型的分支处理都是如此。然而，某些措施（例如，在主流程的线程上运行的每个子流程的开始和结束时使用VM端点）可以确保这些子流程中的每一个都成功执行_as unit_，尽管此体系结构不确保这些子流之一中的每个消息处理器成功完成其任务。有关详细信息，请参阅：两个队列示例。
====


==== 子流

子流程始终同步运行，继承父流程的处理策略和异常策略。这种通过Studio调色板中的Subflow组件引用的子流程提供了许多潜在的优势。首先，一个子流可以隔离逻辑处理块，使底层的XML代码更容易阅读。

子流程非常适合代码重用，因此开发人员只需编写一段特定的代码，然后在同一个应用程序中重复引用相同的子流程。

image:SubflowReuse.png[SubflowReuse]

尽管子流同步运行，但它可以产生一个自己的异步子流，并行执行，而父子流和主流继续运行。

==== 不是子流的同步子流程

一种特殊类型的子流程与Subflow一样同步运行，但与Subflow不同，此类型的同步子流程使用自己的（而不是父流程）异常策略。当子流内部的消息处理事件要比主流中的其他事件更重要或更不重要时，这会非常有用。无论哪种情况，您都可以将同步子流所用的异常策略设置为与您为主流配置的异常策略执行得非常不同。

image:SyncChildNotSubflow.png[SyncChildNotSubflow]

=== 异步

异步流程在由主流程（或成为其父流程的子流程）触发时开始处理。由于这种类型的子流不需要将数据返回给父流，因此它可以与主流同时执行。换句话说，当主流程触发异步流程时，它既不将程序控制传递给异步流程，也不会暂停自己的消息处理，直到异步流程完成执行。换句话说，父流程始终保留程序控制，而不考虑异步线程的状态。

=== 调用子流程

流参考组件可以调用三种不同类型的子流。

第一种类型称为<<Subflows>>，它是同步的，并始终继承父流所采用的处理策略和异常策略。在子流程运行时，父流程的处理暂停，并且只有在子流程完成后才会恢复，并将控制权交还给父流程。另外，因为必须命名子流，所以可以通过散布在主流的流参考组件多次引用子流。

第二种类型的子流程被称为<<Synchronous Child Flows that are not Subflows>>，它被命名，因此可以像子流程一样重用。同样就像子流一样，同步子流也会导致父流暂停，直到它完成执行。但是，与子流不同，同步子流不会继承父流所使用的异常策略。这允许将特殊错误处理措施应用于同步子流程中的消息处理事件。

您可以通过*Flow Reference*组件调用的第三种子流程称为*Asynchronus Child Flow*。请注意，以这种方式调用的异步流必须被命名，并且因为它存在于父流之外，所以它可以多次调用（即重用）。

image:AsyncFlowRef.png[AsyncFlowRef]

由*Async*作用域调用的*Asynchronous Child Flow*而不是流参考组件存在_in-line_（即，在父流程中），并在主线程继续运行时在单独的线程上异步运行没有停顿。

image:AsyncAsyncScope.png[AsyncAsyncScope]

下表详细介绍了用于调用各种子流的组件：

[%header,cols="5*"]
|===
|子流的类型 |调用组件 |串联？ +
 （即未命名为+
 和不可重复使用） |执行 |异常策略
|子流 |流参考 |否 |同步 |继承
|同步子流 |流参考 |否 |同步 |不被继承
|异步子流 |流参考 |否 |异步 |不被继承
|异步子流 |异步 |是 |异步 |继承
|===

== 流程配置

尽管流程由Studio构建块的序列组成，但不能将任何构建块放置在流程中的任何位置。此外，序列内某些构件块的接近或不存在可以确定给定构件块是否可以放置在流内的某个点处。最后，根据它驻留在流中的位置，给定构件块（尤其是端点）可以为配置公开一组截然不同的属性。

幸运的是，Mule Studio中的图形画布会跟踪所有这些意外事件，并且不会让您在不允许的情况下放置构建块图标。

虽然不可能涵盖可产生可行流程的所有可能的构件块序列，但典型的流程可能会采用以下顺序：

. 由一个或多个入站端点组成的*Message Source*在每次接收到消息时触发流。
. 可能嵌入在消息源中或者在主要流程中嵌入的*Filter*可能会识别无效消息并拒绝将它们传递到流程的其余部分进行处理。
.  *Transformer*可以将传入消息转换为流中其他消息处理器可以消费的数据格式。就像过滤器一样，变压器可以嵌入到消息源中或驻留在主流程中。
.  *Message Enricher*可以将某些重要信息附加到邮件中。例如，如果邮件到达时附有地址，则邮件富集器可能会使用邮政编码查找关联的电话区号，然后将此信息附加到邮件标题用于市场营销目的。
. 在“准备好”处理消息之后，通常会将其发送给某些预先打包或自定义的业务逻辑（通常称为*Component*），以便可以以适合于其特定内容。有时，外部数据库或API（例如Salesforce）可通过称为** connectors**的构建块进行利用。
. 流程的最后阶段可能会有很大差异;部分或全部以下情况可能发生：+
* 将响应返回给消息的原始发件人。
* 业务处理的结果将记录到数据库或发送给其他第三方。

在整个流程中，您可以执行以下操作：

* 配置队列（甚至在同一个流程上有多个类型）
* 指定线程模型
* 创建各种类型的子流
* 设置适用于应用程序不同部分的异常策略

== 高级使用案例

通过明智地将Mule ESB中的架构选项和产品特性相结合，您可以通过最少的开发工作来设计和创建功能强大，功能强大的应用程序，以准确地满足您的需求。

下图描述了应用程序利用子流，两种类型的队列，集群和负载均衡来创建一个Mule应用程序，该应用程序有助于以下所有方面：

* 高吞吐量
* 高可用性
* 高可靠性（事务性）

image:AdvancedUseCase.png[AdvancedUseCase]

=== 它是如何工作的

我们的应用程序建立在一个请求 - 响应交换模式上，在这种模式中，Web客户端提交消息（请求），然后等待应用程序的响应。

在这个特定的拓扑结构中，Java消息服务器（JMS）位于客户端和我们的应用程序之间，在提交消息时接收消息并通过Active MQ进行管理，消息队列执行以下操作：

* 记录每一次提交
* 将消息按照提交顺序转发给应用程序
* 确保我们的应用程序在指定的超时期限内对每条消息提供响应
* 将每个响应转发给相应的发件人

由于JMS位于应用程序之外，与其他应用程序相比，它相对较慢，该应用程序在我们的Mule节点集群中的多个线程上运行。此外，它不能直接查看我们应用程序中单个消息处理事件的成败。尽管如此，JMS通过确保收到每条消息的响应，提供了一种“高级事务性”形式。

在我们的应用程序中，设置为请求 - 响应交换模式的HTTP端点既作为应用程序的消息源（即入站端点），也作为出站端点，通过JMS向每个发件人分派响应。

主流中的消息处理器被分离为三个子流，每个子流都以VM端点开始和结束，并且也在单独的线程上运行。这些VM端点通过VM队列共享内存。如果任何异步子流未能成功执行，VM队列会报告此情况，从而确保一种称为*high reliability*的流级别事务性。

我们的应用程序已通过Mule管理控制台配置为在四节点群集上运行。如果任何节点发生故障，则其中一个节点将处理负载，从而确保*high availability.*

如下图所示，即使没有节点发生故障，子流“步骤”也可以在“下一个可用节点”上处理。这种类型的自动*load balancing*会促进*high throughput*。

image:4NodeLoadBalancing.png[4NodeLoadBalancing]

上述应用程序仅仅是您可以利用Mule技术快速创建和部署强大的，定制的Mule应用程序的众多方式的一个示例。
