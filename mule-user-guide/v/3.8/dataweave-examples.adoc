=  DataWeave实例
:keywords: studio, anypoint, transform, transformer, format, aggregate, rename, split, filter convert, xml, json, csv, pojo, java object, metadata, dataweave, data weave, datamapper, dwl, dfl, dw, output structure, input structure, map, mapping

== 介绍

以下是一系列演示以 link:/mule-user-guide/v/3.8/dataweave-language-introduction[DataWeave]表示的各种数据转换方法的示例。 DataWeave代码通常写在*Transform Message*组件内，可在Anypoint Studio中访问。

[NOTE]
要在实际的Mule应用程序中逐步使用基本的DataWeave用例和练习，请参阅 link:/mule-user-guide/v/3.8/dataweave-quickstart[DataWeave快速入门指南]。

[TIP]
示例中显示的DataWeave代码可以在*input/output metadata*的上下文中理解。可以切换下面的选项卡以查看DataWeave利用的元数据结构来完成转换。


== 基本转型

这一基本转换向您展示了如何轻松地将字段从输入映射到输出，而不需要除将XML转换为JSON之外的任何特殊操作。它也改变了一些字段的顺序和名称。

请注意，此转换一次仅处理"order"数据结构的单个实例。如果您想要处理单个Mule消息中的多个订单的集合，则必须使用*map*运算符对它们进行排序，如下例所示。

[TIP]
link:/mule-user-guide/v/3.8/dataweave-quickstart[DataWeave快速入门指南]向您演示相同的转换，向您展示如何通过拖放UI自动创建它。然后它会调整代码以使其更有趣。

=== 示例转换

.DataWeave
[source,DataWeave, linenums]
---
％dw 1.0
％输出应用程序/ json
---
{
         address1：payload.order.buyer.address，
        城市：payload.order.buyer.city，
        国家/地区：payload.order.buyer.nationality，
        电子邮件地址：payload.order.buyer.email，
        名称：payload.order.buyer.name，
         postalCode：payload.order.buyer.postCode，
         stateOrProvince：payload.order.buyer.state
}
----

[tabs]
------
[tab,title="Input: XML"]
....

.Input
[source, xml, linenums]
----
<?xml version='1.0' encoding='UTF-8'?>
<order>
  <product>
    <price>5</price>
    <model>MuleSoft Connect 2016</model>
  </product>
  <item_amount>3</item_amount>
  <payment>
    <payment-type>credit-card</payment-type>
    <currency>USD</currency>
    <installments>1</installments>
  </payment>
  <buyer>
    <email>mike@hotmail.com</email>
    <name>Michael</name>
    <address>Koala Boulevard 314</address>
    <city>San Diego</city>
    <state>CA</state>
    <postCode>1345</postCode>
    <nationality>USA</nationality>
  </buyer>
  <shop>main branch</shop>
  <salesperson>Mathew Chow</salesperson>
</order>
----

....
[tab,title="Output: JSON"]
....

.Output
[source, json, linenums]
----
{
  "address1": "Koala Boulevard 314",
  "city": "San Diego",
  "country": "USA",
  "email": "mike@hotmail.com",
  "name": "Michael",
  "postalCode": "1345",
  "stateOrProvince": "CA"
}
----

....
------



== Using the `map` Operator

Follow along to see how to use the link:/mule-user-guide/v/3.8/dataweave-operators#map[`map`] operator. The `as` operator is also featured in this example. Take an XML list of books and use DataWeave to output a JSON version of the book list. It goes through each `<book>` element from the XML input, simply using the `map` operator.


You can ensure the transformation generates the correct type for each element by using the `as` operator (used for type coercion - see an https://docs.mulesoft.com/mule-user-guide/v/3.8/dataweave-operators#coerce-to-number[`as` operator example]).

[NOTE]
Since JSON cannot accept duplicate keys, elements that are duplicated in the input, show the first of the keys on the output side.

=== Example Transformation

.DataWeave
[source,DataWeave,linenums]

----
％dw 1.0
％输出应用程序/ json
---
项目：payload.books地图{
      类型："book"，
      价格：$ .price as：number，
      属性：{
        标题：$ .title，
        作者：$。作者，
         year：$ .year as：number
      }
}
----

[tabs]
------
[tab,title="Input: JSON"]
....
.Input
[source, json, linenums]
----
{
    "books": [
      {
        "-category": "cooking",
        "title": {
          "-lang": "en",
          "#text": "Everyday Italian"
        },
        "author": "Giada De Laurentiis",
        "year": "2005",
        "price": "30.00"
      },
      {
        "-category": "children",
        "title": {
          "-lang": "en",
          "#text": "Harry Potter"
        },
        "author": "J K. Rowling",
        "year": "2005",
        "price": "29.99"
      },
      {
        "-category": "web",
        "title": {
          "-lang": "en",
          "#text": "XQuery Kick Start"
        },
        "author": [
          "James McGovern",
          "Per Bothner",
          "Kurt Cagle",
          "James Linn",
          "Vaidyanathan Nagarajan"
        ],
        "year": "2003",
        "price": "49.99"
      },
      {
        "-category": "web",
        "-cover": "paperback",
        "title": {
          "-lang": "en",
          "#text": "Learning XML"
        },
        "author": "Erik T. Ray",
        "year": "2003",
        "price": "39.95"
      }
    ]
}
----

....
[tab,title="Output: JSON"]
....

.Output
[source, json, linenums]
----
{
  "items": [
    {
      "type": "book",
      "price": 30.00,
      "properties": {
        "title": {
          "-lang": "en",
          "#text": "Everyday Italian"
        },
        "author": "Giada De Laurentiis",
        "year": 2005
      }
    },
    {
      "type": "book",
      "price": 29.99,
      "properties": {
        "title": {
          "-lang": "en",
          "#text": "Harry Potter"
        },
        "author": "J K. Rowling",
        "year": 2005
      }
    },
    {
      "type": "book",
      "price": 49.99,
      "properties": {
        "title": {
          "-lang": "en",
          "#text": "XQuery Kick Start"
        },
        "author": [
          "James McGovern",
          "Per Bothner",
          "Kurt Cagle",
          "James Linn",
          "Vaidyanathan Nagarajan"
        ],
        "year": 2003
      }
    },
    {
      "type": "book",
      "price": 39.95,
      "properties": {
        "title": {
          "-lang": "en",
          "#text": "Learning XML"
        },
        "author": "Erik T. Ray",
        "year": 2003
      }
    }
  ]
}
----
....
------

In general, it is better to name the mapping parameters with an easier to understand context, so instead of using the automatic parameters $ and $$, it's better to name these parameters. 

Here is how this map operator can be written with more descriptive mapping parameters, which are then referenced inside the map operator's mapping expression: 

.DataWeave
[source,DataWeave,linenums]
----
％dw 1.0
％输出应用程序/ json
---
项目：payload.books地图（nextBook，nextIndex） - > {
      类型："book"，
      价格：nextBook.price as：number，
      属性：{
        标题：nextBook.title，
        作者：$。作者，
         year：nextBook.year as：number
      }
}
----

[tabs]
------
[tab,title="Input: JSON"]
....
.Input
[source, json, linenums]
----
{
    "books": [
      {
        "-category": "cooking",
        "title": {
          "-lang": "en",
          "#text": "Everyday Italian"
        },
        "author": "Giada De Laurentiis",
        "year": "2005",
        "price": "30.00"
      },
      {
        "-category": "children",
        "title": {
          "-lang": "en",
          "#text": "Harry Potter"
        },
        "author": "J K. Rowling",
        "year": "2005",
        "price": "29.99"
      },
      {
        "-category": "web",
        "title": {
          "-lang": "en",
          "#text": "XQuery Kick Start"
        },
        "author": [
          "James McGovern",
          "Per Bothner",
          "Kurt Cagle",
          "James Linn",
          "Vaidyanathan Nagarajan"
        ],
        "year": "2003",
        "price": "49.99"
      },
      {
        "-category": "web",
        "-cover": "paperback",
        "title": {
          "-lang": "en",
          "#text": "Learning XML"
        },
        "author": "Erik T. Ray",
        "year": "2003",
        "price": "39.95"
      }
    ]
}
----

....
[tab,title="Output: JSON"]
....

.Output
[source, json, linenums]
----
{
  "items": [
    {
      "type": "book",
      "price": 30.00,
      "properties": {
        "title": {
          "-lang": "en",
          "#text": "Everyday Italian"
        },
        "author": "Giada De Laurentiis",
        "year": 2005
      }
    },
    {
      "type": "book",
      "price": 29.99,
      "properties": {
        "title": {
          "-lang": "en",
          "#text": "Harry Potter"
        },
        "author": "J K. Rowling",
        "year": 2005
      }
    },
    {
      "type": "book",
      "price": 49.99,
      "properties": {
        "title": {
          "-lang": "en",
          "#text": "XQuery Kick Start"
        },
        "author": [
          "James McGovern",
          "Per Bothner",
          "Kurt Cagle",
          "James Linn",
          "Vaidyanathan Nagarajan"
        ],
        "year": 2003
      }
    },
    {
      "type": "book",
      "price": 39.95,
      "properties": {
        "title": {
          "-lang": "en",
          "#text": "Learning XML"
        },
        "author": "Erik T. Ray",
        "year": 2003
      }
    }
  ]
}
----
....
------

[NOTE] 
Naming mapping operator parameters is also a best practice because it also helps you to next other operators inside the map operator, but still have access to these mapping parameters, such as if you are trying to join two data schema together. 


Because you are not using the index at all in the mapping expression, the second parameter does not have to be included in the map operator: 


.DataWeave
[source,DataWeave,linenums]
----
％dw 1.0
％输出应用程序/ json
---
项目：payload.books地图（nextBook） - > {
      类型："book"，
      价格：nextBook.price as：number，
      属性：{
        标题：nextBook.title，
        作者：$。作者，
         year：nextBook.year as：number
      }
}
----

[tabs]
------
[tab,title="Input: JSON"]
....
.Input
[source, json, linenums]
----
{
    "books": [
      {
        "-category": "cooking",
        "title": {
          "-lang": "en",
          "#text": "Everyday Italian"
        },
        "author": "Giada De Laurentiis",
        "year": "2005",
        "price": "30.00"
      },
      {
        "-category": "children",
        "title": {
          "-lang": "en",
          "#text": "Harry Potter"
        },
        "author": "J K. Rowling",
        "year": "2005",
        "price": "29.99"
      },
      {
        "-category": "web",
        "title": {
          "-lang": "en",
          "#text": "XQuery Kick Start"
        },
        "author": [
          "James McGovern",
          "Per Bothner",
          "Kurt Cagle",
          "James Linn",
          "Vaidyanathan Nagarajan"
        ],
        "year": "2003",
        "price": "49.99"
      },
      {
        "-category": "web",
        "-cover": "paperback",
        "title": {
          "-lang": "en",
          "#text": "Learning XML"
        },
        "author": "Erik T. Ray",
        "year": "2003",
        "price": "39.95"
      }
    ]
}
----

....
[tab,title="Output: JSON"]
....

.Output
[source, json, linenums]
----
{
  "items": [
    {
      "type": "book",
      "price": 30.00,
      "properties": {
        "title": {
          "-lang": "en",
          "#text": "Everyday Italian"
        },
        "author": "Giada De Laurentiis",
        "year": 2005
      }
    },
    {
      "type": "book",
      "price": 29.99,
      "properties": {
        "title": {
          "-lang": "en",
          "#text": "Harry Potter"
        },
        "author": "J K. Rowling",
        "year": 2005
      }
    },
    {
      "type": "book",
      "price": 49.99,
      "properties": {
        "title": {
          "-lang": "en",
          "#text": "XQuery Kick Start"
        },
        "author": [
          "James McGovern",
          "Per Bothner",
          "Kurt Cagle",
          "James Linn",
          "Vaidyanathan Nagarajan"
        ],
        "year": 2003
      }
    },
    {
      "type": "book",
      "price": 39.95,
      "properties": {
        "title": {
          "-lang": "en",
          "#text": "Learning XML"
        },
        "author": "Erik T. Ray",
        "year": 2003
      }
    }
  ]
}
----
....
------

If the mapping expression was not using object constructor curly braces { }, you would want to use evaluation parentheses to define the scope of the mapping parameters. Even with the object constructor curly braces { }, it is fine to enclose the mapping parameters and the mapping expression in a pair of evaluation parentheses ( ), such as:  


.DataWeave
[source,DataWeave,linenums]
----
％dw 1.0
％输出应用程序/ json
---
项目：payload.books地图（（nextBook，nextIndex） - > {
      类型："book"，
      价格：nextBook.price as：number，
      属性：{
        标题：nextBook.title，
        作者：$。作者，
         year：nextBook.year as：number
      }
  }
)
----
[tabs]
------
[tab,title="Input: JSON"]
....
.Input
[source, json, linenums]
----
{
    "books": [
      {
        "-category": "cooking",
        "title": {
          "-lang": "en",
          "#text": "Everyday Italian"
        },
        "author": "Giada De Laurentiis",
        "year": "2005",
        "price": "30.00"
      },
      {
        "-category": "children",
        "title": {
          "-lang": "en",
          "#text": "Harry Potter"
        },
        "author": "J K. Rowling",
        "year": "2005",
        "price": "29.99"
      },
      {
        "-category": "web",
        "title": {
          "-lang": "en",
          "#text": "XQuery Kick Start"
        },
        "author": [
          "James McGovern",
          "Per Bothner",
          "Kurt Cagle",
          "James Linn",
          "Vaidyanathan Nagarajan"
        ],
        "year": "2003",
        "price": "49.99"
      },
      {
        "-category": "web",
        "-cover": "paperback",
        "title": {
          "-lang": "en",
          "#text": "Learning XML"
        },
        "author": "Erik T. Ray",
        "year": "2003",
        "price": "39.95"
      }
    ]
}
----

....
[tab,title="Output: JSON"]
....

.Output
[source, json, linenums]
----
{
  "items": [
    {
      "type": "book",
      "price": 30.00,
      "properties": {
        "title": {
          "-lang": "en",
          "#text": "Everyday Italian"
        },
        "author": "Giada De Laurentiis",
        "year": 2005
      }
    },
    {
      "type": "book",
      "price": 29.99,
      "properties": {
        "title": {
          "-lang": "en",
          "#text": "Harry Potter"
        },
        "author": "J K. Rowling",
        "year": 2005
      }
    },
    {
      "type": "book",
      "price": 49.99,
      "properties": {
        "title": {
          "-lang": "en",
          "#text": "XQuery Kick Start"
        },
        "author": [
          "James McGovern",
          "Per Bothner",
          "Kurt Cagle",
          "James Linn",
          "Vaidyanathan Nagarajan"
        ],
        "year": 2003
      }
    },
    {
      "type": "book",
      "price": 39.95,
      "properties": {
        "title": {
          "-lang": "en",
          "#text": "Learning XML"
        },
        "author": "Erik T. Ray",
        "year": 2003
      }
    }
  ]
}
----
....
------

All of these variations of the DataWeave body expression will yield the same result. 






== Remove Fields

In this example, the input contains sensitive information that should be removed. The transform replicates the inbound structure but uses a simple link:/mule-user-guide/v/3.8/dataweave-operators#remove[`remove`] operator to take away specific key:value pairs.

The example goes through the whole set of elements in the input using the link:/mule-user-guide/v/3.8/dataweave-operators#map[`map`] operator.

=== Example Transformation

.DataWeave
[source,DataWeave, linenums]
----
％dw 1.0
％output application / xml
---
用户：{
      （payload.users map {
        用户：{
         personal_information：$。个人信息 -  "ssn"，
         login_information：$ .login_information  -  "password"
        }
      }）
}
----

[tabs]
------
[tab,title="Input: XML"]
....
.Input
[source, xml, linenums]
----
<users>
    <user>
        <personal_information>
            <first_name>Emiliano</first_name>
            <middle_name>Romoaldo</middle_name>
            <last_name>Lesende</last_name>
            <ssn>001-08-84382</ssn>
        </personal_information>
        <login_information>
            <username>3miliano</username>
            <password>mypassword1234</password>
        </login_information>
    </user>
    <user>
        <personal_information>
            <first_name>Mariano</first_name>
            <middle_name>Toribio</middle_name>
            <last_name>de Achaval</last_name>
            <ssn>002-05-34738</ssn>
        </personal_information>
        <login_information>
            <username>machaval</username>
            <password>mypassword4321</password>
        </login_information>
    </user>
</users>
----
....
[tab,title="Output: XML"]
....


.Output
[source, xml, linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<users>
  <user>
    <personal_information>
      <first_name>Emiliano</first_name>
      <middle_name>Romoaldo</middle_name>
      <last_name>Lesende</last_name>
    </personal_information>
    <login_information>
      <username>3miliano</username>
    </login_information>
  </user>
  <user>
    <personal_information>
      <first_name>Mariano</first_name>
      <middle_name>Toribio</middle_name>
      <last_name>de Achaval</last_name>
    </personal_information>
    <login_information>
      <username>machaval</username>
    </login_information>
  </user>
</users>
----
....
------

== Replace Values

In this example, the input contains the same sensitive information as in the previous one, but instead of entirely removing the key:value pairs that contain it, the values are replaced with the string. The transform replicates the inbound structure but uses a simple link:/mule-user-guide/v/3.8/dataweave-language-introduction#when-otherwise[`when`] operator to replace values when specific keys occur.

The example goes through the whole set of elements in the input using the link:/mule-user-guide/v/3.8/dataweave-operators#map[`map`] operator.

=== Example Transformation

.DataWeave
[source,DataWeave, linenums]
----
％dw 1.0
％output application / xml
---
用户：{（payload.users map {
    用户：{
        personal_information：$ .personal_information mapObject {
            （$$）：$除非$$〜= "ssn"否则"****"
       }，
        login_information：$ .login_information mapObject {
          （$$）：$除非$$〜= "password"否则"****"
       }
     }
}) }
----


[tabs]
------
[tab,title="Input: XML"]
....
.Input
[source, xml, linenums]
----
<users>
    <user>
        <personal_information>
            <first_name>Emiliano</first_name>
            <middle_name>Romoaldo</middle_name>
            <last_name>Lesende</last_name>
            <ssn>001-08-84382</ssn>
        </personal_information>
        <login_information>
            <username>3miliano</username>
            <password>mypassword1234</password>
        </login_information>
    </user>
    <user>
        <personal_information>
            <first_name>Mariano</first_name>
            <middle_name>Toribio</middle_name>
            <last_name>de Achaval</last_name>
            <ssn>002-05-34738</ssn>
        </personal_information>
        <login_information>
            <username>machaval</username>
            <password>mypassword4321</password>
        </login_information>
    </user>
</users>
----

....
[tab,title="Output: XML"]
....

.Output
[source, xml, linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<users>
  <user>
    <personal_information>
      <first_name>Emiliano</first_name>
      <middle_name>Romoaldo</middle_name>
      <last_name>Lesende</last_name>
      <ssn>****</ssn>
    </personal_information>
    <login_information>
      <username>3miliano</username>
      <password>****</password>
    </login_information>
  </user>
  <user>
    <personal_information>
      <first_name>Mariano</first_name>
      <middle_name>Toribio</middle_name>
      <last_name>de Achaval</last_name>
      <ssn>****</ssn>
    </personal_information>
    <login_information>
      <username>machaval</username>
      <password>****</password>
    </login_information>
  </user>
</users>
----
....
------


== Target an Attribute

This example shows you how to transform a JSON array of objects to XML. Each object represents a book and its attributes.

The link:/mule-user-guide/v/3.8/dataweave-operators#map[`map`] operator carries out the same steps for each element in the input array. Through the use of @, attributes are injected into the XML.

[TIP]
See link:/mule-user-guide/v/3.8/dataweave-selectors#attribute-selector-expressions[Attribute selector expressions] on how to select XML attributes in DataWeave.

=== Example Transformation

.DataWeave
[source,DataWeave, linenums]
----
％dw 1.0
％output application / xml
---
{
  书店：{（有效载荷地图{
      书：{
       title @（lang："en"）：$ .item.properties.title，
      年：$ .item.properties.year，
      价格：$ .item.price，
      （$。item.properties.author map
      作者@（loc："US"）：$）
    }
  }）}
}
----

[tabs]
------
[tab,title="Input: JSON"]
....

.Input
[source, json, linenums]
----
[
  {
    "item": {
      "type": "book",
      "price": 30,
      "properties": {
        "title": "Everyday Italian",
        "author": [
          "Giada De Laurentiis"
        ],
        "year": 2005
      }
    }
  },
  {
    "item": {
      "type": "book",
      "price": 29.99,
      "properties": {
        "title": "Harry Potter",
        "author": [
          "J K. Rowling"
        ],
        "year": 2005
      }
    }
  },
  {
    "item": {
      "type": "book",
      "price": 49.99,
      "properties": {
        "title": "XQuery Kick Start",
        "author": [
          "James McGovern",
          "Per Bothner",
          "Kurt Cagle",
          "James Linn",
          "Vaidyanathan Nagarajan"
        ],
        "year": 2003
      }
    }
  },
  {
    "item": {
      "type": "book",
      "price": 39.95,
      "properties": {
        "title": "Learning XML",
        "author": [
          "Erik T. Ray"
        ],
        "year": 2003
      }
    }
  }
]
----
....
[tab,title="Output: XML"]
....
.Output
[source, xml, linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<bookstore>
  <book>
    <title lang="en">Everyday Italian</title>
    <year>2005</year>
    <price>30</price>
    <author loc="US">Giada De Laurentiis</author>
  </book>
  <book>
    <title lang="en">Harry Potter</title>
    <year>2005</year>
    <price>29.99</price>
    <author loc="US">J K. Rowling</author>
  </book>
  <book>
    <title lang="en">XQuery Kick Start</title>
    <year>2003</year>
    <price>49.99</price>
    <author loc="US">James McGovern</author>
    <author loc="US">Per Bothner</author>
    <author loc="US">Kurt Cagle</author>
    <author loc="US">James Linn</author>
    <author loc="US">Vaidyanathan Nagarajan</author>
  </book>
  <book>
    <title lang="en">Learning XML</title>
    <year>2003</year>
    <price>39.95</price>
    <author loc="US">Erik T. Ray</author>
  </book>
</bookstore>
----
....
------


== Adding Optional Fields Based on a Condition

When mapping something to an XML format, you may want to add certain tags based on a condition.
The mapping below only inserts the 'insurance' tag when it's present in the input.

The example goes through the whole set of elements in the input using a link:/mule-user-guide/v/3.8/dataweave-operators#map[`map`] operator. It also uses the link:/mule-user-guide/v/3.8/dataweave-language-introduction#when-otherwise[`when`] operator to only select instances that include the field 'insurance'.

=== Example Transformation

.DataWeave
[source,dataweave, linenums]
----
％dw 1.0
％output application / xml
---
用户：{
  （有效载荷映射{
        用户：{
          名称：$ .name，
{$ 0}}（保险：$。保险）何时$。保险？
        }
    }）
}
----

[tabs]
------
[tab,title="Input: JSON"]
....
.Input
[source,json, linenums]
----
[
  {
    "name" : "Julian",
    "gender" : "Male",
    "age" : 41,
    "insurance": "Osde"
  },
  {
    "name" : "Mariano",
    "gender" : "Male",
    "age" : 33
  }
]
----

....
[tab,title="Output: XML"]
....
.Output
[source,xml, linenums]
----
<?xml version='1.0' encoding='US-ASCII'?>
<users>
  <user>
    <name>Julian</name>
    <insurance>Osde</insurance>
  </user>
  <user>
    <name>Mariano</name>
  </user>
</users>
----
....
------


== Rename Keys When These Exist

This example takes in a JSON object that contains several fields. Most of them must be kept identical, except for a couple that optionally might appear in the payload, and if so should be renamed. Instead of referencing each field individually, this example renames two fields in particular and handles the rest without any changes.

The example goes through the whole set of elements in the input using  a link:/mule-user-guide/v/3.8/dataweave-operators#map-object[`mapObject`] operator. Note that it differs from the map operation in that map object processes both key and value of its input, rather than just the keys. It also uses the link:/mule-user-guide/v/3.8/dataweave-language-introduction#when-otherwise[`when`] operator together with an link:/mule-user-guide/v/3.8/dataweave-operators#and[`and`] to pick out the specific keys that need to change, and an https://docs.mulesoft.com/mule-user-guide/v/3.8/dataweave-operators#coerce-to-number[example use] of the `as` operator to coerce its type to string.


=== Example Transformation

.DataWeave
[source,DataWeave, linenums]
----
％dw 1.0
％输出应用程序/ json
---
payload.flights map（flight） - > {
（flight mapObject（value，key） - > {
当键为as时，    （emptySeats：value）：string =='availableSeats'，
    （airline：value）key as：string =='airlineName'，
{（0）}（（key）：value）when（key as：string！='availableSeats'）and（key as：string！='airlineName'）
  }）
}
----

[tabs]
------
[tab,title="Input: JSON"]
....
.Input
[source, json, linenums]
----
{
  "flights":[
  {
  "availableSeats":45,
  "airlineName":"Ryan Air",
  "aircraftBrand":"Boeing",
  "aircraftType":"737",
  "departureDate":"12/14/2017",
  "origin":"BCN",
  "destination":"FCO"
  },
  {
  "availableSeats":15,
  "airlineName":"Ryan Air",
  "aircraftBrand":"Boeing",
  "aircraftType":"747",
  "departureDate":"08/03/2017",
  "origin":"FCO",
  "destination":"DFW"
  }]
}
----


....
[tab,title="Output: JSON"]
....
.Output
[source, json, linenums]
----
[
  {
    "emptySeats": 45,
    "airline": "Ryan Air",
    "aircraftBrand": "Boeing",
    "aircraftType": "737",
    "departureDate": "12/14/2017",
    "origin": "BCN",
    "destination": "FCO"
  },
  {
    "emptySeats": 15,
    "airline": "Ryan Air",
    "aircraftBrand": "Boeing",
    "aircraftType": "747",
    "departureDate": "08/03/2017",
    "origin": "FCO",
    "destination": "DFW"
  }
]
----
....
------


== Using Constant Directives

This example converts an XML input to a JSON output that is structured differently and that contains URL links that are built from concatenating input content defining a few link:/mule-user-guide/v/3.8/dataweave-language-introduction#define-constat-directive[constant directives] in link:/mule-user-guide/v/3.8/dataweave-language-introduction#the-dataweave-header[The DataWeave Header]. The transform also creates a few fields that are conditional and are only present in the output when they exist in the input.

=== Example Transformation


.DataWeave
[source,DataWeave, linenums]
----
％dw 1.0
％输出应用程序/ json
％var baseUrl = "http://alainn-cosmetics.cloudhub.io/api/v1.0/"
％var urlPage = "http://alainn-cosmetics.cloudhub.io/api/v1.0/items"
％var pageIndex = 0
％var requestedPageSize = 4
％var fullUrl = "http://alainn-cosmetics.cloudhub.io/api/v1.0/items"
---
使用（pageSize = payload.getItemsResponse.PageInfo.pageSize）{
     链接：[
         {
             href：fullUrl，
             rel："self"
        }，
         {
             href：urlPage ++ "?pageIndex=" ++（pageIndex + pageSize）++ "&pageSize=" ++ requestedPageSize，
             rel："next"
        }，
        （{
             href：urlPage ++ "?pageIndex=" ++（pageIndex  -  pageSize）++ "&pageSize=" ++ requestedPageSize，
             rel："prev"
        }）when（pageIndex> 0）
     ]，
     集合：{
        大小：pageSize，
        项目：payload.getItemsResponse。*项目图{
             id：$ .id，
            键入：$ .type，
            名称：$ .name，
{$ 0}}（摘要：$ .summary）$ .summary ?,
{。0}}（品牌：$ .brand）$ .brand ?,
            链接：（$ .images。*图片地图{
                 href：trim $，
                 rel：$。@ type
            }）+ {
                 href：baseUrl ++ "/" ++ $ .id，
                 rel："self"
            }
        }
     }
}
----

[tabs]
------
[tab,title="Input: XML"]
....

.Input

[source, xml, linenums]
----
<ns0:getItemsResponse xmlns:ns0="http://www.alainn.com/SOA/message/1.0">
    <ns0:PageInfo>
        <pageIndex>0</pageIndex>
        <pageSize>20</pageSize>
    </ns0:PageInfo>
    <ns1:Item xmlns:ns1="http://www.alainn.com/SOA/model/1.0">
        <id>B0015BYNRO</id>
        <type>Oils</type>
        <name>Now Foods LANOLIN PURE</name>
        <images>
            <image type="SwatchImage">http://ecx.images-amazon.com/images/I/11Qoe774Q4L._SL30_.jpg
            </image>
        </images>
    </ns1:Item>
    <ns1:Item xmlns:ns1="http://www.alainn.com/SOA/model/1.0">
        <id>B002K8AD02</id>
        <type>Bubble Bath</type>
        <name>Deep Steep Honey Bubble Bath</name>
        <summary>Disclaimer: This website is for informational purposes only.
            Always check the actual product label in your possession for the most
            accurate ingredient information due to product changes or upgrades
            that may not yet be reflected on our web site. These statements made
            in this website have not been evaluated by the Food and Drug
            Administration. The products offered are not intended to diagnose,
            treat
        </summary>
        <images>
            <image type="SwatchImage">http://ecx.images-amazon.com/images/I/216ytnMOeXL._SL30_.jpg
            </image>
        </images>
    </ns1:Item>
    <ns1:Item xmlns:ns1="http://www.alainn.com/SOA/model/1.0">
        <id>B000I206JK</id>
        <type>Oils</type>
        <name>Now Foods Castor Oil</name>
        <summary>One of the finest natural skin emollients available</summary>
        <images>
            <image type="SwatchImage">http://ecx.images-amazon.com/images/I/21Yz8q-yQoL._SL30_.jpg
            </image>
        </images>
    </ns1:Item>
    <ns1:Item xmlns:ns1="http://www.alainn.com/SOA/model/1.0">
        <id>B003Y5XF2S</id>
        <type>Chemical Hair Dyes</type>
        <name>Manic Panic Semi-Permanent Color Cream</name>
        <summary>Ready to use, no mixing required</summary>
        <images>
            <image type="SwatchImage">http://ecx.images-amazon.com/images/I/51A2FuX27dL._SL30_.jpg
            </image>
        </images>
    </ns1:Item>
    <ns1:Item xmlns:ns1="http://www.alainn.com/SOA/model/1.0">
        <id>B0016BELU2</id>
        <type>Chemical Hair Dyes</type>
        <name>Herbatint Herbatint Permanent Chestnut (4n)</name>
        <images>
            <image type="SwatchImage">http://ecx.images-amazon.com/images/I/21woUiM0BdL._SL30_.jpg
            </image>
        </images>
    </ns1:Item>
</ns0:getItemsResponse>
----
....
[tab,title="Output: JSON"]
....
.Output
[source, json, linenums]
----
{
  "links": [
    {
      "href": "http:\/\/alainn-cosmetics.cloudhub.io\/api\/v1.0\/items",
      "rel": "self"
    },
    {
      "href": "http:\/\/alainn-cosmetics.cloudhub.io\/api\/v1.0\/items?pageIndex=20&pageSize=4",
      "rel": "next"
    }
  ],
  "collection": {
    "size": "20",
    "items": [
      {
        "id": "B0015BYNRO",
        "type": "Oils",
        "name": "Now Foods LANOLIN PURE",
        "links": [
          {
            "href": "http:\/\/ecx.images-amazon.com\/images\/I\/11Qoe774Q4L._SL30_.jpg",
            "rel": "SwatchImage"
          },
          {
            "href": "http:\/\/alainn-cosmetics.cloudhub.io\/api\/v1.0\/\/B0015BYNRO",
            "rel": "self"
          }
        ]
      },
      {
        "id": "B002K8AD02",
        "type": "Bubble Bath",
        "name": "Deep Steep Honey Bubble Bath",
        "summary": "Disclaimer: This website is for informational purposes only.\n            Always check the actual product label in your possession for the most\n            accurate ingredient information due to product changes or upgrades\n            that may not yet be reflected on our web site. These statements made\n            in this website have not been evaluated by the Food and Drug\n            Administration. The products offered are not intended to diagnose,\n            treat\n        ",
        "links": [
          {
            "href": "http:\/\/ecx.images-amazon.com\/images\/I\/216ytnMOeXL._SL30_.jpg",
            "rel": "SwatchImage"
          },
          {
            "href": "http:\/\/alainn-cosmetics.cloudhub.io\/api\/v1.0\/\/B002K8AD02",
            "rel": "self"
          }
        ]
      },
      {
        "id": "B000I206JK",
        "type": "Oils",
        "name": "Now Foods Castor Oil",
        "summary": "One of the finest natural skin emollients available",
        "links": [
          {
            "href": "http:\/\/ecx.images-amazon.com\/images\/I\/21Yz8q-yQoL._SL30_.jpg",
            "rel": "SwatchImage"
          },
          {
            "href": "http:\/\/alainn-cosmetics.cloudhub.io\/api\/v1.0\/\/B000I206JK",
            "rel": "self"
          }
        ]
      },
      {
        "id": "B003Y5XF2S",
        "type": "Chemical Hair Dyes",
        "name": "Manic Panic Semi-Permanent Color Cream",
        "summary": "Ready to use, no mixing required",
        "links": [
          {
            "href": "http:\/\/ecx.images-amazon.com\/images\/I\/51A2FuX27dL._SL30_.jpg",
            "rel": "SwatchImage"
          },
          {
            "href": "http:\/\/alainn-cosmetics.cloudhub.io\/api\/v1.0\/\/B003Y5XF2S",
            "rel": "self"
          }
        ]
      },
      {
        "id": "B0016BELU2",
        "type": "Chemical Hair Dyes",
        "name": "Herbatint Herbatint Permanent Chestnut (4n)",
        "links": [
          {
            "href": "http:\/\/ecx.images-amazon.com\/images\/I\/21woUiM0BdL._SL30_.jpg",
            "rel": "SwatchImage"
          },
          {
            "href": "http:\/\/alainn-cosmetics.cloudhub.io\/api\/v1.0\/\/B0016BELU2",
            "rel": "self"
          }
        ]
      }
    ]
  }
}
----
....
------



== Perform Basic Math

This example takes an XML input and parses it into a different XML arrangement. After a single `<header>` element is copied, a link:/mule-user-guide/v/3.8/dataweave-operators#map[`map` operation] carries out the same steps for each 'item': several fields are passed on without any changes, then the discount and subtotal fields are calculated with references to constants defined in the link:/mule-user-guide/v/3.8/dataweave-language-introduction#the-dataweave-header[header directives] of the transform. A single set of subtotal, tax and total elements are created by performing a link:/mule-user-guide/v/3.8/dataweave-operators#reduce[*reduce*] operation over all of the items in the "items" array, performing calculations that sometimes involve constants defined in the header. The link:/mule-user-guide/v/3.8/dataweave-operators#as[`as`] operator is also used to coerce to a number and then performs link:/mule-user-guide/v/3.8/dataweave-operators#basic-math-operations[basic math] on these numbers.

=== Example Transformation

.DataWeave
[source,DataWeave, linenums]
----
％dw 1.0
％output application / xml
％var tax = 0.085
％var折扣= 0.05
---
发票：{
    标头：payload.invoice.header，
    项目：{（payload.invoice.items。*项目地图{
         item @（index：$$ + 1）：{
            描述：$ .description，
            数量：$ .quantity，
             unit_price：$ .unit_price，
            折扣：（折扣* 100）as：number {format："##"} ++ "%"，
            小计：$ .unit_price * $.quantity *（1-折扣）
        }
    }）}，
总计：使用（小计= payload.invoice.items reduce（（item，sum1 = 0） - > sum1 +（item.unit_price * item.quantity *（1-折扣））））{
        小计：小计，
        税：（税* 100）as：number {format："##.#"} ++ "%"，
        总计：小计*（1 +税）
    }
}
----

[tabs]
------
[tab,title="Input: XML"]
....
.Input
[source, xml, linenums]
----
<invoice>
    <header>
        <customer_name>ACME, Inc.</customer_name>
        <customer_state>CA</customer_state>
    </header>
    <items>
        <item>
            <description>Product 1</description>
            <quantity>2</quantity>
            <unit_price>10</unit_price>
        </item>
        <item>
            <description>Product 2</description>
            <quantity>1</quantity>
            <unit_price>30</unit_price>
        </item>
    </items>
</invoice>
----
....
[tab,title="Output: XML"]
....

.Output
[source, xml, linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<invoice>
  <header>
    <customer_name>ACME, Inc.</customer_name>
    <customer_state>CA</customer_state>
  </header>
  <items>
    <item index="1">
      <description>Product 1</description>
      <quantity>2</quantity>
      <unit_price>10</unit_price>
      <discount>5%</discount>
      <subtotal>20</subtotal>
    </item>
    <item index="2">
      <description>Product 2</description>
      <quantity>1</quantity>
      <unit_price>30</unit_price>
      <discount>5%</discount>
      <subtotal>30</subtotal>
    </item>
  </items>
  <totals>
    <subtotal>47.5</subtotal>
    <tax>8.5%</tax>
    <total>51.5375</total>
  </totals>
</invoice>
----
....
------


== Group By

This example takes in an XML file that is grouped separating two types of elements: teachers and students, the transform uses the link:/mule-user-guide/v/3.8/dataweave-operators#group-by[*Group By* operation] to make it into an XML where the top level grouping is "class". Within each class, the students and teachers that are registered in it are listed.

The example goes through the whole set of elements in the input using both a link:/mule-user-guide/v/3.8/dataweave-operators#map-object[*map object* operation] and a link:/mule-user-guide/v/3.8/dataweave-operators#map[*map* operation]. Note that they differ in that map object processes both key and value of its input, rather than just the keys. It also uses the link:/mule-user-guide/v/3.8/dataweave-operators#filter[*filter* operation] to only show the attendees that have the class subject listed as a hobby. As each student may have multiple hobbies, the link:/mule-user-guide/v/3.8/dataweave-selectors#multi-value-selector[*Multi value* selector] is used to refer to them all.


=== Example Transformation

.DataWeave
[source,DataWeave, linenums]
----
％dw 1.0
％输出应用程序/ dw
---
教室：payload.school.teachers groupBy $ .subject mapObject（（teacherGroup，subject） - > {
     class：{
      名称：主题，
      位教师：{（teacherGroup map {
        老师：{
            名称：$ .name，
            姓氏：$。姓名
        }
      }）}，
      与会者：{（payload.school.students过滤器（$。*爱好包含主题）map {
        与会者：{
          名称：$ .name，
          姓氏：$。姓名
        }
      }）}
    }
})
----


[tabs]
------
[tab,title="Input: XML"]
....
.Input
[source, xml, linenums]
----
<school>
    <teachers>
        <teacher>
            <name>Mariano</name>
            <lastName>De Achaval</lastName>
            <subject>DW</subject>
        </teacher>
        <teacher>
            <name>Emiliano</name>
            <lastName>Lesende</lastName>
            <subject>DW</subject>
        </teacher>
        <teacher>
            <name>Leandro</name>
            <lastName>Shokida</lastName>
            <subject>Scala</subject>
        </teacher>
    </teachers>
    <students>
        <student>
            <name>Peter</name>
            <lastName>Parker</lastName>
            <hobby>DW</hobby>
            <hobby>Scala</hobby>
        </student>
        <student>
            <name>Homer</name>
            <lastName>Simpson</lastName>
            <hobby>Scala</hobby>
        </student>
    </students>
</school>
----

....
[tab,title="Output: JSON"]
....

.Output
[source, json, linenums]
----
{
  "classrooms": {
    "class": {
      "name": "DW",
      "teachers": [
        {
          "teacher": {
            "name": [
              "Mariano"
            ],
            "lastName": [
              "De Achaval"
            ]
          }
        },
        {
          "teacher": {
            "name": [
              "Emiliano"
            ],
            "lastName": [
              "Lesende"
            ]
          }
        }
      ],
      "attendees": [
        {
          "attendee": {
            "name": [
              "Peter"
            ],
            "lastName": [
              "Parker"
            ]
          }
        }
      ]
    },
    "class": {
      "name": "Scala",
      "teachers": [
        {
          "teacher": {
            "name": [
              "Leandro"
            ],
            "lastName": [
              "Shokida"
            ]
          }
        }
      ],
      "attendees": [
        {
          "attendee": {
            "name": [
              "Peter"
            ],
            "lastName": [
              "Parker"
            ]
          }
        },
        {
          "attendee": {
            "name": [
              "Homer"
            ],
            "lastName": [
              "Simpson"
            ]
          }
        }
      ]
    }
  }
}
----

....
------



== Multiple Inputs

In this example, there are three different input JSON files, these three all arrive in one single Mule message, occupying the payload and two link:/mule-user-guide/v/3.8/dataweave-selectors#flow-variables-from-a-mule-message[flow variables]. The payload contains an array of book objects, one flow variable has a set of currency exchange rates, and the other one a query. The transform filters the first input using the conditions passed in the third input, then performs a link:/mule-user-guide/v/3.8/dataweave-operators#map[`map`] to deal with each remaining object separately. Within this map, it defines two variables: *it* and *props*. Through the use of @, attributes are added into the XML tags. A second map operation inside the first one calculates the price of each book for each of the currencies provided in the second input. Another map operation displays each element in the `author` array as a separate <author></author> tag.


[TIP]
See link:/mule-user-guide/v/3.8/dataweave-selectors#flow-variables-from-a-mule-message[flow variables] for how to access flow variables from the input and link:/mule-user-guide/v/3.8/dataweave-selectors#attribute-selector-expressions[Attribute selector expressions] for how to access XML attributes in DataWeave.

=== Example Transformation

.DataWeave
[source,DataWeave, linenums]
----
％dw 1.0
％output application / xml
---
书籍：{
  （有效载荷过滤器$ .item.properties.year> flowVars.filterParameter.published使用地图后（它= $ .item，props = $ .item.properties）{
     book @（year：props.year）：{
      （flowVars.exchagneRate.USD map {
        价格@（货币：$ .currency）：$ .ratio * it.price
      }），
      标题：props.title，
      作者：{（props.author map {
        作者：$
      }）}
    }
  }）
}
----

[tabs]
------
[tab,title="Inputs"]
....

=== Input 1

.Input 1 - Payload
[source, json, linenums]
----
[
  {
    "item": {
      "type": "book",
      "price": 30,
      "properties": {
        "title": "Everyday Italian",
        "author": [
          "Giada De Laurentiis"
        ],
        "year": 2005
      }
    }
  },
  {
    "item": {
      "type": "book",
      "price": 29.99,
      "properties": {
        "title": "Harry Potter",
        "author": [
          "J K. Rowling"
        ],
        "year": 2005
      }
    }
  },
  {
    "item": {
      "type": "book",
      "price": 49.99,
      "properties": {
        "title": "XQuery Kick Start",
        "author": [
          "James McGovern",
          "Per Bothner",
          "Kurt Cagle",
          "James Linn",
          "Kurt Cagle",
          "Vaidyanathan Nagarajan"
        ],
        "year": 2003
      }
    }
  },
  {
    "item": {
      "type": "book",
      "price": 39.95,
      "properties": {
        "title": "Learning XML",
        "author": [
          "Erik T. Ray"
        ],
        "year": 2003
      }
    }
  }
]
----

=== Input 2

.Input 2 - FlowVariable exchangeRate
[source, json, linenums]
----
{
  "USD": [
    {"currency": "EUR", "ratio":0.92},
    {"currency": "ARS", "ratio":8.76},
    {"currency": "GBP", "ratio":0.66}
  ]
}
----

=== Input 3

.Input 3 - FlowVariable filterParamenter
[source, json, linenums]
----
{
  "publishedAfter": 2004
}
----
....
[tab,title="Output: XML"]
....

.Output
[source, xml, linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<books>
  <book year="2005">
    <price currency="EUR">27.6</price>
    <price currency="ARS">262.8</price>
    <price currency="GBP">19.8</price>
    <title>Everyday Italian</title>
    <authors>
      <author>Giada De Laurentiis</author>
    </authors>
  </book>
  <book year="2005">
    <price currency="EUR">27.5908</price>
    <price currency="ARS">262.7124</price>
    <price currency="GBP">19.7934</price>
    <title>Harry Potter</title>
    <authors>
      <author>J K. Rowling</author>
    </authors>
  </book>
</books>
----
....
------


== Merging Inputs

This example deals with an input that contains a collection of payloads, all grouped as a single Mule event. This kind of input can be produced by having a scatter-gather component in your flow before the transform component.

The first item that makes up the payload contains an array of "price" objects, uniquely identified by a `book id`, the second item that makes up the payload contains an array of "author" objects, also identified by a `book id`. This DataWeave transformation merges the two arrays into one, with author and price data by book. `book id` is used to match these.


=== Example Transformation

.DataWeave
[source,DataWeave, linenums]
----
％dw 1.0
％输出应用程序/ java
---

使用（id = $ .bookId） 有效载荷[0]映射{
 	 BOOKID：$ .bookId，
 	标题：$ .title伪，
 	年：$。年，
 	 isbn：$ .isbn，
 	价格：$ .price，
 	（有效载荷[1]过滤器（$。* bookId包含id）map {
 		作者：$作者
     }）
  }

----

[tabs]
------
[tab,title="Inputs"]
....

=== Input 1

.Input 1 - Payload[0]
[source, json, linenums]
----
[
  { "bookId":"101",
    "title":"world history",
    "year":"2017",
    "isbn":"11111",
    "price":"19.99"
  },
  {
    "bookId":"202",
    "title":"the great outdoors",
    "year":"2016",
    "isbn":"22222",
    "price":"15.99"
  }
]
----

=== Input 2

.Input 2 - Payload[1]
[source, json, linenums]
----
[
  {
    "bookId":"101",
    "author":"john doe"
  },
  {
    "bookId":"202",
    "author":"jane doe"
  }
]
----

....
[tab,title="Output: JSON"]
....

.Output
[source, json, linenums]
----
[
  {
    "bookId": "101",
    "title": "world history",
    "year": "2017",
    "isbn": "11111",
    "price": "19.99",
    "author": "john doe"
  },
  {
    "bookId": "202",
    "title": "the great outdoors",
    "year": "2016",
    "isbn": "22222",
    "price": "15.99",
    "author": "jane doe"
  }
]
----
....
------

[NOTE]
The *sample data* section of the Transform message component doesn't allow you to provide it a collection of multiple payloads as a sample. The only way to test this example is running it.


== Remove XML Attributes

As a more advanced use case, you may want to remove specific attributes from within an XML tag that are known to contain sensitive data.

The example defines a link:/mule-user-guide/v/3.8/dataweave-types#functions-and-lambdas[function] in the link:/mule-user-guide/v/3.8/dataweave-language-introduction#dataweave-header[dataweave header] and then calls it on the body. It goes through the whole set of elements in the input using  a link:/mule-user-guide/v/3.8/dataweave-operators#map-object[`mapObject`] operator. Note that it differs from the map operation in that map object processes both key and value of its input, rather than just the keys. It also uses the link:/mule-user-guide/v/3.8/dataweave-language-introduction#when-otherwise[`when` and `otherwise`] operators to pick out only instances where an XML attribute exists, and to do nothing otherwise.
It also uses the link:/mule-user-guide/v/3.8/dataweave-operators#match[`match` ] operator.

See link:/mule-user-guide/v/3.8/dataweave-selectors#attribute-selector-expressions[Attribute selector expressions] for how to access XML attributes in DataWeave.

=== Example Transformation

.DataWeave
[source,Dataweave,linenums]
----
％dw 1.0
％输出应用程序/ dw
％var removeAttribute =（element，attrName） - >
元素mapObject {
$$ {@} {$$} @（（（$$。@  -  attrName）$$。@？否则{}））：$ match {
    ：object  - > removeAttribute（$，attrName），
    默认 - > $
  }
}
---

removeAttribute（有效内容，"password"）
----

[tabs]
------
[tab,title="Input: XML"]
....
.Input
[source,xml,linenums]
----
<users>
  <user username="Julian" password="1234"/>
  <user username="Mariano" password="4321"/>
</users>
----


....
[tab,title="Output: JSON"]
....
.Output
[source,json,linenums]
----
{
  users @(): {
    user @(
      username: "Julian"
    ): "",
    user @(
      username: "Mariano"
    ): ""
  }
}
----
....
------

== Output self-closing XML tags

When producing an output in link:/mule-user-guide/v/3.8/dataweave-formats#xml[XML], DataWeave by default outputs every value as enclosed between an opening and a closing tag:

[source,xml,linenums]
----
   <parentElement>
     <emptyElement1> 15 </emptyElement1>
     <emptyElement2> 1 </emptyElement2>
     <emptyElement3> 8 </emptyElement3>
   </parentElement>
----

In case you have empty fields that don't hold any values within, you might find that you instead want to output a single tag that self-closes. You can set the DW output directive so that your transform generates an output that follows this style for each case. You configure this by setting the `inlineCloseOn` property to "empty".

=== Example Transformation

.DataWeave
[source,Dataweave,linenums]
----
％dw 1.0
％output application / xml inlineCloseOn = "empty"
---
有效载荷


----

[tabs]
------
[tab,title="Input: JSON"]
....
{ "customer":{

    "userName": "John Doe",
    "password":{},
    "status":"active",
    "lastLogin":{}
  }
}
----


....
[tab,title="Output: XML"]
....
.Output
[source,xml,linenums]
----
<?xml version='1.0' encoding='UTF-8'?>
<customer>
  <userName>John Doe</userName>
  <password/>
  <status>active</status>
  <lastLogin/>
</customer>
----
....
------

[TIP]
See more XML reader and writer properties on link:/mule-user-guide/v/3.8/dataweave-formats#xml[DataWeave formats].


== Configure CSV Reader

DataWeave supports CSV inputs and outputs, by configuring the reader and writer properties, you can adapt it to different conventions regarding separations, line breaks, etc. Other formats also allow for this kind of configuration. See link:/anypoint-studio/v/6/input-output-structure-transformation-studio-task[To Define Input and Output Structure of a Transformation] for how to do this on the UI, or look at the link:/mule-user-guide/v/3.8/dataweave-xml-reference#reader-configuration[DataWeave XML Reference] for the required XML syntax. You can also see a full reference of the reader properties available with CSV format on link:/mule-user-guide/v/3.8/dataweave-formats#csv[DataWeave formats].

Reader properties are set as part of the XML `dw:transform-message` component, whilst writer properties are specified in the DataWeave code itself, as part of the output directive. You can see a full reference to the writer properties available with CSV format on link:/mule-user-guide/v/3.8/dataweave-formats#writer-properties[DataWeave formats].

This example takes a CSV file that is formatted in a certain way (with `;` as a separator) and outputs another CSV file that is formatted differently (with `,` as a separator, and all values quoted).

=== Example Transformation

.XML
[source,xml, linenums]
----
<dw:transform-message metadata:id="ab7c919b-c57c-47da-a1e7-207a7e571341" doc:name="Transform Message">
     <dw:input-payload mimeType="application/csv" doc:sample="sample_data/list_csv.csv">
         <dw:reader-property name="header" value="false"/>
         <dw:reader-property name="separator" value=";"/>
     </dw:input-payload>
     <dw:set-payload>
       <![CDATA[
%dw 1.0
%output application/csv separator = "," , header = false, quoteValues = true
---
payload
      ]]>
    </dw:set-payload>
</dw:transform-message>
----

Note that the code above includes not just the DW transformation, but the XML of the Transform Message component that contains it, to display the reader properties configured in it.

[tabs]
------
[tab,title="Input: CSV"]
....

.Input
[source, csv, linenums]
----
name;address;phone
George Harrisson; 1234 Abbey Road, London; 12341123
David Gilmour; 3434 Diamond st., Dark side of the moon; 12341234
Steven Wilson; 13/16 Raven st., Somewhere but not Here; 1234567
----

....
[tab,title="Output: CSV"]
....

.Output
[source, xml, linenums]
----
"name","address","phone"
"George Harrisson"," 1234 Abbey Road, London"," 12341123"
"David Gilmour"," 3434 Diamond st., Dark side of the moon"," 12341234"
"Steven Wilson"," 13/16 Raven st., Somewhere but not Here"," 1234567"
----

....
------


== Parse Dates with Different Separators

Suppose that you want to include a date field that admits using different characters as separators between the elements of the date, and want DataWeave to be able to parse them as if they all were the same. For this example, imagine that you want to accept these three formats:

* `26-JUL-2016`
* `26/JUL/2016`
* `26.JUL.2016`

To do this, you can normalize the input with the link:/mule-user-guide/v/3.8/dataweave-operators#replace[replace] operator so that they all match a single pattern, and then turn the resulting string to a date with link:/mule-user-guide/v/3.8/dataweave-operators#coerce-to-date[coerce to date].

To improve the clarity in your code, you can easily abstract the normalizing of your string into custom a link:/mule-user-guide/v/3.8/dataweave-types#functions-and-lambdas[function], declaring it only once on your DW header, and then using it as many times as necessary by simply referencing this function.

=== Example Transformation

This is what the function for this example would look like:

.DataWeave
[source,Dataweave,linenums]
----
%function normalize(date) date replace "/" with "-" replace "." with "-"
----

You can declare this function on the header of a DW script and then simply call it from anywhere in the DW body. The example below shows the full DataWeave transform for doing this:

.DataWeave
[source,Dataweave,linenums]
----
%dw 1.0
%output text/xml
%function normalize(date) date replace "/" with "-" replace "." with "-"
---
{
dates : {
date1: normalize("26-JUL-16") as :date {format: "d-MMM-yy"} as :string {format: "yyyy-MM-dd"},
date2: normalize("26/JUL/16") as :date {format: "d-MMM-yy"} as :string {format: "yyyy-MM-dd"},
date3: normalize("26.JUL.16") as :date {format: "d-MMM-yy"} as :string {format: "yyyy-MM-dd"}
  }
}
----

This example only deals with dates that use different separator characters, for a more advanced use case that deals with different date patterns, see <<Conditional Date Parsing>>

== Conditional Date Parsing

Suppose that you want to include a date field that admits different formats, and want DataWeave to be able to parse each accordingly. For this example, imagine that you want to accept these three formats:

* Sun, 06 Nov 1994 08:49:37 GMT = `E, d LLL u H:m:s O`
* Sun Nov 6 08:49:37 1994 = `cccc, d-LLL-u H:m:s O`
* Sunday, 06-Nov-94 08:49:37 GMT = `E LLL d H:m:s u`

Start out by writing a regular expression to match each of them:

* Sun, 06 Nov 1994 08:49:37 GMT = `/^[A-z][A-z][A-z],/`
* Sun Nov 6 08:49:37 1994 = `/^[A-z][A-z][A-z]\s/`
* Sunday, 06-Nov-94 08:49:37 GMT = This will be the default


You can use these regular expressions in a DW link:/mule-user-guide/v/3.8/dataweave-types#functions-and-lambdas[function] that first evaluates a string to see which regular expression it matches, and then converts it through the the corresponding operation. This function should do the following:

. Take the input string as argument
. Match it with regular expressions in order to determine which format it's in
. Run the link:/mule-user-guide/v/3.8/dataweave-operators#coerce-to-date[coerce to date] operator with the corresponding properties
. Return a date time object

=== Example Transformation

This is what the function looks like:

.DataWeave
[source,Dataweave,linenums]
----
%var parseDate = (dateStr) -> dateStr as :localdatetime {format: "E, d LLL u H:m:s O"} when (dateStr contains /^[A-z][A-z][A-z],/) otherwise (dateStr as :localdatetime {format: "E LLL d H:m:s u"} when (dateStr contains /^[A-z][A-z][A-z]\s/) otherwise dateStr as :localdatetime {format: "cccc, d-LLL-u H:m:s O"})
----

You can declare this function on the header of a DW script and then simply call it from anywhere in the DW body like so:


.DataWeave
[source,Dataweave,linenums]
----
%dw 1.0
%output application/json
%var parseDate = (dateStr) -> dateStr as :localdatetime {format: "E, d LLL u H:m:s O"} when (dateStr contains /^[A-z][A-z][A-z],/) otherwise (dateStr as :localdatetime {format: "E LLL d H:m:s u"} when (dateStr contains /^[A-z][A-z][A-z]\s/) otherwise dateStr as :localdatetime {format: "cccc, d-LLL-u H:m:s O"})
---
date: parseDate(payload.dateString)
----





== Create Mule Config

This example use of DataWeave does not take any input--rather, it simply creates an XML structure out of hard-coded instructions, which reference several external sources using certain namespace directives. What you end up with is a set of XML tags mirroring the structure of a Mule application XML file, including attributes that go inside these tags through the use of `@`. 

[TIP]
See link:/mule-user-guide/v/3.8/dataweave-selectors#attribute-selector-expressions[Attribute selector expressions] for how to access XML attributes in DataWeave.

[tabs]
------
[tab,title="DataWeave Code"]
....

=== Example Transformation

.DataWeave
[source,DataWeave,linenums]
----
%dw 1.0
%output application/xml encoding="UTF-8"
%namespace http http://www.mulesoft.org/schema/mule/http
%namespace as2 http://www.mulesoft.org/schema/mule/as2
%namespace spring http://www.springframework.org/schema/beans
%namespace doc http://www.mulesoft.org/schema/mule/documentation
%namespace sftp http://www.mulesoft.org/schema/mule/sftp
---

mule: {

  http#connector @(name:"HTTP_HTTPS",
                                  cookieSpec:"netscape",
                                  alidateConnections:"true",
                                sendBufferSize:"0",
                                receiveBufferSize:"0",
                                receiveBacklog:"0",
                                clientSoTimeout:"10000",
                                serverSoTimeout:"10000",
                                    socketSoLinger:"0",
                                doc#name:"HTTP-HTTPS"
  ): {},

  http#endpoint @(exchange-pattern:"request-response",
                                host:"localhost",
                                    port:"\${http.port}",
                                connector-ref:"HTTP_HTTPS",
                                method:"POST",
                                    name:"http-receive-endpoint",
                                doc#name:"HTTP"
  ): {},

  http#endpoint @(exchange-pattern:"request-response",
                                host:"btsci-dev.cloudapp.net",
                                    port:"80",
                                connector-ref:"HTTP_HTTPS",
                                method:"POST",
                                name:"http-send-endpoint",
                                    doc#name:"HTTP",
                                path:"as2tests/scenario1/BTSHTTPReceive.dll"
  ): {},

  as2#config @(name:"receive-as2-config",
                                 httpEndpointRef:"http-receive-endpoint",
                                     doc#name:"AS2"
  ): {},

  as2#config @(name:"send-as2-config",
                                httpEndpointRef:"http-send-endpoint",
                                    doc#name:"AS2"
  ): {},


  flow @(name:"receive-flow"): {

            as2#receive @(config-ref:"receive-as2-config",
                                  doc#name:"Receive EDI over AS2",
                                            keyStorePassword:"passw0rd",
                                  keyStorePath:"myPartner.p12"): {},
            sftp#outbound-endpoint @(exchange-pattern:"one-way",
                                            host:"dev.modusintegration.com",
                                  port:"22",
                                  responseTimeout:"10000",
                                            doc#name:"Save EDI doc",
                                  password:"pa\$\$w0rd",
                                  path:"/mule/inbox",
                                            user:"guest"): {}
  },

  flow @(name:"send-flow"):{
          sftp#inbound-endpoint @(host:"dev.modusintegration.com",
                            port:"22",
                    responseTimeout:"10000",
                    doc#name:"Read EDI doc",
                    password:"\$pa\$\$w0rd",
                            path:"/mule/outbox",
                    user:"guest"  ):{},

    as2#send @(config-ref:"send-as2-config",
                      as2From:"myPartner",
                            as2To:"myCompany",
                      doc#name:"Send EDI over AS2",
                      encrypt:"true",
                            keyStorePassword:"passw0rd",
                      keyStorePath:"myPartner.p12",
                      sign:"true"):{}
  }

}
----
....

[tab,title="Output: XML"]
....
.Output
[source, xml, linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns:http="http://www.mulesoft.org/schema/mule/http" xmlns:as2="http://www.mulesoft.org/schema/mule/as2"
      xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
      xmlns:sftp="http://www.mulesoft.org/schema/mule/sftp">
    <http:connector name="HTTP_HTTPS" cookieSpec="netscape" alidateConnections="true" sendBufferSize="0" receiveBufferSize="0" receiveBacklog="0" clientSoTimeout="10000" serverSoTimeout="10000" socketSoLinger="0" doc:name="HTTP-HTTPS"></http:connector>
    <http:endpoint exchange-pattern="request-response" host="localhost" port="${http.port}" connector-ref="HTTP_HTTPS" method="POST" name="http-receive-endpoint" doc:name="HTTP"></http:endpoint>
    <http:endpoint exchange-pattern="request-response" host="btsci-dev.cloudapp.net" port="80" connector-ref="HTTP_HTTPS" method="POST" name="http-send-endpoint" doc:name="HTTP" path="as2tests/scenario1/BTSHTTPReceive.dll"></http:endpoint>
    <as2:config name="receive-as2-config" httpEndpointRef="http-receive-endpoint" doc:name="AS2"></as2:config>
    <as2:config name="send-as2-config" httpEndpointRef="http-send-endpoint" doc:name="AS2"></as2:config>
    <flow name="receive-flow">
        <as2:receive config-ref="receive-as2-config" doc:name="Receive EDI over AS2" keyStorePassword="passw0rd" keyStorePath="myPartner.p12"></as2:receive>
        <sftp:outbound-endpoint exchange-pattern="one-way" host="dev.modusintegration.com" port="22" responseTimeout="10000" doc:name="Save EDI doc" password="pa$$w0rd" path="/mule/inbox" user="guest"></sftp:outbound-endpoint>
    </flow>
    <flow name="send-flow">
        <sftp:inbound-endpoint host="dev.modusintegration.com" port="22" responseTimeout="10000" doc:name="Read EDI doc" password="$pa$$w0rd" path="/mule/outbox" user="guest"></sftp:inbound-endpoint>
        <as2:send config-ref="send-as2-config" as2From="myPartner" as2To="myCompany" doc:name="Send EDI over AS2" encrypt="true" keyStorePassword="passw0rd" keyStorePath="myPartner.p12" sign="true"></as2:send>
    </flow>
</mule>
----
....
------


== Create Mule POM

This example does not take any input in, it simply creates an XML output out of hard-coded instruction. It references several external sources through namespace directives and defines a version as a constant in the header, that is then referenced in the body. It creates a set of XML tags that replicate the structure of a Mule POM file, including attributes inside these tags that are added through the use of @ and references to a variable.

[TIP]
See link:/mule-user-guide/v/3.8/dataweave-selectors#attribute-selector-expressions[Attribute selector expressions] for how to access XML attributes in DataWeave.

=== Example Transformation

[tabs]
------
[tab,title="DataWeave"]
....

.DataWeave
[source,DataWeave, linenums]
----
%dw 1.0
%output application/xml
%namespace xsi http://www.w3.org/2001/XMLSchema-instance
%var modelVersion = "4.0.0"
---
{
    project: {

      modelVersion: modelVersion,
    groupId: "com.mycompany",
    version: "1.0.0-SNAPSHOT",
    packaging: "mule",
    name: "Mavenito",

    properties: {
        "project.build.sourceEncoding": "UTF-8",
      "project.reporting.outputEncoding": "UTF-8",
      "mule.version": "3.6.0",
      "mule.tools.version": "1.0"
    },

    build: {
        plugins: {
          plugin: {
            groupId: "org.mule.tools.maven",
          artifactId: "mule-app-maven-plugin",
          version: "\${mule.tools.version}",
          extensions: true,
          configuration: {
                        copyToAppsDirectory: true
          }
        },
        plugin: {
          artifactId: "maven-assembly-plugin",
                    version: "2.2.1",
                  configuration: {
                            descriptorRefs: {
                                descriptorRef: "project"
                }
             }
        },
        plugin: {
          groupId: "org.mojohaus",
                     artifactId: "build-helper-maven-plugin",
                    version:1.7,
                    executions: {
                            execution: {
                                id: "add-resource",
                                phase: "generate-resources",
                                goals: {
                                    goal: "add-resource"
                                },
                                configuration: {
                                        resources: {
                                            resource: {
                                                directory: "src/main/app/"
                                            },
                                            resource: {
                                                directory: "mappings/"
                      }
                                    }
                                }
                            },
                    configuration: {
                            resources: {
                 resource: {
                         directory: "src/main/api/"
                                    }
              }
          }
        }
      },
      plugin: {
          groupId: "org.apache.maven.plugins",
        artifcatId: "maven-dependency-plugin",
        version: "2.4",
        executions: {
              execution: {
                  id: "copy-clover-plugins",
              phase: "validate",
              goals: {
                  goal: "copy"
              },
              configuration: {
                 overWriteReleases: true,
                 overWriteSnapshots: true,
                 overWriteIfNewer: true,
                 stripVersion: true,
                 outputDirectory: "\${project.build.testOutputDirectory}"
              },
              artifactItems: {
                                artifactItem: {
                           groupId: "com.cloveretl",
                        artifactId: "cloveretl-engine",
                                        version: "\${mule.version}",
                                        type: "zip"
                    }
                 }
              }
        }
      },
      plugin: {
          artifactId: "maven-antrun-plugin",
                version: "1.7",
        executions: {
               execution: {
                        phase: "compile",
                        configuration: {
                            tasks: {
                                    unzip @(dest: "\${project.build.testOutputDirectory}",
                          src: "\${project.build.testOutputDirectory}/cloveretl-engine.zip"): {}
                        }
           },
           goals: {
                            goal: "run"
           }
         }
           }
      }
    }
  },

  dependencies: {
    dependency: {
        groupId: "com.mulesoft.muleesb",
      artifactId: "mule-core-ee",
      version: "\${mule.version}",
      scope: "provided"
    },
    dependency: {
        groupId: "com.mulesoft.muleesb.modules",
      artifactId: "mule-module-spring-config-ee",
      version: "\${mule.version}",
      scope: "provided"
    },
    dependency: {
        groupId: "org.mule.transports",
      artifactId: "mule-transport-file",
      version: "\${mule.version}",
      scope: "provided"
    },
    dependency: {
        groupId: "org.mule.transports",
      artifactId: "mule-transport-http",
      version: "\${mule.version}",
      scope: "provided"
    },
    dependency: {
        groupId: "com.mulesoft.muleesb.transports",
      artifactId: "mule-transport-jdbc-ee",
      version: "\${mule.version}",
      scope: "provided"
    },
    dependency: {
        groupId: "com.mulesoft.muleesb.transports",
      artifactId: "mule-transport-jms-ee",
      version: "\${mule.version}",
      scope: "provided"
    },
    dependency: {
        groupId: "org.mule.transports",
      artifactId: "mule-transport-vm",
      version: "\${mule.version}",
      scope: "provided"
    },
    dependency: {
        groupId: "org.mule.modules",
      artifactId: "mule-module-scripting",
      version: "\${mule.version}",
      scope: "provided"
    },
    dependency: {
        groupId: "org.mule.modules",
      artifactId: "mule-module-xml",
      version: "\${mule.version}",
      scope: "provided"
    },
    dependency: {
        groupId: "org.mule.tests",
      artifactId: "mule-tests-functional",
      version: "\${mule.version}",
      scope: "provided"
    },
    dependency: {
        groupId: "com.cloveretl",
      artifactId: "cloveretl-engine",
      version: "\${mule.version}",
      scope: "provided"
    }
    },

  repositories: {
      repository: {
        id: "Central",
      name: "Central",
      url: "http://repo1.maven.org/maven2/",
      layout: "default"
    },
    repository: {
        id: "mulesoft-releases",
      name: "MuleSoft Releases Repository",
      url: "http://repository.mulesoft.org/releases/",
      layout: "default"
    },
    repository: {
        id: "mulesoft-snapshots",
      name: "MuleSoft Snapshots Repository",
      url: "http://repository.mulesoft.org/snapshots/",
      layout: "default"
    }
  },


  pluginRepositories: {
    pluginRepository: {
                id: "mulesoft-release",
                name: "mulesoft release repository",
                layout: "default",
        url: "http://repository.mulesoft.org/releases/",
                 snapshots: {
                enabled: false
                }
    }
  }

 }
}
----
....
[tab,title="Output: XML"]
....
.Output
[source, xml, linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.mycompany</groupId>
  <version>1.0.0-SNAPSHOT</version>
  <packaging>mule</packaging>
  <name>Mavenito</name>
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    <mule.version>3.6.0</mule.version>
    <mule.tools.version>1.0</mule.tools.version>
  </properties>
  <build>
    <plugins>
      <plugin>
        <groupId>org.mule.tools.maven</groupId>
        <artifactId>mule-app-maven-plugin</artifactId>
        <version>${mule.tools.version}</version>
        <extensions>true</extensions>
        <configuration>
          <copyToAppsDirectory>true</copyToAppsDirectory>
        </configuration>
      </plugin>
      <plugin>
        <artifactId>maven-assembly-plugin</artifactId>
        <version>2.2.1</version>
        <configuration>
          <descriptorRefs>
            <descriptorRef>project</descriptorRef>
          </descriptorRefs>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.mojohaus</groupId>
        <artifactId>build-helper-maven-plugin</artifactId>
        <version>1.7</version>
        <executions>
          <execution>
            <id>add-resource</id>
            <phase>generate-resources</phase>
            <goals>
              <goal>add-resource</goal>
            </goals>
            <configuration>
              <resources>
                <resource>
                  <directory>src/main/app/</directory>
                </resource>
                <resource>
                  <directory>mappings/</directory>
                </resource>
              </resources>
            </configuration>
          </execution>
          <configuration>
            <resources>
              <resource>
                <directory>src/main/api/</directory>
              </resource>
            </resources>
          </configuration>
        </executions>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifcatId>maven-dependency-plugin</artifcatId>
        <version>2.4</version>
        <executions>
          <execution>
            <id>copy-clover-plugins</id>
            <phase>validate</phase>
            <goals>
              <goal>copy</goal>
            </goals>
            <configuration>
              <overWriteReleases>true</overWriteReleases>
              <overWriteSnapshots>true</overWriteSnapshots>
              <overWriteIfNewer>true</overWriteIfNewer>
              <stripVersion>true</stripVersion>
              <outputDirectory>${project.build.testOutputDirectory}</outputDirectory>
            </configuration>
            <artifactItems>
              <artifactItem>
                <groupId>com.cloveretl</groupId>
                <artifactId>cloveretl-engine</artifactId>
                <version>${mule.version}</version>
                <type>zip</type>
              </artifactItem>
            </artifactItems>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <artifactId>maven-antrun-plugin</artifactId>
        <version>1.7</version>
        <executions>
          <execution>
            <phase>compile</phase>
            <configuration>
              <tasks>
                <unzip dest="${project.build.testOutputDirectory}" src="${project.build.testOutputDirectory}/cloveretl-engine.zip"></unzip>
              </tasks>
            </configuration>
            <goals>
              <goal>run</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
  <dependencies>
    <dependency>
      <groupId>com.mulesoft.muleesb</groupId>
      <artifactId>mule-core-ee</artifactId>
      <version>${mule.version}</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>com.mulesoft.muleesb.modules</groupId>
      <artifactId>mule-module-spring-config-ee</artifactId>
      <version>${mule.version}</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>org.mule.transports</groupId>
      <artifactId>mule-transport-file</artifactId>
      <version>${mule.version}</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>org.mule.transports</groupId>
      <artifactId>mule-transport-http</artifactId>
      <version>${mule.version}</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>com.mulesoft.muleesb.transports</groupId>
      <artifactId>mule-transport-jdbc-ee</artifactId>
      <version>${mule.version}</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>com.mulesoft.muleesb.transports</groupId>
      <artifactId>mule-transport-jms-ee</artifactId>
      <version>${mule.version}</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>org.mule.transports</groupId>
      <artifactId>mule-transport-vm</artifactId>
      <version>${mule.version}</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>org.mule.modules</groupId>
      <artifactId>mule-module-scripting</artifactId>
      <version>${mule.version}</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>org.mule.modules</groupId>
      <artifactId>mule-module-xml</artifactId>
      <version>${mule.version}</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>org.mule.tests</groupId>
      <artifactId>mule-tests-functional</artifactId>
      <version>${mule.version}</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>com.cloveretl</groupId>
      <artifactId>cloveretl-engine</artifactId>
      <version>${mule.version}</version>
      <scope>provided</scope>
    </dependency>
  </dependencies>
  <repositories>
    <repository>
      <id>Central</id>
      <name>Central</name>
      <url>http://repo1.maven.org/maven2/</url>
      <layout>default</layout>
    </repository>
    <repository>
      <id>mulesoft-releases</id>
      <name>MuleSoft Releases Repository</name>
      <url>http://repository.mulesoft.org/releases/</url>
      <layout>default</layout>
    </repository>
    <repository>
      <id>mulesoft-snapshots</id>
      <name>MuleSoft Snapshots Repository</name>
      <url>http://repository.mulesoft.org/snapshots/</url>
      <layout>default</layout>
    </repository>
  </repositories>
  <pluginRepositories>
    <pluginRepository>
      <id>mulesoft-release</id>
      <name>mulesoft release repository</name>
      <layout>default</layout>
      <url>http://repository.mulesoft.org/releases/</url>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
    </pluginRepository>
  </pluginRepositories>
</project>
----
....
------


== Pass Functions as Arguments


The following example makes all "keys" lower case. The link:/mule-user-guide/v/3.8/dataweave-language-introduction#the-dataweave-header[DataWeave header] defines a link:/mule-user-guide/v/3.8/dataweave-types#functions-and-lambdas[function] that receives another function as an argument and then calls that function in the body, applying itself to the keys and not the values it processes. The function that is sent as an argument is a simple one that uses the link:/mule-user-guide/v/3.8/dataweave-operators#lower[`lower`] operator to set the specified text to lower case.

The example goes through the whole set of elements in the input using a link:/mule-user-guide/v/3.8/dataweave-operators#map-object[`mapObject`] operator. It also uses the link:/mule-user-guide/v/3.8/dataweave-operators#dataweave-language-introduction#when-otherwise[`when` and `otherwise`] operators to pick out only instances _when_ an XML attribute exists, and do nothing _otherwise_.
It also uses the link:/mule-user-guide/v/3.8/dataweave-operators#match[`match` ] operator.

////
mapKeys???????
////

See link:/mule-user-guide/v/3.8/dataweave-selectors#attribute-selector-expressions[Attribute selector expressions] on how to access XML attributes in DataWeave.

=== Example Transformation

.DataWeave
[source,dataweave,linenums]
----
%dw 1.0
%output application/xml
%function mapKeys(element, func)
  element match {
    obj is :object -> obj mapObject {
      "$(func($$))" @(($$.@ when $.@? otherwise {}) ): mapKeys($, func)
    },
    default -> element
  }
---
mapKeys(payload, ((key) ->(lower key)))
----

[tabs]
------
[tab,title="Input: XML"]
....
.Input
[source,xml,linenums]
----
<CATALOG>
  <CD>
    <TITLE name="foo">Empire Burlesque</TITLE>
    <ARTIST>Bob Dylan</ARTIST>
    <COUNTRY>USA</COUNTRY>
    <COMPANY>Columbia</COMPANY>
    <PRICE>10.90</PRICE>
    <YEAR>1985</YEAR>
  </CD>
  <CD>
    <TITLE>Hide your heart</TITLE>
    <ARTIST>Bonnie Tyler</ARTIST>
    <COUNTRY>UK</COUNTRY>
    <COMPANY>CBS Records</COMPANY>
    <PRICE>9.90</PRICE>
    <YEAR>1988</YEAR>
  </CD>
</CATALOG>
----
....


[tab,title="Output: XML"]
....
.Output
[source,xml,linenums]
----
<?xml version='1.0' encoding='US-ASCII'?>
<catalog>
  <cd>
    <title name="foo">Empire Burlesque</title>
    <artist>Bob Dylan</artist>
    <country>USA</country>
    <company>Columbia</company>
    <price>10.90</price>
    <year>1985</year>
  </cd>
  <cd>
    <title>Hide your heart</title>
    <artist>Bonnie Tyler</artist>
    <country>UK</country>
    <company>CBS Records</company>
    <price>9.90</price>
    <year>1988</year>
  </cd>
</catalog>
----
....
------


== Dynamic Mapping Based on a Definition

Based on a mapping definition, stored for instance in a DB table, you can dynamically execute a transformation. Here you have two inputs, one coming in via the payload, the other from a `flowVariable` called `mapping`.

* The whole set of elements in the input is mapped using a link:/mule-user-guide/v/3.8/dataweave-operators#map[`map`] operator.
* The example also uses the link:/mule-user-guide/v/3.8/dataweave-language-introduction#default[`default`] operator.


[NOTE]
Note that for this example to work, on the payload input you must set the reader configuration so that the 'nullValueOn' attribute is "empty". See link:/anypoint-studio/v/6/input-output-structure-transformation-studio-task[To Define Input and Output Structure of a Transformation].

=== Example Transformation

.DataWeave
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
%var applyMapping = (input, mappingsDef) ->
{
  (mappingsDef map ((mappingDef) -> {
  (mappingDef.target) : input[mappingDef.source] default mappingDef.default
  }))
}
---
payload.sfdc_users.*sfdc_user map ((user) -> applyMapping(user, mapping))
----

[tabs]
------
[tab,title="Inputs"]
....

.Input - Payload
[source,xml, linenums]
----
<sfdc_users>
    <sfdc_user>
      <sfdc_name>Mariano</sfdc_name>
      <sfdc_last_name>Achaval</sfdc_last_name>
      <sfdc_employee>true</sfdc_employee>
    </sfdc_user>
    <sfdc_user>
      <sfdc_name>Julian</sfdc_name>
      <sfdc_last_name>Esevich</sfdc_last_name>
      <sfdc_employee>true</sfdc_employee>
    </sfdc_user>
    <sfdc_user>
      <sfdc_name>Leandro</sfdc_name>
      <sfdc_last_name>Shokida</sfdc_last_name>
    </sfdc_user>
</sfdc_users>
----

.Input - flowVariable Mapping
[source,json, linenums]
----
[
  {
    "source": "sfdc_name",
    "target": "name",
    "default": "---"
  },
  {
    "source": "sfdc_last_name",
    "target": "lastName",
    "default": "---"
  },
  {
    "source": "sfdc_employee",
    "target": "user",
    "default": true
  }
]
----


....

[tab,title="Output: JSON"]
....
.Output
[source,json,linenums]
----
[
  {
    "name": "---",
    "lastName": "---",
    "user": true
  }
]
----
....
------


== Conditional list reduction via a function

When presented with nested lists of data, you often need to `flatten` the data for a simplified output, extracting only the values required. Here you have a set of JSON data that returns a nested set of `interests` for a user and within are further nested sets. Certain values from the nested sets `tags` and `contenttypes` are needed to be extracted, with a conditional check to ensure `contenttypes` is present.

* The whole set of elements in the input is mapped using a link:/mule-user-guide/v/3.8/dataweave-operators#map[`map`] operator.
* This example uses the link:/mule-user-guide/v/3.8/dataweave-operators#reduce[`reduce`] operator.
* This example also uses the link:/mule-user-guide/v/3.8/dataweave-language-introduction#when-otherwise[`when`] operator to conditionally display the last field.
* This example also uses the link:/mule-user-guide/v/3.8/dataweave-operators#split-by[`splitBy`] operator to parse the input.
* Finally this example takes advantage of the ability to define a link:/mule-user-guide/v/3.8/dataweave-types#functions-and-lambdas[`function`] for re-use.


=== Example Transformation

.DataWeave
[source,dataweave,linenums]
----
%dw 1.0
%output application/json
%function reduceMapFor(data) data reduce (($$ splitBy ":")[0] ++ "," ++ ($ splitBy ":")[0])
---
payload.results map
	{
		email: $.profile.email,
		name: $.profile.firstName,
	 	tags: reduceMapFor($.data.interests.tags[0]),
	 	(contenttypes: reduceMapFor($.data.interests.contenttypes[0]))  when (sizeOf $.data.interests.contenttypes[0]) > 0
	}
----

[tabs]
------
[tab,title="Input: JSON"]
....
=== Input - Payload

[source,json, linenums]
----
{
  "results": [
    {
      "profile": {
        "firstName": "john",
        "lastName": "doe",
        "email": "johndoe@demo.com"
      },
      "data": {
        "interests": [
          {
            "language": "English",
            "tags": [
              "digital-strategy:Digital Strategy",
              "innovation:Innovation"
            ],
            "contenttypes": []
          }
        ]
      }
    },
    {
      "profile": {
        "firstName": "jane",
        "lastName": "doe",
        "email": "janedoe@demo.com"
      },
      "data": {
        "interests": [
          {
            "language": "English",
            "tags": [
              "tax-reform:Tax Reform",
              "retail-health:Retail Health"
            ],
            "contenttypes": [
              "News",
              "Analysis",
              "Case studies",
              "Press releases"
            ]
          }
        ]
      }
    }
  ],
  "objectsCount": 2,
  "totalCount": 2,
  "statusCode": 200,
  "errorCode": 0,
  "statusReason": "OK"
}
----


....

[tab,title="Output: JSON"]
....
.Output
[source,json,linenums]
----
[
  {
    "email": "johndoe@demo.com",
    "name": "john",
    "tags": "digital-strategy,innovation"
  },
  {
    "email": "janedoe@demo.com",
    "name": "jane",
    "tags": "tax-reform,retail-health",
    "contenttypes": "News,Analysis,Case studies,Press releases"
  }
]
----
....
------


== See Also

*  link:/mule-user-guide/v/3.8/dataweave-quickstart[DataWeave quickstart guide]
*  link:/anypoint-studio/v/6/transform-message-component-concept-studio[About Transform Message Component]
*  link:/mule-user-guide/v/3.8/dataweave-language-introduction[DataWeave Language Introduction]
*  link:/mule-user-guide/v/3.8/dataweave-operators[DataWeave Operators]
*  link:/mule-user-guide/v/3.8/dataweave-types[DataWeave Types]
*  link:/mule-user-guide/v/3.8/dataweave-formats[DataWeave Formats]
*  link:/mule-user-guide/v/3.8/dataweave-selectors[DataWeave Selectors]
*  link:/mule-user-guide/v/3.8/mel-dataweave-functions[MEL DataWeave Functions]
