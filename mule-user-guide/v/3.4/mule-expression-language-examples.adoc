=  Mule表达式语言示例

本文将介绍几个简单的例子，介绍Mule表达式语言（MEL）的大部分基本实现。每个示例都包含一个分步指南，用于在Mule Studio的可视化编辑器或XML中创建流程。您也可以直接跳到所有六个示例的完整代码，您可以在自己的应用程序中进一步复制和操作。


== 假设

本文假设您熟悉Mule Expression Language的 link:/mule-user-guide/v/3.4/mule-expression-language-basic-syntax[基本语法]，并且使用 link:/anypoint-studio/v/5/[骡子工作室]或XML轻松构建和运行Mule应用程序。

如果您还不熟悉如何访问通过应用程序传递的Mule消息的信息，请考虑遵循此 link:/getting-started/mule-message[教程]，它会引导您检查Mule消息及其数据结构并编写简单的MEL表达式。


== 示例1  - 访问属性

本示例创建一个简单的Web服务，它接受包含`username`参数的HTTP请求，并使用该`username`返回问候语。

在这个例子中，你使用MEL来：

* 访问入站属性
* 动态设置有效负载

[tabs]
------
[tab,title="Studio Visual Editor"]
....

. In a new flow, drag an HTTP endpoint and a Set Payload transformer.
+
image:ex1.png[ex1]
+
. Open the HTTP endpoint's properties editor and give it the path `greet1`. In this way, the endpoint can be reached via the `http://localhost:8081/greet1` URI.
. Open the Set Payload's properties editor and set the value field with the following MEL expression:
+
[source]
----
Hello #[message.inboundProperties['username']]
----
+
This expression captures the inbound property "username", which is passed as a query string parameter when calling the service.
+
. Save and run the project.
. Through a web browser, access the `http://localhost:8081/greet1?username=yourName` URL.
+
The response displays `Hello yourName` in your browser.
+
[TIP]
====
This method of accessing query string parameters does not escape URL encoded characters (such as spaces, which would be read as `%20`). If you want to access the escaped values of these parameters, you can do it through a special inbound property provided by Mule named `http.query.params` which contains a map, where keys are property names and values are escaped property values.

In this example, you can get a user name with escaped characters through this expression:

[source]
----
Hello #[message.inboundProperties['http.query.params']['username']]
----
====

....
[tab,title="XML Editor"]
....

. In a new flow, add an `http:inbound-endpoint `and configure it with the path` greet1`.
+
[source, xml]
----
<http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet1" doc:name="HTTP"/>
----
+
[%header,cols="2*"]
|===
|Attribute |Value
|*exchange-pattern*
a|`request-response`
|*host* a|`localhost`
|*port* a|`8081`
|*path* a|`greet1`
|*doc:name* a|`HTTP`
|===
+
In this way, the endpoint can be reached via the `http://localhost:8081/greet1` URI.
+
. After the endpoint, add a `set-payload` transformer, configured as shown:
+
[source, xml]
----
<set-payload value="Hello #[message.inboundProperties['username']]" doc:name="Set Payload"/>
----
+
[%header,cols="2*"]
|===
|Attribute |Value
|*value* a|`Hello #[message.inboundProperties['username']]``
|*doc:name* a|`Set Payload`
|===
+
The MEL expression used in `value` captures the inbound property `username`, which is passed as a query string parameter when calling the service.
+
. The full code of your flow should look like this:
+
[source, xml, linenums]
----
<flow name="greetingFlow1" doc:name="greetingFlow1">
  <http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet1" doc:name="HTTP"/>
  <set-payload value="Hello #[message.inboundProperties['username']]" doc:name="Set Payload"/>
</flow>
----
+
. Save and run the project.
. Through a browser, access the `http://localhost:8081/greet1?username=yourName` URL.
+
This displays `Hello yourName` in your browser.
....
------

== 示例2  - 通过评估条件进行动态路由

在前面的示例中，如果您对该服务的调用不包含`username`参数，则会导致错误。您可以通过添加一些流量控制组件来防止发生这种情况。此示例包含一个选择路由器，用于验证是否传递了所需的参数。

在这个例子中，你可以使用MEL来：

* 评估选择组件中的条件
* 访问入站属性
* 动态设置有效负载

[tabs]
------
[tab,title="Studio Visual Editor"]
....

. In a new flow, drag an HTTP endpoint and a Choice Router. Inside this Choice Router, add a Set Payload component in the space provided for the Default action and another Set Payload as a separate branch, as shown below. 
+
image:MELex2.png[MELex2]
+
. Open the HTTP Endpoint's properties editor and give it the path `greet2`. In this way, the endpoint can be reached via the `http://localhost:8081/greet2` URI.
. Open the properties editor of the Set Payload transformer that sits in the Default space and set the *Display Name* to `Set Payload for valid username` and configure the *Value* with the following MEL expression:
+
[source]
----
Hello #[message.inboundProperties['username']]
----
+
This expression captures the inbound property "username", which is passed as a query string parameter when calling the service.
+
. Open the properties editor of the other Set Payload transformer (the one that doesn't sit in the default space) and set the *Display Name* to `Set Payload for invalid username` and configure the *Value* with the expression `&#x0023;['No username provided']`.
. Open the Choice Router's properties editor to configure the routing logic. Double-click the row of the non-default route to provide a conditional expression. In the window that opens up, write the following MEL expression:
+
[source]
----
#[message.inboundProperties['username'] == empty]
----
+
This expression accesses the username inbound property and determines whether or not it is `null` or an empty string. This expression returns either Boolean true or false.
+
[TIP]
====
In MEL, the keyword `empty` tests the emptiness of a value, and returns boolean true for any of the following:` `

* `null`
* boolean false
* empty strings or strings with only white space
* 0 value numeric values
* empty collections
====
+
. Save and run the project.
. Through a web browser, access the `http://localhost:8081/greet2?username=yourName` URL. This displays `Hello yourName` in your browser.
. Access the URL again, but this time do not include any parameters. Verify that the expected output is received.

....
[tab,title="XML Editor"]
....

. In a new flow, add an `http:inbound-endpoint`:
+
[source, xml]
----
<http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet2" doc:name="HTTP"/>
----

+
[%header,cols="2*"]
|===
|Attribute |Value
|*exchange-pattern* a|`request-response`
|*host* a|`localhost`
|*port* a|`8081`
|*path* a|`greet2`
|*doc:name* a|`HTTP`
|===

+
In this way, the endpoint can be reached via the `http://localhost:8081/greet2` URI.
+
. After the endpoint, add a choice element with two possible outputs. One of these outputs is the default, the other evaluates a MEL expression.
+
[source, xml, linenums]
----
<choice doc:name="Choice">
  <when>
 
  </when>
  <otherwise>
                
  </otherwise>
</choice>
----
+
Inside the `when` tag, insert the following MEL expression:
+
[source]
----
expression="#[message.inboundProperties['username'] == empty]"
----
+
This expression accesses the username inbound property and determines whether or not it is `null` or an empty string. This expression returns either boolean `true` or `false`.
+
[TIP]
====
In MEL, the keyword `empty` tests the emptiness of a value, and returns boolean true for any of the following:` `

* `null`
* boolean `false`
* empty strings or strings with only white space
* 0 value numeric values
* empty collections
====
+
. On each of the two paths in the choice router, add a `set-payload` transformer. In the first `set-payload` transformer, add the following attributes:
+
[%header,cols="2*"]
|===
|Attribute |Value
|*value* a|`#[No username provided]`
|*doc:name* a|`Set Payload for invalid username`
|===
+
In the second set-payload transformer, use a MEL expression to access the inbound property:
+
[%header,cols="2*"]
|===
|Attribute |Value
|*value* a|`Hello #[message.inboundProperties['username']]`
|*doc:name* a|`Set Payload for valid username`
|===
+
The MEL expression in the `value` attribute in the second `set-property` captures the inbound property `username`, which is passed as a query string parameter when calling the service.
+
[source, xml, linenums]
----
<choice doc:name="Choice">
  <when expression="#[message.inboundProperties['username'] == empty]">
    <set-payload value="#['No username provided']" doc:name="Set Payload for invalid username"/>
  </when>
  <otherwise>
    <set-payload value="Hello #[message.inboundProperties['username']]" doc:name="Set Payload for valid username"/>
  </otherwise>
</choice>
----
+
. The full code of your flow should look like this:
+
[source, xml, linenums]
----
<flow name="greetingFlow2" doc:name="greetingFlow2">
  <http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet2" doc:name="HTTP"/>
  <choice doc:name="Choice">
    <when expression="#[message.inboundProperties['username'] == empty]">
      <set-payload value="#['No username provided']" doc:name="Set Payload for invalid username"/>
    </when>
    <otherwise>
      <set-payload value="Hello #[message.inboundProperties['username']]" doc:name="Set Payload for valid username"/>
    </otherwise>
  </choice>
</flow>
----
+
. Save and run the project.
. Through a browser, access the `http://localhost:8081/greet1?username=yourName` URL.
+
This displays `Hello yourName` in your browser.
+
. Access the URL again, but this time do not include any parameters. Verify that the expected output is received.

....
------

== 示例3-变量赋值和评估条件

在此示例中，除了仅返回问候之外，该服务还会保存一个包含用户数据的CSV文件。现在对该服务的调用包括两个参数`username`和`age`。该服务存储这两个参数并添加第三个布尔参数，用于评估用户是否为未成年（如果`age`> 18）。

在这个例子中，你可以使用MEL来：

* 在消息中设置一个流变量
* 基于评估输入生成输出
* 访问入站属性
* 动态设置有效负载

[tabs]
------
[tab,title="Studio Visual Editor"]
....

. In a new flow, drag an HTTP endpoint, followed by an Expression component, then a Set Payload component, a File Enpoint, and finally another Set Payload Component.
+
image:ex3.png[ex3]
+
. Open the HTTP Endpoint's properties editor and give it the *Path* `greet3`. In this way, the endpoint can be reached via the `http://localhost:8081/greet3` URI.
. In the expression component, set the following MEL expression:
+
[source]
----
flowVars['username'] = message.inboundProperties['username']
----
+
This expression takes the value of the inbound property `username` and sets it as the flow variable `username`.
+
[TIP]
Because this MEL expression is used in an *expression component*, it doesn't need to be surrounded with `&#x0023;[]` brackets.
+
. In the Set Payload transformer, set the *Value* to the following MEL expressions:
+
[source]
----
#[message.inboundProperties['username']],
#[message.inboundProperties['age']],
#[message.inboundProperties['age'] > 18]
----

+
This sets the payload to a string that contains three comma-separated values. The third of these values evaluates a condition and returns `true` or `false` depending on the user's age.
+
. In the properties editor of the File endpoint, set a path for the file to be saved.
. Open the properties editor of the final Set Payload transformer and set the *Value* field with the following MEL expression:
+
[source]
----
Hello #[flowVars['username']]
----
+
This expression captures the flow variable `username`, which was created by the Expression Component in your flow.
+
. Save and run the project.
. Through a web browser, access the `http://localhost:8081/greet3?username=yourName&age=22 ` URL.
+
This displays `Hello yourName` in your browser and also saves a CSV file that contains this data, plus the value `true` for the boolean parameter.

....
[tab,title="XML Editor"]
....

. In a new flow, add an `http:inbound-endpoint`. Configure it as shown:
+
[source, xml, linenums]
----
<http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet3" doc:name="HTTP"/>
----
+
[%header,cols="2*"]
|===
|Attribute |Value
|*exchange-pattern* a|`request-response`
|*host* a|`localhost`
|*port* a|`8081`
|*path* a|`greet3`
|*doc:name* a|`HTTP`
|===
+
In this way, the endpoint can be reached via the `http://localhost:8081/greet3` URI.
+
. After the endpoint, add an expression component that uses a MEL expression to record the inbound property `username` into a flowVar.
+
[source, xml, linenums]
----
<expression-component doc:name="Expression"><![CDATA[flowVars['username'] = message.inboundProperties['username']]]>
</expression-component>
----
+
This expression takes the value of the inbound property `username` and sets it as the flow variable `username`.
+
[TIP]
Since this MEL expression is used in an *expression component,* it doesn't need to be surrounded with `&#x0023;[]` brackets.
+
. Add a Set Payload transformer and set the `value` field to a MEL expression:
+
[source, xml]
----
<set-payload value="#[message.inboundProperties['username']], #[message.inboundProperties['age']], #[message.inboundProperties['age']&gt;18]" doc:name="Set Payload"/>
----
+
[%header,cols="2*"]
|===
|Attribute |Value
|*value* a|``#[message.inboundProperties['username']], #[message.inboundProperties['age']], #[message.inboundProperties['age']&gt;18]``
|*doc:name* a|`Set Payload`
|===
+
This sets the payload to a string that contains three comma-separated values. The third of these values evaluates a condition and returns `true` or `false` depending on the user's age.
+
. Below, add a `file:outbound-endpoint` to send this data to a file:
+
[source, xml]
----
<file:outbound-endpoint path="path_of_your_choice" responseTimeout="10000" doc:name="File"/> 
----
+
[%header,cols="2*"]
|===
|Attribute |Value
a|`path`
a|
`_(Example)_`

`/Users/AaronMacbook/Downloads`

a|`responseTimeout`
a|`10000`
a|`doc:name`
a|`File`
|===
+
. Below, add another Set Payload transformer containing a MEL expression that references the flow variable that you set earlier in the flow:
+
[source, xml]
----
<set-payload value="Hello #[flowVars['username']]" doc:name="Set Payload"/>
----
+
This expression accesses the flow variable `username`, which was created by the Expression Component in your flow.
+
[%header,cols="2*"]
|===
|Attribute |Value
a|`value`
a|`Helo #[flowVars['username']]``
a|`doc:name`
a|`Set Payload`
|===
+
. The full code of your flow should look like this:
+
[source, xml, linenums]
----
<flow name="greetingFlow3" doc:name="greetingFlow3">
  <http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet3" doc:name="HTTP"/>
  <expression-component doc:name="Expression"><![CDATA[flowVars['username'] = message.inboundProperties['username']]]></expression-component>
  <set-payload value="#[message.inboundProperties['username']], #[message.inboundProperties['age']], #[message.inboundProperties['age']&gt;18]" doc:name="Set Payload"/>
  <file:outbound-endpoint path="path_of_your_choice" responseTimeout="10000" doc:name="File"/>
  <set-payload value="Helo #[flowVars['username']]" doc:name="Set Payload"/>
</flow>
----
+
. Save and run your project.
. In a browser, access the URL` http://localhost:8081/greet3?username=yourName&age=22 ` +
This will print the words `Hello yourName` in your browser and also save a csv file that contains this data, plus the value `true` for the boolean parameter.
....
------

== 示例4  - 使用DataMapper创建地图和评估条件

*Enterprise*

在这个例子中，和上一个例子一样，Mule应用程序保存一个包含用户数据的CSV文件并返回一个问候语。对该服务的调用包括两个参数`username`和`age`。该服务存储这两个参数并添加第三个布尔参数，用于评估用户是否超过特定年龄（如果`age ` `> 18`）。但是，在这种情况下，输入和输出字段之间的映射以及第三个字段的生成由 link:/anypoint-studio/v/6/datamapper-user-guide-and-reference[的DataMapper]组件执行。

在这个例子中，你可以使用MEL来：

* 在消息中设置一个流变量
* 将地图设置为您的消息载荷
* 基于评估DataMapper中的输入生成输出
* 访问入站属性
* 动态设置有效负载

[tabs]
------
[tab,title="Studio Visual Editor"]
....

. In a new flow, drag an HTTP endpoint, followed by an Expression Component, then a Set Payload transformer, a DataMapper transformer, a File Endpoint, and finally another Set Payload transformer.
+
image:ex4.png[ex4]
+
. Open the HTTP endpoint's properties editor and give it the path `greet4`. In this way, the endpoint can be reached via the `http://localhost:8081/greet4` URI.
. In the expression component, set the following MEL expression:
+
[source]
----
flowVars['username'] = message.inboundProperties['username']
----
+
[TIP]
Since this MEL expression is used in an *expression component,* it doesn't need to be surrounded with `&#x0023;[]` brackets.
+
. In the Set Payload transformer, set the *Value* field to the following MEL expression:
+
[source]
----
#[['username' : message.inboundProperties['username'], 'age' : message.inboundProperties['age']]]
----
+
This sets the payload to a map that contains two key:value pairs.
+
. In the DataMapper properties editor, configure the fields as shown:
+
* In the Input, select *Map<k,v>* type and *User Defined* structure.
* In the Output, select *CSV* type and *User Defined* structure.
+
image:MELex4.png[MELex4]
+
. For the input, click *Edit Fields* to open the Define the Map dialog.  
. Give your map a *Name* and *Type*, then create two fields by clicking the green plus sign:
+
[%header%autowidth.spread]
|===
|Name |Type
|username |String
|age |Integer
|===
+
image:MELex4-input.png[MELex4-input]
+
. For the Output, click *Edit Fields*, then give the output a *Name*, select a *Delimiter*, and create three fields, as shown:
+
image:MELex4-output.png[MELex4-output]
+
. Click *Create Mapping* to trigger DataMapper to generate the mapping.
. DataMapper now displays the mapping between input and output fields. The third output field (of_age) needs a MEL expression to get its values. Select it and then write the following MEL expression in the input box below:
+
[source]
----
input.age>18
----
+
The resulting mapping should look like this:
+
image:MELex4-mapping.png[MELex4-mapping]
+
. In the File endpoint, set a path of your choice for the file to be saved.
. Open the properties editor of the final Set Payload transformer and set the *Value* field with the following:
+
[source]
----
Hello #[flowVars['username']]
----
+
This expression  accesses the flow variable `username`, which was created by the Expression Component in your flow.
+
. Save and run the project.
. In a browser, access the `http://localhost:8081/greet4?username=yourName&age=22` URL.
+
This displays `Hello yourName` in your browser and also saves a CSV file that contains this data, plus the value `true` for the boolean parameter.

....
[tab,title="XML Editor"]
....

. In a new flow, add an `http:inbound-endpoint `configured as shown.
+
[source, xml]
----
<http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet4" doc:name="HTTP"/>
----
+
[%header,cols="2*"]
|===
|Attribute |Value
|*exchange-pattern* a|`request-response`
|*host* a|`localhost`
|*port* a|`8081`
|*path* a|`greet4`
|*doc:name* a|`HTTP`
|===
+
In this way, the endpoint is reached via the `http://localhost:8081/greet4` URI.
+
. After the endpoint, add an expression component that uses a MEL expression to record the inbound property `username` into a flow variable of the same name.
+
[source, xml, linenums]
----
<expression-component doc:name="Expression"><![CDATA[flowVars['username'] = message.inboundProperties['username']]]>
</expression-component>
----
+
[TIP]
Since this MEL expression is used in an *expression component*, it doesn't need to be surrounded with `&#x0023;[]` brackets.
+
. Add a set-payload transformer and set the value attribute to a MEL expression:
+
[source, xml]
----
<set-payload value="#[['username' : message.inboundProperties['username'], 'age' : message.inboundProperties['age']]]" doc:name="Set Payload"/>
----
+
[%header,cols="2*"]
|===
|Attribute |Value
|*value* a|`#[['username' : message.inboundProperties['username'], 'age' : message.inboundProperties['age']]]`
|*doc:name* a|`Set Payload`
|===
+
This sets the payload to a map of key:value pairs that contains username and age.
+
. Next, add a data-mapper:transform element. 
+
[source]
----
<data-mapper:transform doc:name="Map To CSV"/>
----
+
To configure the DataMapper, transition to Studio's Visual Editor.
+
. In the DataMapper properties editor, configure the following:
+
* In the input, select *Map<k,v>* type and *User Defined* structure.
* In the output, slect *CSV* type and *User Defined* structure.
+
image:MELex4.png[MELex4]
+
. For the input, click *Edit fields* to open the Define the Map dialog. 
. Give your map a *Name* and *Type*, then create two fields by clicking the green plus sign:
+
[%header%autowidth.spread]
|===
|Name |Type
|username |String
|age |Integer
|===
+
image:MELex4-input.png[MELex4-input]
+
. For the Output, click *Edit Fields*, then give the output a *Name*, select a *Delimiter*, and create three fields, as shown:
+
image:MELex4-output.png[MELex4-output]
+
. Click *Create Mapping* to trigger DataMapper to generate the mapping. DataMapper now displays the mapping between input and output fields. The third output field (of_age) needs a MEL expression to get its values. Select it and  write the following MEL expression in the input box below:
+
[source]
----
input.age>18
----
+
The resulting mapping should look like this:
+
image:MELex4-mapping.png[MELex4-mapping]
+
. Set Studio's view back to the XML editor. Below the last component, add a `file:outbound-endpoint` to send this data to a file:
+
[source, xml]
----
<file:outbound-endpoint path="path_of_your_choice" responseTimeout="10000" doc:name="File"/> 
----
+
[%header,cols="2*"]
|===
|Attribute |Value
|*path* a|`_(Example)_` +
`Users/AaronMacBook/Desktop`
|*responseTimeout* a|`10000`
|*doc:name* a|`File`
|===
+
. Below, add another Set Payload transformer, configured as shown:
+
[source, xml]
----
<set-payload value="Hello #[flowVars['username']]" doc:name="Set Payload"/>
----
+
This expression accesses the flow variable `username`, which was created by the Expression Component in your flow.
+
[%header,cols="2*"]
|===
|Attribute |Value
|*value* a|`Hello #[flowVars['username']]`
|*doc:name* a|`Set Payload`
|===
+
. The full code of your flow should look like this:
+
[source, xml, linenums]
----
<flow name="greetingFlow4" doc:name="greetingFlow4">
  <http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet4" doc:name="HTTP"/>
  <expression-component doc:name="Expression"><![CDATA[flowVars['username'] = message.inboundProperties['username']]]>
  </expression-component>
  <set-payload value="#[['username' : message.inboundProperties['username'], 'age' : message.inboundProperties['age']]]" doc:name="Set Payload"/>
  <data-mapper:transform config-ref="map_to_csv" doc:name="Map To CSV"/>
  <file:outbound-endpoint path="path_of_your_choice" responseTimeout="10000" doc:name="File"/>
  <set-payload value="Hello #[flowVars['username']]" doc:name="Set Payload"/>
</flow>
----
+
. Save and run your project.
. In a browser, access the `http://localhost:8081/greet4?username=yourName&age=22` URL.
+
This displays `Hello yourName` in your browser and also save a csv file that contains this data, plus the value `true` for the boolean parameter.

....
------

== 示例5  - 使用Xpath

在前面的所有示例中，通过包含查询参数的GET请求来调用服务。在此示例中，您创建的服务是一个接受带有XML主体的POST请求的API。所需的XML包含两个参数`username`和`age`。该服务存储这两个参数并添加第三个布尔参数，用于评估用户是否超过特定年龄（如果`age >18`）

在这个例子中，你使用MEL来：

* 在消息中设置一个流变量
* 基于评估输入生成输出
* 通过xpath查询解析XML输入
* 动态设置有效负载

[tabs]
------
[tab,title="Studio Visual Editor"]
....

. In a new flow, drag an HTTP endpoint, followed by an Expression Component, a Set Payload transformer, a File endpoint, and another Set Payload transformer.
+
image:ex5.png[ex5]
+
. Open the HTTP Endpoint's properties editor and give it the path `greet5`. In this way, the endpoint is be reached via the URI ` http://localhost:8081/greet5`.
. Open the Expression Component's properties editor and set the following MEL expression:
+
[source]
----
flowVars['username'] = xpath('/user/username').text
----
+
This expression calculates the result of the xpath function and sets it as the value of the flow variable `username`.
+
[TIP]
Since this MEL expression is used in an *expression component,* it doesn't need to be surrounded with `#[]`.
+
Since the payload is in XML, *xpath* is needed to parse it.
+
. In the Set Payload transformer, set the *Value* field to the following:
+
[source, code, linenums]
----
#[xpath('/user/username').text],
#[xpath('/user/age').text],
#[xpath('/user/age').text > 18]
----
+
This sets the payload to a string that contains three comma-separated values. The third of these values evaluates a condition and returns `true` or `false` depending on the user's age. Once again, as the payload is in XML, *xpath* is needed to parse it.
+
. In the File endpoint, set a path of your choice to determine where the .csv file should be saved.
. Open the properties editor of the final Set Payload transformer and set the *Value* field with the following:
+
[source]
----
Hello #[flowVars['username']]
----
+
This expression accesses the flow variable username, which was created by the Expression Component earlier in your flow.
+
. Save and run your project.
. You must now send the HTTP endpoint an HTTP request that includes a body with an attached XML file.
+
Send a POST request to `http://localhost:8081/greet5` and attach an XML to the body of the message. A sample XML is provided below.
+
[source, xml, linenums]
----
<user>
  <username>test</username>
  <age>21</age>
</user>
----
+
This displays `Hello yourName` in your browser and also saves a CSV file that contains this data, plus the value `true` for the boolean parameter.

....
[tab,title="XML Editor"]
....

. In a new flow, add an `http:inbound-endpoint `configured as shown.
+
[source, xml]
----
<http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet5" doc:name="HTTP"/>
----
+
[%header,cols="2*"]
|===
|Attribute |Value
|*exchange-pattern* a|`request-response`
|*host* a|`localhost`
|*port* a|`8081`
|*path* a|`greet5`
|*doc:name* a|`HTTP`
|===
+
In this way, the endpoint can be reached via the `http://localhost:8081/greet5` URI.
+
. After the endpoint, add an Expression Component that uses a MEL expression to record the inbound property `username` into a flow variable. Because the payload is an XML file, it must be parsed with xpath.
+
[source, xml]
----
<expression-component doc:name="Expression"><![CDATA[flowVars['username'] = xpath('/user/username').text]]></expression-component>
----
+
This expression calculates the result of the xpath function and sets it as the value of the flow variable `username`.
+
[TIP]
Since this MEL expression is used in an *expression component,* it isn't surrounded with brackets `#[]`
+
. Add a set-payload transformer and set the `value` attribute to a comma-separated list of MEL expressions:
+
[source, xml]
----
<set-payload value="#[xpath('/user/username').text], #[xpath('/user/age').text], #[xpath('/user/age').text &gt; 18]" doc:name="Set Payload"/>
----
+
[%header,cols="2*"]
|===
|Attribute |Value
|*value* a|#[`xpath('/user/username').text], #[xpath('/user/age').text], #[xpath('/user/age').text &gt; 18`]
|*doc:name* a|`Set Payload`
|===
+
This sets the payload to a string that contains three comma separated values. The third of these values is evaluating a condition and returns `true` or `false` depending on the user's age. Once again, as the payload is in XML, *xpath* is needed to parse it.
+
. Add a `file:outbound-endpoint` to output the payload into a csv file.
+
[source, xml]
----
<file:outbound-endpoint path="path_of_your_choice" responseTimeout="10000" doc:name="File"/> 
----
+
[%header,cols="2*"]
|===
|Attribute |Value
|*path* a|`_(Example)_`
Users/AaronMacBook/Downloads
|*responseTimeout* a|`10000`
|*doc:name* a|`File`
|===
+
. Below, add another set-payload transformer with a value containing a MEL expression that references the flow variable `username` that you set earlier in the flow:
+
[source, xml]
----
<set-payload value="Hello #[flowVars['username']]" doc:name="Set Payload"/>
----
+
[%header,cols="2*"]
|===
|Attribute |Value
|*value* a|`Hello #[flowVars['username'`]]
|*doc:name* a|`Set Payload`
|===
+
. The full code of your flow should look like this:
+
[source, xml, linenums]
----
<flow name="greetingFlow5" doc:name="greetingFlow5">
        <http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet5" doc:name="HTTP"/>
        <expression-component doc:name="Expression"><![CDATA[flowVars['username'] = xpath('/user/username').text]]></expression-component>
        <set-payload value="#[xpath('/user/username').text], #[xpath('/user/age').text], #[xpath('/user/age').text &gt; 18]" doc:name="Set Payload"/>
        <file:outbound-endpoint path="path_of_your_choice" responseTimeout="10000" doc:name="File"/>
        <set-payload value="Hello #[flowVars['username']]" doc:name="Set Payload"/>
    </flow>
----
+
. Save and run your project. You must now send the HTTP endpoint an HTTP request that includes a body with an attached XML file. Send a POST request to` http://localhost:8081/greet5`, and attach an XML to the body of the message. A sample XML is provided below.
+
[TIP]
The easiest way to do this is by sending a POST via a browser extension such as Postman (for Google Chrome) or the http://curl.haxx.se/[curl] command line utility.
+
[source, xml, linenums]
----
<user>
  <username>test</username>
  <age>21</age>
</user>
----
+
This displays `Hello yourName` in your browser and also saves a CSV file that contains this data, plus the value `true` for the boolean parameter.

....
------

== 示例6  - 使用Java对象

这个例子就像例5一样，除了服务现在接收JSON输入而不是XML。

JSON输入包含两个参数`username`和`age`。该服务存储这两个参数并添加第三个布尔参数，用于评估用户是否超过特定年龄（如果`age>18`）。 Mule首先将JSON对象转换为Java对象，以便MEL表达式可以访问该对象的属性。

在这个例子中，你可以使用MEL来：

* 在消息中设置一个流变量
* 基于评估输入生成输出
* 访问Java对象的属性
* 动态设置有效负载

[tabs]
------
[tab,title="Studio Visual Editor"]
....

. In a new flow, drag an HTTP endpoint, followed by a JSON to Object transformer, an Expression Component, a Set Payload transformer, a File endpoint, and another Set Payload transformer.
+
image:ex6.png[ex6]
+
. Open the HTTP Endpoint's properties editor and give it the path `greet6`. In this way, the endpoint can be reached via the `http://localhost:8081/greet6` URI.
+
. Open the properties editor of the JSON to Object transformer and click the *Advanced* tab. Set the *Return Class* to `java.lang.Object`. With this configuration, the JSON input becomes a Java object with attributes that can be easily called by using `object.attribute` notation.
. In the expression component, set the following MEL expression that accesses an attribute of the object and sets that as the value of a flow variable called `username`:
+
[source]
----
flowVars['username'] = payload.username
----
+
[TIP]
Since this MEL expression is used in an *expression component*, it doesn't need to be surrounded with `&#x0023;[]` brackets.
+
. In the Set Payload component, set the *Value* field to the following comma-separated list of MEL expressions:
+
[source, code, linenums]
----
#[payload.username],
#[payload.age],
#[payload.age > 18]
----
+
This sets the payload to a string that contains three comma-separated values. The third of these values is evaluating a condition and returns `true` or `false` depending on the user's age.
+
. In the File endpoint, set a *Path* of your choice to determine where the CSV files should be saved.
. Open the properties editor of the final Set Payload transformer and set the *Value* field with the following:
+
[source]
----
Hello #[flowVars['username']]
----
+
This expression accesses the flow variable `username`, which was created by the Expression Component earlier in your flow.
+
. Save and run the project.
. You must now send the HTTP endpoint an HTTP request that includes a body with an attached JSON file. +
Send a POST request to `http://localhost:8081/greet6`, attaching a JSON object the body of the message. A sample JSON is provided below.
+
[TIP]
The easiest way to do this is by sending a POST via a browser extension such as Postman (for Google Chrome) or the link:http://curl.haxx.se/[curl] command line utility.
+
[source]
----
{ "username": "test", "age" : 21 }
----
+
This displays `Hello yourName` in your browser and also saves a CSV file that contains this data, plus the value `true` for the boolean parameter.

....
[tab,title="XML Editor"]
....

. In a new flow, add an `http:inbound-endpoint` statement configured as shown.
+
[source, xml]
----
<http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet6" doc:name="HTTP"/>
----
+
[%header,cols="2*"]
|===
|Attribute |Value
|*exchange-pattern* a|`request-response`
|*host* a|`localhost`
|*port* a|`8081`
|*path* a|`greet6`
|*doc:name* a|`HTTP`
|===
+
In this way, the endpoint is reached via the URI `http://localhost:8081/greet6`.
+
. After the endpoint, add a `json:json-to-object-transformer` statement. 
+
[source, xml]
----
<json:json-to-object-transformer doc:name="JSON to Object" returnClass="java.lang.Object"/>
----
+
[%header,cols="2*"]
|===
|Attribute |Value
|*returnClass* a|`java.lang.Object`
|*doc:name* a|`JSON to Object`
|===
+
With this configuration, the JSON input becomes a Java object with attributes that can be easily called by using `object.attribute` notation.
+
. After the transformer, add an expression component that uses a MEL expression to access the Java object's `username` attribute and assign its value into a flow variable of the same name.
+
[source, xml]
----
<expression-component doc:name="Expression"><![CDATA[flowVars['username'] = payload.username]]></expression-component>
----
+
[TIP]
Since this MEL expression is used in an *expression component*, it doesn't need to be surrounded with `&#x0023;[]`.
+
. Add a set-payload transformer and set the `value` attribute to a comma-separated list of MEL expressions:
+
[source, xml]
----
<set-payload value="#[payload.username], #[payload.age], #[payload.age &gt; 18]" doc:name="Set Payload"/>
----
+
[%header,cols="2*"]
|===
|Attribute |Value
a|`value`
a|#[`payload.username], #[payload.age], #[payload.age &gt; 18`]
a|`doc:name`
a|`Set Payload`
|===
+
This sets the payload to a string that contains three comma-separated values. The third of these values is evaluating a condition and returns `true` or `false` depending on the user's age.
+
. Add  a `file:outbound-endpoint` to output the payload into a csv file.
+
[source, xml]
----
<file:outbound-endpoint path="path_of_your_choice" responseTimeout="10000" doc:name="File"/> 
----
+
[%header,cols="2*"]
|===
|Attribute |Value
|*path* a|_(`Example`)_
`Users/AaronMacBook/Downloads`
|*responseTimeout* a|`10000`
|*doc:name* a|`File`
|===
+
. Below, add another set-payload transformer, containing a MEL expression that references a flow variable:
+
[source, xml, linenums]
----
<set-payload value="Hello #[flowVars['username']]" doc:name="Set Payload"/>
----
+
This expression accesses the flow variable `username`, which was created by the Expression Component earlier in your flow.
+
[%header,cols="2*"]
|===
|Attribute |Value
|*value* a|`Hello #[flowVars['username'`]]
|*doc:name* a|`Set Payload`
|===
+
. The full code of your flow should look like this:
+
[source, xml, linenums]
----
<flow name="greetingFlow6" doc:name="greetingFlow6">
  <http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet6" doc:name="HTTP"/>
  <json:json-to-object-transformer doc:name="JSON to Object" returnClass="java.lang.Object"/>
  <expression-component doc:name="Expression"><![CDATA[flowVars['username'] = payload.username]]></expression-component>
  <set-payload value="#[payload.username], #[payload.age], #[payload.age &gt; 18]" doc:name="Set Payload"/>
    <file:outbound-endpoint path="users" responseTimeout="10000" doc:name="File"/>
  <set-payload value="Hello #[flowVars['username']]" doc:name="Set Payload"/>
</flow>
----
+
. Save and run the project. You must now send the HTTP endpoint an HTTP request that includes a body with an attached JSON file.
. Send a POST request to http://localhost:8081/greet6, and attach a JSON object the body of the message. A sample JSON is provided below.
+
[TIP]
The easiest way to do this is to send a POST via a browser extension such as Postman (for Google Chrome) or the http://curl.haxx.se/[curl] command line utility.
+
[source]
----
{ "username": "test", "age" : 21 }
----
+
This displays `Hello yourName` in your browser and also saves a CSV file that contains this data, plus the value `true` for the boolean parameter.

....
------

== 所有示例的完整代码

[TIP]
为了您的方便，您可以下载 link:_attachments/mel-examples.zip[完成项目]。

[source, xml, linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
 
<mule xmlns:json="http://www.mulesoft.org/schema/mule/json"
    xmlns:data-mapper="http://www.mulesoft.org/schema/mule/ee/data-mapper" xmlns:file="http://www.mulesoft.org/schema/mule/file"
    xmlns:tracking="http://www.mulesoft.org/schema/mule/ee/tracking" xmlns:http="http://www.mulesoft.org/schema/mule/http" xmlns="http://www.mulesoft.org/schema/mule/core" xmlns:doc="http://www.mulesoft.org/schema/mule/documentation" xmlns:spring="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mulesoft.org/schema/mule/json http://www.mulesoft.org/schema/mule/json/current/mule-json.xsd
http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
http://www.mulesoft.org/schema/mule/file http://www.mulesoft.org/schema/mule/file/current/mule-file.xsd
http://www.mulesoft.org/schema/mule/ee/tracking http://www.mulesoft.org/schema/mule/ee/tracking/current/mule-tracking-ee.xsd
http://www.mulesoft.org/schema/mule/ee/data-mapper http://www.mulesoft.org/schema/mule/ee/data-mapper/current/mule-data-mapper.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-current.xsd
http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd">
 
<data-mapper:config name="new_mapping_grf" transformationGraphPath="new_mapping.grf" doc:name="DataMapper"/>
    <data-mapper:config name="map_to_csv" transformationGraphPath="map_to_csv.grf" doc:name="map_to_csv"/>
 
 
<!-- Example 1 Start - How to access properties using MEL, how to set a payload dynamically -->  
    <flow name="greetingFlow1" doc:name="greetingFlow1">
        <http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet1" doc:name="HTTP"/>
        <set-payload value="Hello #[message.inboundProperties['username']]" doc:name="Set Payload"/>
    </flow>
 
<!-- Example 1 End -->
 
<!-- Example 2 Start - How to dynamically route messages based on the results of a conditional expression -->  
    <flow name="greetingFlow2" doc:name="greetingFlow2">
        <http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet2" doc:name="HTTP"/>
        <choice doc:name="Choice">
            <when expression="#[message.inboundProperties['username'] == empty]">
                <set-payload value="#['No username provided']" doc:name="Set Payload for invalid username"/>
            </when>
            <otherwise>
                <set-payload value="Hello #[message.inboundProperties['username']]" doc:name="Set Payload for valid username"/>
            </otherwise>
        </choice>
    </flow>
<!-- Example 2 End -->
 
<!-- Example 3 Start - How to assign variables, how to evaluate a condition -->
    <flow name="docs-greetingFlow3" doc:name="greetingFlow3">
        <http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet3" doc:name="HTTP"/>
        <expression-component doc:name="Expression"><![CDATA[flowVars['username'] = message.inboundProperties['username']]]></expression-component>
        <set-payload value="#[message.inboundProperties['username']], #[message.inboundProperties['age']], #[message.inboundProperties['age']&gt;18]" doc:name="Set Payload"/>
        <file:outbound-endpoint path="Path_of_your_choice" responseTimeout="10000" doc:name="File"/>
        <set-payload value="Hello #[flowVars['username']]" doc:name="Set Payload"/>
    </flow>
<!-- Example 3 End -->
 
<!-- Example 4 Start - How to create a map, how to evaluate a condition with DataMapper -->
    <flow name="docs-greetingFlow4" doc:name="greetingFlow4">
        <http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet4" doc:name="HTTP"/>
        <expression-component doc:name="Expression"><![CDATA[flowVars['username'] = message.inboundProperties['username']]]></expression-component>
        <set-payload value="#[['username' : message.inboundProperties['username'], 'age' : message.inboundProperties['age']]]" doc:name="Set Payload"/>
        <data-mapper:transform config-ref="map_to_csv" doc:name="Map To CSV"/>
        <file:outbound-endpoint path="Path_of_your_choice" responseTimeout="10000" doc:name="File"/>
        <set-payload value="Hello #[flowVars['username']]" doc:name="Set Payload"/>
    </flow>
<!-- Example 4 End -->
 
<!-- Example 5 Start - How to parse XML input with Xpath -->  
    <flow name="docs-greetingFlow5" doc:name="greetingFlow5">
        <http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet5" doc:name="HTTP"/>
        <expression-component doc:name="Expression"><![CDATA[flowVars['username'] = xpath('/user/username').text]]></expression-component>
        <set-payload value="#[xpath('/user/username').text], #[xpath('/user/age').text], #[xpath('/user/age').text &gt; 18]" doc:name="Set Payload"/>
        <file:outbound-endpoint path="Path_of_your_choice" responseTimeout="10000" doc:name="File"/>
        <set-payload value="Hello #[flowVars['username']]" doc:name="Set Payload"/>
    </flow>
<!-- Example 5 End -->
 
<!-- Example 6 Start - How to parse Java objects -->
    <flow name="greetingFlow6" doc:name="greetingFlow6">
        <http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" path="greet6" doc:name="HTTP"/>
        <json:json-to-object-transformer doc:name="JSON to Object" returnClass="java.lang.Object"/>
        <expression-component doc:name="Expression"><![CDATA[flowVars['username'] = payload.username]]></expression-component>
        <set-payload value="#[payload.username], #[payload.age], #[payload.age &gt; 18]" doc:name="Set Payload"/>
        <file:outbound-endpoint path="Path_of_your_choice" responseTimeout="10000" doc:name="File"/>
        <set-payload value="Hello #[flowVars['username']]" doc:name="Set Payload"/>
    </flow>
<!-- Example 6 End -->
 
</mule>
----

== 另请参阅

* 访问Mule表达式语言 link:/mule-user-guide/v/3.4/mule-expression-language-reference[参考]和 link:/mule-user-guide/v/3.4/mule-expression-language-tips[提示]。
