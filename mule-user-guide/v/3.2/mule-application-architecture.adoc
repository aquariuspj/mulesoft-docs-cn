[TIP]
此文档页面正在建设中。请谅解信息中不一致的外观和差距。

=  Mule应用程序体系结构

在最简单的层面上，Mule应用程序一次接受一个消息，然后按照接收的顺序处理每个消息。有时，Mule应用程序向原始消息的来源返回不同的消息。在其他情况下，应用程序可能会将其原始或更改形式的消息发送给一个或多个第三方。或者它可能会兼而有之。

在其他情况下，Mule可能拒绝处理（即丢弃）不符合特定标准的消息。

先进的Mule应用程序不仅支持这种线性消息处理。您可以设置机制以不同的方式处理不同的消息。此外，您可以构建应用程序，利用：

* 各种队列和线程安排来最大化吞吐量
* 群集或事务来最大化可靠性
* 对象存储确保数据持久性

这些仅代表您可以通过Mule应用程序实现的一小部分功能。

== 关于Mule执行单元

Mule ESB支持几种构建Mule应用程序的架构方法。 MuleSoft推荐最新，最方便，最灵活的体系结构*Flows*作为大多数Mule应用程序的首选执行单元。但*Services*和*Patterns*仍然可用，并且在某些特定情况下可能会证明有用。

=== 流

流程是构建Mule应用程序的最有力和灵活的方式，因为您可以将预先打包的构建块安排到一系列消息处理事件中，从而完全符合您的应用程序需求。

流程对于以下用例可能特别有效：

* 简单的集成任务
* 计划的数据处理
* 与基于云或内部部署的应用程序集成
* 需要编排多个服务的事件处理

Mule提供了一对用于构建流程的接口。您可以选择：

* 在应用程序配置文件中输入XML代码行
使用Studio，Mule的拖放式图形界面* ，可以将构建块图标排列成视觉序列

随后，您可以使用其他Studio图形工具或通过编辑配置文件中的XML代码来配置这些顺序构建模块。

=== 模式

Mule ESB提供配置模式，这些配置模式针对几种常见的消息处理情况进行了优化。如果您的应用程序不在由Mule捆绑的配置模式组所覆盖的区域之外，则应该使用流程。

四种预封装的配置模式是：

[%header,cols="2*"]
|===
|配置模式 |简要说明
|简单服务 |将带有注释的JAX-WS组件公开为SOAP Web服务。将JAX-RS注释的bean公开为RESTful组件。还可以使用简单的POJO组件处理JAXB，XML和原始内容。
| Web服务代理 |代理远程Web服务。可以在SOAP信封上执行转换。可以将远程WSDL重写或重定向到本地WSDL。
|网桥 |在入站端点和出站端点之间建立直接通道。支持请求响应和单向桥接。可以执行转换。支持入站到出站的交易桥接。
|验证器 |针对定义的验收过滤器验证入站消息。异步返回ACK或NACK响应，并异步分配有效消息。
|===

=== 服务

在推出Mule Flows的Mule ESB 3之前，Mule Services成为Mule应用程序构建的主要架构方法。每个服务都提供了一个用于集成功能的固定框架，因此您必须将每个服务配置为通过入站路由器和端点接收输入，并通过出站路由器和另一端点提供输出。如果你想链接两个或更多的服务，你通常通过VM队列链接它们。

相比之下，一个或多个容易链接的构建块可以创建实现相同功能的流程，同时需要少得多的开发工作量。

MuleSoft建议所有新的应用程序都是围绕Flow实现的，而不是服务。

== 关于Flows

在最简单的层面上，流程是消息处理事件的序列。如以下示意图所示，进入流程的消息可能是：

. 验证（过滤）
. 丰富（附加）
. 转换成新格式，有时首先转换为中间格式
通过自定义编码的业务逻辑处理. 
记录到数据库的. 
对. 进行评估，以确定将什么样的响应返回给提交原始消息的参与方

image:BellsnWhistles.png[BellsnWhistles]

构建流的单元通常称为构建块。通常，这些对应于Mule应用程序配置文件中的Studio图形 link:/mule-user-guide/v/3.2/the-studio-interface[帆布]或 link:/mule-user-guide/v/3.2/the-studio-xml-editor[XML元素]上的图标。

以下屏幕截图演示了Studio图形“画布”上布置的流程。

image:FlowOnCanvas.png[FlowOnCanvas]

以下代码块表示该同一流的XML列表：

[source, xml, linenums]
----
<?xml version="1.0" encoding="UTF-8"?><mule xmlns="http://www.mulesoft.org/schema/mule/core" xmlns:mulexml="http://www.mulesoft.org/schema/mule/xml" xmlns:http="http://www.mulesoft.org/schema/mule/http" xmlns:scripting="http://www.mulesoft.org/schema/mule/scripting" xmlns:doc="http://www.mulesoft.org/schema/mule/documentation" xmlns:spring="http://www.springframework.org/schema/beans" xmlns:core="http://www.mulesoft.org/schema/mule/core" xmlns:wmq="http://www.mulesoft.org/schema/mule/ee/wmq" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="EE-3.2.2" xsi:schemaLocation="http://www.mulesoft.org/schema/mule/xml http://www.mulesoft.org/schema/mule/xml/current/mule-xml.xsd http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd http://www.mulesoft.org/schema/mule/scripting http://www.mulesoft.org/schema/mule/scripting/current/mule-scripting.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd http://www.mulesoft.org/schema/mule/ee/wmq http://www.mulesoft.org/schema/mule/ee/wmq/current/mule-wmq-ee.xsd ">    <flow name="DemoFlow1" doc:name="DemoFlow1">        <http:inbound-endpoint exchange-pattern="request-response" host="localhost" port="8081" doc:name="HTTP"/>        <expression-transformer doc:name="Expression"/>        <append-string-transformer message="" doc:name="Append String"/>        <mulexml:xml-to-object-transformer doc:name="XML to Object"/>        <component doc:name="Java"/>        <logger level="INFO" doc:name="Logger"/>        <scripting:component doc:name="Groovy">            <scripting:script engine="Groovy"/>        </scripting:component>    </flow></mule>
----

=== 流程构建模块

工作室构建块可以分为几个功能类别，其中一些功能类别是由多个构建块组成的处理块。

并非所有构建块都可以占用流内的所有位置。通常，建筑砌块相对于其他流动（或与其附近的建筑砌块有关）的位置会大大影响砌块的行为以及必须如何配置。

以下小节详细介绍了可以填充Mule流的各种构建块（和处理块）。

==== 消息源（可选）

典型流程中的第一个构建块是*Message Source*，它接收来自一个或多个外部源的消息，从而触发流实例。每次它收到另一条消息时，消息源会触发另一个流实例。

有时消息源立即将传入消息放入队列中。这允许消息源关闭接收消息的接收者线程，并立即打开另一个线程接受另一个消息。该消息刚刚放入队列中，等待它到达队列的顶部并可以通过流的其余部分进行处理。由于消息由两个不同的线程按顺序处理（在队列内插入一个中间等待），所以从头到尾的事务处理通常是不可能的。有关优雅的解决方法，请参阅下面的<<Advanced Use Case>>。

image:ThreadHandoff.png[ThreadHandoff]

有时，消息源可以接受来自多个传输通道的传入消息。例如，您可以在称为*Composite Scope*的构建块中嵌入HTTP端点和Servlet端点。无论哪个端点有效接收消息都将成为该特定消息流实例的消息源。或者，您可以填充复合范围以接收IMAP和POP3邮件。

在某些情况下，流量不需要由消息来源触发。例如，一个 link:/mule-user-guide/v/3.2/flow-ref-component-reference[流量参考组件]可以触发一个私有的子流，它可以同步或异步执行，是可重用的，也可以不是，并且继承父流使用的异常策略。有关详情，请参阅下面的<<Child Flows>>。同样， link:/mule-user-guide/v/3.2/async-scope-reference[异步范围]可以触发异步执行的子流程（即与父流程并行）。

==== 消息处理器

通常，这些是预先打包的执行单元，它们以各种方式处理消息。除了消息源外，流中的所有构建块均符合*Message Processors*。与Mule Services相比，它们在很大程度上取代了消息处理器，它具有以下优点：

通常* ，它们不必定制编码
* 它们不必以服务所需的严格方式与路由器，端点和VM队列相互连接
* 多个消息处理器可以组合成各种结构，为您的应用程序提供所需的确切功能

您可以用两种不同的方式将消息处理器组装成应用程序（即主流）序列：

通过在Studio画布上排列图标* 
通过将XML代码插入到应用程序配置文件中* 

消息处理器分为许多方便的类别，如下表所示：

[%header,cols="10a,90a"]
|===
|类别 |简要说明
|端点 |它们分为两个子类别（入站和出站），并为Mule应用程序与外部世界进行通信提供了一种手段。
|范围 |它们以各种方式增强其他消息处理器或称为*Processing Blocks*的消息处理器功能组的功能。
|组件 |它们允许您通过附加日志记录，显示输出甚至子流等功能来增强流。或者，它们通过提供特定于语言的"shells"来促进*Software as a Service*（SaaS）集成，使得定制编码的业务逻辑可用于Mule应用程序。
|变形金刚 |他们通过增强或改变消息头或消息负载来准备要通过Mule流处理的消息。
|过滤器 |单独和组合，它们确定消息是否可以通过应用程序流进行。
|流量控制 |它们指定消息如何在流中各种消息处理器之间路由。它们还可以在将消息路由到其他消息处理器之前处理消息（即聚合，拆分或重新排序）。
|云端连接器 |它们促进Mule应用程序与基于Web的第三方API（如Salesforce和Mongo DB）的集成。
|===

将流程中的各种消息处理程序按正确顺序排列后，可能需要使用以下一种或两种可用选项来配置这些消息处理程序：

* 从Studio图形界面中的可用选项下拉列表中选择或完成文本字段
* 在XML配置代码中输入属性值。 （一个漂亮的预测“自动完成”功能可以大大简化这项任务）

==== 消息处理块

Mule提供了几种将多个消息处理器组合成功能处理块的方法。

例如，复合源范围允许您将单个消息源嵌入两个或更多入站端点，每个端点监听不同的传输通道。只要其中一个侦听器收到传入消息，它就会触发一个流实例并通过消息处理序列启动消息。

其他被称为作用域的构建块提供了多种方式将消息处理器组合到方便的功能组中，使您的XML代码更易于阅读，实现并行处理或创建可重用的构建块序列。

==== 端点

如前所述，端点实现传输通道，以便于从流中插入或提取数据。终端服务于多种角色，具体取决于它们的配置方式。例如，如前所述，它们可以用作入站或出站管道。他们可以实现单向或请求 - 响应交换模式。而且，在某些情况下，您可以将其他类型的消息处理器（如变形金刚）嵌入端点。

===== 入站端点

当放置在一个流的开始处时，无论是单独一个，还是与Composite Source Component中的其他端点一起嵌入时，端点始终被称为入站端点，因为它接受来自外部源的消息并将它们传递给其余端点的流量，从而触发新的流量实例。

并非所有流程都需要入站端点。例如，子流可以通过流引用来触发，该引用不会将任何数据导入到子流中。

并非所有端点都可以用作入站端点。例如，SMTP端点只能用作出站端点。

===== 出站端点

在最基本的层面上，出站端点将数据从流中传递出去。通常它们占用流中的最终消息处理器位置，因此当它们将数据从流中传出时，流实例被视为完成。

但是，出站端点也可以出现在流的中间，例如，随着流的其余部分继续，将数据传递到数据库。

并非所有端点都可以用作出站端点。例如，POP3和IMAP只能用作入站端点。

出站端点也可以配置为请求 - 响应交换模式，如下节所述。

===== 请求 - 响应端点

当入站端点（例如HTTP或VM）配置为请求 - 响应模式时，它们实际上会成为混合入站出站端点。即使其他出站端点存在以从数据流中执行数据，为请求响应交换模式配置的入站端点也会通过向该消息的原始发件人返回响应来执行数据流。

当出站端点配置为请求 - 响应交换模式时，它们可以与流程外部的资源交换数据，或者使用完全在同一Mule应用程序中的一串消息处理器交换数据，如以下示意图所示：

image:req-resp.png[REQ，RESP]

并非所有端点都可以为请求 - 响应交换模式配置，而且可以为请求响应交换模式中的一部分设置默认交换模式。更复杂的是，存在某些情况下（例如JDBC端点），有时可以获得请求响应，但只有当端点配置为出站端点时。

当主流中没有端点被配置为请求 - 响应交换模式时，流遵循单向交换模式，在该模式下它接收传入消息，但不期望对原始发送者提供任何响应。但是，流可能会将数据发送给其他方，例如日志文件，数据库，电子邮件服务器或基于Web的API。

==== 处理策略

处理策略决定Mule如何执行Mule应用程序中的消息处理器序列。例如，当为请求 - 响应交换模式配置消息源时，Mule将处理策略设置为同步，从而确保消息处理器的整个序列执行，并且发送该消息的客户端接收到响应。为了完成这个同步处理，整个流程在一个处理线程上执行。

相比之下，当流程配置为单向非事务交换模式（即，不需要对原始消息发送者作出响应，并且不需要验证流程中的所有步骤都已完成） ，Mule将处理策略设置为排队异步，这有可能提高流量吞吐量。在这种处理策略下，入站端点将收到的消息放入队列中，然后关闭接收器线程。当消息到达队列顶部时，它恢复处理，但这次是在另一个线程上。这意味着，这种处理不能作为事务端到端的限定，因为从一个线程到下一个线程的传输意味着如果抛出异常，处理将无法回滚。

image:ProcessingStrategies.png[ProcessingStrategies]

===== 默认处理策略

所有基于流量的Mule应用程序都是围绕一个主要流程构建的。如果主要流程采用请求 - 响应交换模式，则Mule将默认处理策略设置为同步。如果主流实现事务性，Mule还会将默认处理策略设置为同步。对于所有其他情况，Mule将默认设置为排队异步。

如果Mule将处理策略设置为同步，则无法对其进行更改。另一方面，只要Mule将主流的默认处理策略设置为排队异步，就可以明确强制主流同步运行。

另外，您可以配置子流程以执行以下操作：

* 同步或异步运行
* 继承父流的异常策略，或者实现它自己的一个
* 可重用或不可以

有关更多详情，请参阅 link:/mule-user-guide/v/3.2/flow-processing-strategies[流程处理策略]

==== 例外策略

一个例外策略决定了Mule在消息处理过程中是否发生错误以及何时发生错误。在最简单的情况下，错误只是记录到文件中。

您可以配置异常策略以各种方式响应各种条件。例如，如果在消息转换后引发异常，您可以将消息设置为Mule，以便在消息转换后存在，但紧接在发生错误之前，以便消息不会无意中被处理两次。

有关详情，请参阅： link:/mule-user-guide/v/3.2/error-handling[错误处理]

== 流程架构

Mule Flow非常灵活，所以您可以通过多种方式组合构建模块，通常可以实现相同的结果。然而，对于许多用例，某些消息处理器倾向于陷入某些松散排序的模式。例如，假设您想创建一个应用程序，该应用程序从网页接收产品目录请求，然后将该目录的PDF发回给提交请求的客户端。另外，您希望此流程将客户的客户信息记录到数据库并记录事务，以便您可以跟踪每种类型的目录已发送的数量。你的流可能看起来像这样：

image:DiagramCatalogApp.png[DiagramCatalogApp]


请注意，您可以将过滤器和变换器嵌入到入站端点中，但将它们放入主流程序列中，可以更轻松地在*Studio Message Flow canvas*和基于XML的应用程序配置文件上“读取”事件序列。

image:StudioCatalogApp.png[StudioCatalogApp]

image:XMLCatalogApp.png[XMLCatalogApp]

== 子流程

每个基于Fiow的Mule应用程序都基于主应用程序流程，在最简单的层面上，它是一系列消息处理器，按顺序执行一系列消息处理事件。先进的Mule应用程序可以通过多种以各种方式执行的子流程扩充主应用程序流。这些儿童流量分为两大类：*Synchronous*和*Asynchronous*。

=== 同步

当主要流程触发同步子流程时，它将程序控制传递给该子流程，并挂起其自己的消息处理活动，直到子流程完成其自己的消息处理事件序列并已通过程序控制返回主流程。

由于主要流程和子流程彼此交换程序控制，并且暗示所有处理都发生在同一个线程上，因此可以跟踪消息处理序列中的每个事件，并确保事务性。

==== 子流

子流程继承父流程的处理策略和异常策略。

子流程提供了许多潜在的优势。首先，他们可以隔离逻辑处理块，使底层的XML代码更容易阅读。接下来，它们可以被重用，因此开发人员只需编写一段代码，然后在同一个应用程序中重复引用相同的子流。

虽然子流同步运行，但它可以产生自己的异步子流，它与主流（或父子流本身）并行运行，直到父子流和主流完成。

==== 不是子流的同步子流程

一个特殊类型的子流程与子流程同时运行，但与Subflow不同，此类型的同步子流程使用自己的子流程，而不是父流程的异常策略。当子流内部的消息处理事件要比主流中的其他事件更重要或更不重要时，这会非常有用。无论哪种情况，您都可以将同步子流所用的异常策略设置为与您为主流配置的异常策略执行得非常不同。

=== 异步

异步流程在主流程触发时开始处理。由于这种类型的子流不需要将数据返回到主流，因此它可以与主流同时执行。换句话说，当主流程触发异步流程时，它既不将程序控制传递给异步流程，也不会暂停自己的消息处理，直到异步流程完成执行。换句话说，父流程保留了程序控制吞吐量，而不考虑异步线程的状态。

=== 调用子流程

流参考组件可以调用三种不同类型的子流。

第一种类型称为*Subflow*，它是同步的，并始终继承父流所采用的处理策略和异常策略。在子流程运行时，父流程的处理暂停，并且只有在子流程完成后才会恢复，并将控制权交还给父流程。另外，因为必须命名子流，所以可以通过散布在主流的流参考组件多次引用子流。

第二种类型的子流程被称为*Synchronous Child Flow*，因此可以像Subflow一样被重用。同样，就像子流一样，同步子流也会导致父流暂停，直到它完成执行。但是，与子流不同，同步子流*not*会继承父流所使用的异常策略。这允许将专门的错误处理措施专门应用于同步子流程中的消息处理事件。

您可以通过流参考组件调用的第三种子流称为*Asynchronus Child Flow*。请注意，以这种方式调用的异步流程必须被命名，并且因为它存在于父流程之外，所以可以多次调用它。

由*Async Component*调用的*Asynchronus Child Flow*而不是流参考组件存在于内联中（即在父流程内），并且在特定线程上异步运行，而主线程继续运行没有停顿。

下表详细介绍了用于调用各种子流的组件：

[%header,cols="10,10,10,10,60"]
|===
|儿童类型FLow  |调用组件 |联机？
 （即没有命名
 和不可重复使用） |执行 |异常策略
|子流 |流参考 |否 |同步 |继承
|同步子流 |流参考 |否 |同步 |不被继承
|异步子流 |流参考 |否 |异步 |不被继承
|异步子流 |异步 |是 |异步 |继承
|===

== 流程配置

尽管流程由Studio构建块的序列组成，但不能将任何构建块放置在流程中的任何位置。此外，序列内某些构件块的接近或不存在可以确定给定构件块是否可以放置在流内的某个点处。最后，根据它驻留在流中的位置，给定构件块（尤其是端点）可以为配置公开一组截然不同的属性。

幸运的是，Mule Studio中的图形画布会跟踪所有这些意外事件，并且不会让您在不允许的情况下放置构建块图标。

虽然不可能涵盖可产生可行流程的所有可能的构件块序列，但典型的流程可能会采用以下顺序：

. 由一个或多个入站端点组成的*Message Source*在每次接收到消息时触发流。
. 可能嵌入在消息源中或者在主要流程中嵌入的*Filter*可能会识别无效消息并拒绝将它们传递到流程的其余部分进行处理。
.  *Transformer*可以将传入消息转换为流中其他消息处理器可以消费的数据格式。就像过滤器一样，变压器可以嵌入到消息源中或驻留在主流程中。
.  *Message Enricher*可以将某些重要信息附加到邮件中。例如，如果消息到达时附有地址，则消息丰富者可能使用邮政编码查找关联的电话区号，然后将此信息附加到消息传递者用于市场营销目的。
. 在“准备好”处理消息之后，通常会将其发送给某些预先打包或自定义的业务逻辑（通常称为*Component*），以便可以以适合于其特定内容。有时，外部数据库或API（如Saleforce）可通过称为*Cloud Connectors*的构建块进行利用。
. 流程的最后阶段可能会有很大差异;部分或全部以下情况可能发生：
将* 响应返回给消息的原始发件人
* 业务处理的结果将记录到数据库或发送给其他第三方

在整个流程中，您可以执行以下操作：

* 配置队列（甚至在同一个流程上有多个类型）
* 指定线程模型
* 创建各种类型的子流
* 设置适用于应用程序不同部分的异常策略

== 高级使用案例

下面描述的拓扑结构利用子流，两种类型的队列和集群来创建Mule应用程序，该应用程序有助于以下所有功能：

* 高吞吐量
* 高可用性
* 高可靠性（事务性）

image:AdvancedUseCase.png[AdvancedUseCase]
