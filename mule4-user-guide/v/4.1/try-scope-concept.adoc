= 尝试范围

Try范围允许您处理尝试执行Try范围内的任何组件时可能发生的错误。它也支持交易。 Try范围包装一个或多个事件处理器，然后捕获并处理任何这些封闭事件处理器可能抛出的任何异常。这种行为就好像您使用自己的错误处理策略将这些包含的事件组件提取到单独的流程中，但是内联，而不必实际定义新的流程。

使用Try Scope进行== 错误处理

Try范围有其自己的错误处理策略，您可以使用与为流配置错误处理相同的方式进行配置。它支持内部组件的错误处理，而不是整个流程，因此您不必将它们解压缩到单独的流程中。

image::error-handling-try-scope.png[使用Try Scope进行错误处理]
// image::component-try-config.png[尝试组件配置]

像所有错误处理一样，Try范围也可以区分各种错误类型条件，并将不同的行为应用于每种错误类型条件。

就像在流中引发的任何错误一样，如果Try范围内的组件引发错误，那么将执行Try范围的错误处理程序，并将错误路由到匹配的处理程序。此时，错误可用于检查，所以处理程序可以执行相应的操作：

* 一个On Error继续将执行并使用执行结果作为其所有者的结果，就好像所有者实际上已成功完成执行一样。此时的任何交易也都承诺。
{0}}错误传播会回滚任何事务，执行并使用该结果重新抛出现有错误，这意味着它的所有者将被视为失败。

如果Try作用域有多个组件，那么一旦组件产生一个异常，就会跳过Try作用域中的后续组件，而不管捕获该异常的错误处理程序的类型如何。在On Error Propagate的情况下，错误会传播到流的错误处理，就像Try范围不存在一样。在On Error Continue的情况下，处理在下一个下游流组件的Try范围之外继续，就好像Try范围从未抛出异常。

在上例中，由于On Error Propagate（`on-error-propagate`）设置，所以会传播任何数据库连接错误（DB：CONNECTIVITY）。传播此错误会导致Try进程失败并执行流的错误处理程序。其他错误通过On Error Continue（`on-error-continue`）进行处理，因此Try在发生时被视为成功，这意味着下一个处理器（即HTTP请求）将继续执行。



在你的流程中，你可以将一组事件处理器分组，这些事件处理器可能会在Try Scope中引发错误。 Try Scope允许您在流程中放置各种事件处理器，并为其分配一个Error Handler作用域，以防操作失败。 +
您还可以配置Try Scope内的操作作为事务进行处理。


== 处理事务

您可以配置一个Try范围，以便将其子操作视为不可分割的事务。交易是一系列不应部分执行的操作。事务范围内的每个操作都在同一个线程中执行，并且错误应导致回滚或提交。

image::error-handling-try-scope-config.png[尝试范围配置]

当事务操作（`transactionalAction`）设置为`ALWAYS_BEGIN`或`BEGIN_OR_JOIN`时，Try范围将子操作视为事务。它可以通过以下方式进行配置：

* 忽略（`INDIFFERENT`）：
+
默认。行为不被视为交易。错误不会导致回滚或提交。

* 始终开始（`ALWAYS_BEGIN`）
+
每次执行作用域时都会启动新的事务。

* 开始或加入（`BEGIN_OR_JOIN`）
+
仅在执行顺序可能有所不同的情况下（例如，由于异步操作发生在流程之外）：如果流程的当前处理已经开始事务，则将其加入。否则，开始一个新的。

== 另请参阅

*  link:try-scope-xml-reference[试用Scope XML参考]
*  link:transaction-management[交易管理]
*  link:error-handling[关于错误处理]
*  link:scopes-concept[关于范围]
