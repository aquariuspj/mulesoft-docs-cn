= 解压

// * <<unzip1>>


[[unzip1]]
=====  unzip（Array <Array<T>>）：Array <Array<T>>

执行// * <<zip arrays>>的相反功能。也就是说，只有一个
数组，其中每个索引包含具有两个元素的数组，它会输出
两个分开的阵列，每个阵列都有每对的相应元素。

这也可以放大：如果提供的数组中的索引包含
具有两个以上元素的数组，输出将包含尽可能多的数组
因为每个索引都有元素。

。转变
[source,DataWeave, linenums]
----
%dw 2.0
output application/json
---
{
  a: unzip([[0,"a"],[1,"b"],[2,"c"],[3,"d"]]),
  b: unzip([ [0,"a"], [1,"a"], [2,"a"], [3,"a"]]),
  c: unzip([ [0,"a"], [1,"a","foo"], [2], [3,"a"]])
}
----

.OUTPUT
[source,JSON,linenums]
----
{
   "a":[
      [0, 1, 2, 3],
      ["a", "b", "c", "d"]
    ],
  "b": [
      [0,1,2,3],
      ["a","a","a","a"]
    ],
  "c": [
      [0,1,2,3]
    ]
}
----

请注意，即使示例`b`可以被视为反函数
例如{// <<zip array>>中的`b`，结果不相似，因为它返回
重复元素而不是单个元素的数组。还要注意在
例如`c`，原始数组每个组件中的元素数量
不一致。所以输出只能创建尽可能多的完整阵列，
在这种情况下只有一个。

