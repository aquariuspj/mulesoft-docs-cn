= 添加DataSense支持
:keywords: mule, sdk, metadata, datasense, input, output, keys, type

DataSense是一个Mule服务，它显示模块中实体的类型元数据。

尽管此功能是可选的，但MuleSoft强烈建议您在模块中使用DataSense，以便模块用户更容易使用。

请注意，本文档假定您熟悉连接器的体系结构以及从最终用户角度理解DataSense的概念。


== 什么是组件的元数据？

集成开发人员通常会花费大量时间来确定给定组件（操作，源代码等）的输入和输出类型，以便他们可以转换手头的数据以将一个组件的输出连接到另一个组件的输入。这通常需要使用每个组件的API文档来发现参数。这个过程效率低下，易出错，而且往往令人沮丧。

DataSense使用这些组件提供的元数据自动解析所有这些信息，并在设计时将其呈现给最终用户，这大大提高了开发速度。

术语"types"指的是元素的`MetadataType`。 `MetadataType`表示给定元素的种类和结构，例如`StringType`或`NumberType`，表示基本字符串或数字的元素`ArrayType`，`ObjectType`对于具有嵌套元素的复杂结构（如POJO或JSON对象），对于其类型实际上未知的元素`AnyType`，并且可以是任何其他可用类型。

请参阅 link:/mule4-user-guide/v/4.1/dataweave-types[DataWeave类型]。

=== 静态元数据

静态元数据是在编译时已知的元数据，可以从连接器的JAR文件中获得。简单的Java类型是静态元数据的一部分，开发人员在其模型中定义的自定义POJO也是如此。相关的是，结构是众所周知的，或者可以在不依赖于其他结构的情况下进行内省
参数。

=== 动态元数据

动态元数据是在编译时具有未知结构的类型的元数据。它必须根据设计时连接器的配置来解决。此元数据具有跨越一系列案例的不同用途。从类型本身已知但其结构取决于服务配置的情况（例如系统具有可由用户自定义的字段的帐户的情况）使用跨度，因此必须每次基于用户的凭证）到一切都是动态的情况，并且所描述的结构在很大程度上取决于所配置的参数（例如，所描述的结构是服务操作的有效载荷，其也取决于基于用户沙箱的服务的定义）。

要解析动态元数据，元素必须与元数据解析器相关联，该元数据解析器知道如何根据当前组件配置获取所需的类型结构。这在<<metadata_resolvers, MetaData Resolvers>>中有更详细的解释。

=== 输入元数据

输入元数据是组件参数的类型分辨率。每个参数都可以提供静态或动态元数据，这些元数据与相同组件的其他参数公开的元数据类型相隔离。

只有操作和来源可以具有动态元数据的参数，而配置和连接始终具有静态元数据。

=== 输出元数据

组件的输出绑定到其元数据的静态或动态解析。例如，`void`操作具有指示该操作的输出为`VoidType`的静态元数据，而从远程服务提取`User`配置文件的操作可以动态地描述`User`类型。

如<<module-structure#, Structure>>所述，操作可以输出包含有效负载数据和结果消息属性的结果。这些属性的结构与有效负载的结构一样重要。因此，为了改善最终用户的体验，每个元数据的元数据可以独立描述，但属性的动态元数据始终是可选的，因为某些组件可能不会生成属性。

请注意，某些返回类型被迫动态地描述它们的元数据。此要求是为了保持一致性，因为有必要考虑最终用户的体验，而过于通用的类型会影响用户体验的质量。

== 实施概述

实现动态DataSense支持从定义类型开始
您想要为给定元素提供的元数据。一旦定义，您可以使用注释和自定义实现的组合
不同的元数据解析器，如`@MetadataKeyId(BucketKeysResolver.class)`。使用什么取决于你的用例。

接下来的部分提供了有关实施上述情况的详细信息。

=== 元数据键参数

为了描述一个动态的元数据结构，你需要知道代表什么类型。这种类型的引用是通过定义一个`@MetadataKeyId`参数完成的
该操作将保存要描述的类型的ID。

例如，这意味着如果您的操作可以将通用记录保存到Amazon S3，但您希望通过描述每个受支持的类型结构（例如`Account`或{{1}）来提供更好的设计时体验， }），那么你的一个操作参数将是一个包含id `Account`或id `Organization`的类型引用。该参数将用于描述帐户
结构或记录的组织结构保存到存储桶中，具体取决于最终用户决定使用的内容。

拥有`@MetadataKeyId`参数并不总是必需的，因为您可能只有一个结构（而不​​是多个）来定义根据配置动态变化的结构。例如，您可能有一个`User`实体，其结构根据连接凭据是否为管理员而更改。

[[metadata_resolvers]]
=== 元数据解析器

无论何时您想获取DataSense的动态元素，都需要实现元数据解析器。有许多不同的解析器，每个解决器都有自己的责任和用例（稍后解释），但它们都有这些主要概念：

* 类别名称：关联不同元数据解析器的组的名称，以便它们可以一起使用。

* 解析器名称：唯一标识给定元数据解析器的名称。不同的解析器可以属于同一个`category`，但_must_具有不同的解析器名称。

* 元数据上下文：提供对所有配置和连接的访问
在元数据提取调用期间使用的元素以及一组实用程序组件，如`TypeLoader`和`TypeBuilder`。创建动态类型时始终使用上下文提供的实现很重要。
